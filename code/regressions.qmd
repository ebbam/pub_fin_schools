---
title: "Uneven Wage Growth and Public Goods:"
subtitle: 'The Case of US Public Education'
author:
- name: Ebba Mark
  affiliation: University of Oxford
format:
  pdf:
    documentclass: article
    toc: true
    number-sections: true
    fontsize: 10pt
    include-in-header: 
      text: |
        \usepackage[margin=1in]{geometry}
        \usepackage{tikz}
  html:
    embed-resources: true
    theme: cosmo
    toc: true
    toc_float: true
    toc-expand: 3
    toc-depth: 4
    toc-location: left
params:
  font_size: 6
editor_options: 
  chunk_output_type: console
---

```{r setup-appendix-writer, include=FALSE}
appendix_file <- "appendix_generated.qmd"

# Initialize the file with appendix header only (overwrite if exists)
writeLines(c(
  "# Appendix {.unnumbered}",
  "",
  "```{=latex}",
  "\\appendix",
  "```",
  ""
), appendix_file)

# Define function to append a rendered chunk to it
append_to_appendix <- function(title, description) {
  chunk_label <- knitr::opts_current$get("label")
  lines <- c(
    sprintf("%s", title),
    "",
    description,
    "",
    sprintf("```{r, ref.label='%s', echo = FALSE, eval=TRUE, results = 'asis'}", chunk_label),
    "```",
    ""
  )
  write(lines, file = appendix_file, append = TRUE)
}

```


# Introduction

The following document summarises the progress made thus far on Chapter 1: Local Fiscal Risks of Decarbonisation of my DPhil. The work aims to pursue a better understanding of how industrial transformation impacts local well-being. From an original interest in looking at all aspects of local public finance, the project has narrowed to focus on expenditure on public education and its connection to industrial prosperity and transformation.

Current strategy/research plan: 
1. Outcome: Educational Expenditure
2. Treatment (endogenous): Wages, Economic Growth, Property Values, Property Taxes
3. Instrument: Industry Shares of Employment in high vs. low wage growth industries/sectors - plausible exogeneity comes from industrial shares. Need to justify the choice of base-year for the shift-share instrument such that industries were "present" but still nascent (this is important because there are likely to be certain industries that "cropped up" post-baseline completely unrelated to the industrial composition before right?)

Recall the work from the previous meeting:

1.  After reading more work on US economic geography, it became clear that aggregating counties up to commuting zones was the better choice for analysis at sub-state level as these areas more accurately represent local labour markets/economies/commuting zones ([Fowler et al. 2024](https://www.nature.com/articles/s41597-024-03829-5), [David Dorn's Resource Page](https://www.ddorn.net/data.htm#Local%20Labor%20Market%20Geography)).
2.  Below, I provide some baseline regressions to demonstrate the relationships between key variables in the dataset.
3.  Next, I turn to an instrumental variable application in which I use coal mine counts and production volumes as an instrument for property taxes. Coal mine counts do not serve as good instruments but coal production passes relevance and exogeneity restrictions. I believe a strong argument can be made for the exclusion restriction to be satisfied. I provide supporting statistical tests for all that demonstrate the unfitness of coal mine counts but fitness of coal production. Along this line, we can hopefully discuss other sources of variation in industrial/economic productivity that might lead to property value spirals (positive or negative) to test the property tax channel.
4.  I identify declining vs. growing regions by estimating commuting-zone growth rates conditional on state and national level growth rates. Using this distinction (on both a per capita and total gdp bases and a lenient vs. stringent magnitude threshold), I rerun the key regressions identified in steps 2 and 3 on the subgroups (declining and growing regions).

Note: Any warnings about "missing observations" or "NA being removed" relates to the lags incorporated, except in the Bartik estimations.


```{r, echo = FALSE, message = FALSE}

options(width = 500)
knitr::opts_chunk$set(echo = FALSE, warnings = FALSE, message = FALSE)

library(tidyverse)
library(conflicted)
library(stargazer)
library(zoo)
library(tidycensus)
library(here)
library(viridis)
library(datasets)
library(broom)
library(xtable)
library(fipio)
library(panelvar)
library(fixest)
library(paletteer)
library(readxl)
library(ggrepel)
library(plm)
library(getspanel)
library(usmap)
library(patchwork)
library(kableExtra)
library(lattice)
library(lubridate)
library(stringr)
library(xts)
library(urca)
library(dynlm)
library(tseries)
library(quantmod)
library(lmtest)
library(sandwich)
library(patchwork)
library(vars)
library(assertthat)
library(ggridges)
library(grid)
library(ggplotify)
source(here('code/source_code/useful_functions.R'))
source(here('code/source_code/dicts.R'))
source(here('code/reg_forms.R'))
source(here('code/source_code/cz_cleaning.R'))
conflict_prefer_all("dplyr", quiet = TRUE)

setFixest_etable(fitstat = ~ . + ivf1 + ivf1.p + ivf2 + ivf2.p + wh + wh.p + ivwaldall + ivwaldall.p, se.below = TRUE)

unit_id = "cz_id"

source(here("code/source_code/pull_data.R"))

```

# Data

All data used is reported annually at the commuting zone level. Therefore, no time-invariant variables are included (apart from the State in which a commuting zone is in, which is made time-variant through the inclusion of a state-level trend in various models). 636 commuting zones in 40 states between 2001-2021.

**Expenditure and Revenue:** The dependent variables of interest come from [Willamette University's Government Finance Database](https://willamette.edu/mba/research-impact/public-datasets/index.html). The data includes commuting-zone level revenue and expenditure on public education including disaggregated values by revenue source (federal, state, or other intergovernmental revenue) and expenditure item (lunches, wages, debt). All values are reported in real US dollars. The data for property taxes collected used in regressions below also come from this dataset. Expenditure on vocational training and from Educational Service Agencies (ESAs) are also sourced from this dataset.

**GDP Controls:** US Bureau of Economic Analysis. Values are also reported in current US dollars (real GDP values exist). The controls used in the below are total, private industry, and oil, gas, mining & quarrying commuting zone-level GDP.

**Population controls:** US Census Bureau.

**Coal mine activity and production levels:** Mine Safety and Health Administration

```{r, echo = FALSE, message = FALSE, warnings = FALSE, fig.height = 10}

mean_df <- mines_cz %>% 
  group_by(year) %>%
             summarise(real_Total_Educ_Total_Exp = mean(real_Total_Educ_Total_Exp, na.rm = TRUE),
                       real_Total_Educ_Total_Exp_pp = mean(real_Total_Educ_Total_Exp_pp, na.rm = TRUE),
                       real_log_Total_Educ_Total_Exp = mean(log_real_Total_Educ_Total_Exp, na.rm = TRUE),
                       real_log_Total_Educ_Total_Exp_pp = mean(log_real_Total_Educ_Total_Exp_pp, na.rm = TRUE))

```

## Summary statistics

```{r, eval = FALSE, echo = FALSE}

is.pbalanced(mines_cz, index = c("cz_id", "year"))

```

All dollar values are reported in real 2017-chained thousands. 

```{r, results = 'asis'}

# Variables of interest for descriptive statistics
vars <- c("Property_Tax", "Total_IG_Revenue", "Total_Fed_IG_Revenue", "Total_State_IG_Revenue", "Total_Educ_Total_Exp", "Elem_Educ_Total_Exp") # Total_Revenu

mines_cz %>%
  select(Enrollment, pop_total, real_Elem_Educ_Total_Exp_pp, real_Property_Tax_pp, real_Total_IG_Revenue_pp, real_Total_Fed_IG_Revenue_pp, 
         real_Total_State_IG_Revenue_pp, real_gdp_total_pc, real_gdp_priv_ind_pc, real_gdp_o_g_mining_quarr_21_pc,
         real_Elem_Educ_Total_Exp, real_Property_Tax, real_Total_IG_Revenue, real_Total_Fed_IG_Revenue, 
         real_Total_State_IG_Revenue, real_gdp_total, real_gdp_priv_ind, real_gdp_o_g_mining_quarr_21, total_active_n, total_active_prod) %>% 
  mutate(across(c(real_gdp_total, real_gdp_priv_ind, real_gdp_o_g_mining_quarr_21, real_gdp_total_pc, real_gdp_priv_ind_pc, real_gdp_o_g_mining_quarr_21_pc))) %>%  # gdp_govt, 
          data.frame() %>%
          stargazer(digits = 0, digits.extra = 3, covariate.labels = c(
         "Enrollment",
         "Population",
         "Elem. Expenditure per pupil",
         "Property Tax per pupil",
         "IG Revenue per pupil", 
         "Federal IG Revenue per pupil", 
         "State IG Revenue per pupil",
         "GDP per capita",
         "GDP pc - Private Industry", 
         "GDP pc - Oil, gas, mining",
         "Elem. Expenditure",
         "Property Tax",
         "IG Revenue", 
         "Federal IG Revenue", 
         "State IG Revenue",
         "GDP",
         "GDP - Private Industry", 
         "GDP - Oil, gas, mining",
         "Active Coal Mines",
         "Coal Produced (k short tons)"), type = "latex")


```
<!-- Descriptive Regression Results - Appendix  -->

```{r appendix1, include = FALSE, echo = FALSE, results = 'asis'}
append_to_appendix("# Descriptive Regression Results", 
"In the following set of results, I report descriptive regressions to establish relationships between property taxes, education expenditure, GDP (total, private industry, O&G&mining), etc.
All regression models that follow include TWFE (CZ- and year- fixed effects) and standard errors clustered by commuting zone.
All functional forms in the feols() functions below are of the form Y ~ X In the cases in which multiple estimations are included via sw(Xa, Xb, Xc + Xd), the function will return results for Y~Xa, Y~Xb, Y ~ Xc + Xd.")


```

```{r appendix2, include = FALSE, echo = FALSE, results = 'asis'}

append_to_appendix("## Property Tax ~ GDP",
               "GDP has a highly relevant relationship to property taxes. A 1% increase in GDP (per capita) leads to a 0.38% (0.32%) increase in property taxes collected (per capita).")

run_model(prop_taxes, mines_cz) %>%
  etable(tex = TRUE)

```


```{r appendix3, include = FALSE, echo = FALSE, results = 'asis'}

append_to_appendix("## Education Expenditure ~ Revenue Sources",
               "The below regressions are included to establish the relationship between education expenditure and its component parts. These regressions simply corroborate what is displayed in the section on Key Relationships in [LINK](https://ebbam.github.io/pub_fin_schools/code/cz_results.html) (ie. that the largest form of IG revenue is state funding and Own Source revenue is largely sourced from Property Taxes).")

run_model(educ_source, mines_cz) %>% etable(tex = TRUE)

```


```{r appendix4, include = FALSE, echo = FALSE, results = 'asis'}

append_to_appendix("## Education Expenditure ~ GDP",
               "A 1% increase in GDP pc is associated with a 0.19% increase in education expenditure per pupil, dominated by the effect of GDP from private industry (0.16%). I include here also the GDP generated from the oil, gas, mining, and quarrying sector. The effect is small and statistically insignificant.")

run_model(educ_gdp, mines_cz) %>% 
  etable(tex = TRUE)

```

# Modelling 

## Baseline TWFE Model

### Incorporating time lags

Education expenditure has a highly relevant time dependence. The effect of increases in GDP two years prior has the greatest effect on current education expenditure, implying a delayed effect of commuting zone-level economic growth on public education expenditure. First 6 do not include state time trends; second 6 do.

```{r, message = FALSE, warnings = FALSE, results = 'asis'}

#run_model(selected_twfe_models[1:2], mines_cz) %>% etable(tex = TRUE) 
run_model(selected_twfe_models[3:4], mines_cz) %>% etable(tex = TRUE)
#run_model(selected_twfe_models_levs[1:2], mines_cz) %>% etable(tex = TRUE) 
#run_model(selected_twfe_models_levs[3:4], mines_cz) %>% etable(tex = TRUE)
#run_model(selected_twfe_models_state_share_interaction[1:2], mines_cz) %>% etable(tex = TRUE) 
run_model(selected_twfe_models_state_share_interaction[3:4], mines_cz) %>% etable(tex = TRUE)
#run_model(selected_twfe_models_levs_state_share_interaction[1:2], mines_cz) %>% etable(tex = TRUE) 
#run_model(selected_twfe_models_levs_state_share_interaction[3:4], mines_cz) %>% etable(tex = TRUE)

```

### Incorporating state-level trends

The below take the Education Expenditure \~ GDP models and incorporate deterministic state time trends.

```{r, message = FALSE, warnings = FALSE, results = 'asis'}

# run_model(selected_twfe_models_state_trend[1:2], mines_cz) %>% 
#   etable(drop = "*time", tex = TRUE)

run_model(selected_twfe_models_state_trend[3:4], mines_cz) %>% 
  etable(drop = "*time", tex = TRUE)

```


## Instrumental Variable Approach

There is a significant endogeneity concern in using total active production and active mines as the treatment variable. Therefore, I have tried two instrumental variable approaches below and aim to add results using production- and employment-based Bartik instruments.

We consider using XX as an instrument affecting education expenditure through property taxes or GDP. We know that property taxes have an endogenous relationship with education expenditure, however, in theory, XX is unlikely to affect education expenditure, except via property taxes. We test this hypothesis below.

As a reminder, the intuition behind the idea is:

\begin{figure}[H]
\begin{center}
\caption{Instrumental Variable Path Diagram}
\begin{tikzpicture}
% nodes %
\node[rectangle] (z) at (0,0) {Mining Activity};
\node (t) at (4,0) {Property Taxes};
\node (y) at (8,0) {Education Expenditure};
\node (u) at (4,2) {Omitted variable};

% edges %
\draw[->, line width= 1] (z) --  (t);
\draw [->, line width= 1] (t) -- (y);
\draw[->,line width= 1, red, dashed] (u) --(t);
\draw[->,line width= 1, red, dashed] (u) -- (y);
\end{tikzpicture}
\end{center}
\label{fig:iv_approach}
\end{figure}


A more commonly used identification strategy is via a shift-share or Bartik instrument. A shift-share instrument interacts local industry shares with nationa industry-level growth rates to attain a plausibly exogenous local shock. In the context of this work, we intend to create a unit-specific time-varying treatment variable by interacting a unit-specific, time-invariant industrial employment share variable with a national-level time-varying wage growth rate. 

The literature on Bartik instruments derives plausible exogeneity from two sources. First, authors argue that local industry shares are exogenous by imposing that shares be fixed to a particular base year and are therefore unable to adapt to changes in national-level growth rates. Such a shift-share instrument would look as follows:

\begin{equation}
Z_{it} = \sum_{j=1}^{k} S_{ij\tau}G_{njt} 
\end{equation}

where $S_{ij0}$ is the local share of unit $i$'s economy (potentially measured by metrics like employment, wages, revenue) in industry $j$ at a fixed base year $\tau$ and $G_{njt}$ is the growth rate of industry $j$ at a national level $n$ at time $t$. 

Alternatively, authors may argue that the national-level growth rates are exogenous allowing the shares to vary over time, constructing the shift-share instrument as follows: 

\begin{equation}
Z_{it} = \sum_{j=1}^{k} S_{ijt}G_{njt} 
\end{equation}

Finally, authors might be concerned about the implausible exogeneity of both shares and national-level growth rates in which case they could construct the instrument as follows where the local shares are fixed at a common base year and industry-specific growth rates $G$ are derived from data on other similar regions $o$ rather than national-level changes that are inherently comprised of local-level shifts. This approach likely comes at significant expense to instrument relevance. 

\begin{equation}
Z_{it} = \sum_{j=1}^{k} S_{0jt}G_{ojt} 
\end{equation}

Finally, the authors can make an additional design choice about whether the effect of these instruments should be assumed common to an aggregate local-level wage growth indicator or allowed to vary by industry. In other words, whether to construct the first-stage relationship of the 2SLS as:

\begin{equation}
X_{it} = \alpha_i + \beta\sum_{j=1}^{k}S_{\*j\*}G_{\*j} + \epsilon_{it}
\end{equation}


\begin{equation}
X_{it} = \alpha_i + \sum_{j=1}^{k}\beta_{j}S_{\star j \star}G_{\star jt} + \epsilon_{it}
\end{equation}



```{r, include = FALSE}

# getspanel
# isatpanel(data = mines_cz, 
#           formula = "Total_Educ_Total_Exp_pp ~ gdp_total_pc + gdp_priv_ind_pc + gdp_o_g_mining_quarr_21_pc + gdp_govt_pc",
#           index = c("unit","year"),
#          iis = TRUE,
#          t.pval =0.01
#          # SIS = TRUE 
#           )

```

```{r, fig.height = 10, fig.width = 8, echo = FALSE, cache = TRUE, warning = FALSE, message = FALSE}
# Draw the functions needed to calcualte the SS instruments from the following script. 
source(here("data/raw/QCEW/industry_shares_cleaning.R"))

```


```{r, echo = FALSE}

ss_temp <- compute_shares(source = "QCEW", base_year = 2004, unit_id = "cz_id") %>% 
  compute_ss(.)

p1 <- ss_temp %>% 
  ggplot(aes(x = year, y = ss_2d, group = cz_id)) + 
  geom_line() +
  labs(title = "Shift-Share Instrument: 2-digit NAICS",
       x = "SS Instrument: Local Employment Share * National Industry-Specific Wage Growth",
       y = "Year")

p2 <- ss_temp %>% 
  ggplot(aes(x = year, y = ss_3d, group = cz_id)) + 
  geom_line() +
  labs(title = "Shift-Share Instrument: 3-digit NAICS",
       x = "SS Instrument: Local Employment Share * National Industry-Specific Wage Growth",
       y = "Year")

p1 + p2

iv_model_2d <- feols(
    as.formula("log_real_Elem_Educ_Total_Exp_pp ~ log_real_Total_IG_Revenue_pp + log_real_gdp_total_pc | unit + year | log_hpi ~ ss_2d"),
    data = left_join(mines_cz, rename(ss_temp, unit = cz_id), by = c("year", "unit")))

iv_model_3d <- feols(
    as.formula("log_real_Elem_Educ_Total_Exp_pp ~ log_real_Total_IG_Revenue_pp + log_real_gdp_total_pc | unit + year | log_hpi ~ ss_3d"),
    data = left_join(mines_cz, rename(ss_temp, unit = cz_id), by = c("year", "unit")))

etable(iv_model_2d, iv_model_3d)


```


### Declining vs. Growing Regions

What would be great is to be able to econometrically test when a commuting zone is "declining." In the first step, it would be good to identify when a commuting zone is declining overall (GDP, poverty, etc) but ideally eventually apply this to the education outcome. My hope is that being able to identify counties that are "declining" we can either use this variable as a covariate or as a central point of analysis. The below analysis looks at state-level variables as a first step (mainly to aid in visual comparison and plotting). Ideally, once a method is decided on this would be applied to commuting zone-level data which would need to be summarise/collated in some way for plotting.

```{r, include = FALSE, cache = TRUE}

state_lev <- mines_cz %>% 
  group_by(state, year) %>% 
  summarise(across(c(real_gdp_priv_ind, real_gdp_total, pop_total), ~sum(., na.rm = TRUE))) %>% 
  ungroup %>% 
  mutate(real_gdp_priv_ind_pc = real_gdp_priv_ind/pop_total,
         real_gdp_total_pc = real_gdp_total/pop_total,
         across(!c(state, year), ~log(. + 1), .names = "log_{.col}")) %>% 
  group_by(state) %>% 
  mutate(across(contains("log"), ~.- dplyr::lag(., 1), .names = "diff_{.col}")) %>% 
  ungroup 

natl_lev <- mines_cz %>% 
  group_by(year) %>% 
  summarise(across(c(real_gdp_priv_ind, real_gdp_total, pop_total), ~sum(., na.rm = TRUE))) %>% 
  ungroup %>% 
  mutate(real_gdp_priv_ind_pc = real_gdp_priv_ind/pop_total,
         real_gdp_total_pc = real_gdp_total/pop_total,
         across(!c(year), ~log(. + 1), .names = "log_{.col}"),
         across(contains("log"), ~.- dplyr::lag(., 1), .names = "diff_{.col}"))

growth_rates <- mines_cz %>% 
  select(unit, names(state_lev)) %>%
  left_join(., state_lev, by = c("state", "year"), suffix = c("", "_state")) %>% 
  left_join(., natl_lev, by = c("year"), suffix = c("", "_natl"))

```

### CZ GDP growth conditional on state and national level

```{r, echo = FALSE, fig.height = 8, fig.width = 10, warning = FALSE, cache = TRUE}

trend_forms <- c("trend" = "diff_log_real_gdp_total ~ diff_log_real_gdp_total_state + diff_log_real_gdp_total_natl", 
                "trend_pc" = "diff_log_real_gdp_total_pc ~ diff_log_real_gdp_total_pc_state + diff_log_real_gdp_total_pc_natl")
                # "trend_pc" = "diff_log_real_gdp_total_pc ~ diff_log_real_gdp_total_pc_state")
                 #"trend_pc" = "diff_log_real_gdp_total_pc ~ diff_log_real_gdp_total_pc_natl")

for(k in names(trend_forms)){
  # runs model of growth rate in gdp_total and gdp_total_pc conditional on state and national growth rates
   cz_trends = growth_rates %>% 
    group_by(unit) %>% 
    do(model = lm(as.formula(trend_forms[k]), data = .)) %>% 
    ungroup %>% 
    mutate(!!k := map_dbl(model, ~ pluck(coef(.x), "(Intercept)")))
   
   assign(k, cz_trends)
}

cz_trends <- trend %>% 
  left_join(., trend_pc, by = "unit")

percentiles <- cz_trends %>%
  summarize(
    p25trend = quantile(trend, 0.25, na.rm = TRUE),
    p75trend = quantile(trend, 0.75, na.rm = TRUE),
    p25trend_pc = quantile(trend_pc, 0.25, na.rm = TRUE),
    p75trend_pc = quantile(trend_pc, 0.75, na.rm = TRUE)
  )

cz_trends <- cz_trends %>% 
  mutate(declining = trend < 0,
         declining_extreme = trend < percentiles$p25trend,
         growing_extreme = trend > percentiles$p75trend,
         declining_pc = trend_pc < 0,
         declining_pc_extreme = trend_pc < percentiles$p25trend_pc,
         growing_pc_extreme = trend_pc > percentiles$p75trend_pc)

trend_hist <- cz_trends %>% 
  ggplot() + 
  geom_histogram(aes(x = trend), bins = 75, fill = "blue", alpha = 0.5) +
  geom_vline(aes(xintercept = percentiles$p25trend), 
             color = "darkgreen", linetype = "dashed") +
  geom_vline(aes(xintercept = percentiles$p75trend), 
             color = "purple", linetype = "dashed") +
  labs(x = "CZ Trend Coefficient", title = "Distribution of CZ Trend Coefficients", y = "Frequency") +
  annotate("text", x = percentiles$p25trend, y = 90, label = "25th Percentile", color = "darkgreen", angle = 90, vjust = -0.5) +
  annotate("text", x = percentiles$p75trend, y = 90, label = "75th Percentile", color = "purple", angle = 90, vjust = 1.5) +
  theme_minimal()


trend_pc_hist <- cz_trends %>% 
  ggplot() + 
  geom_histogram(aes(x = trend_pc), bins = 75, fill = "magenta", alpha = 0.5) +
  geom_vline(aes(xintercept = percentiles$p25trend_pc), 
             color = "coral", linetype = "dashed") +
  geom_vline(aes(xintercept = percentiles$p75trend_pc), 
             color = "slateblue", linetype = "dashed") +
  labs(x = "CZ Trend Coefficient", title = "Distribution of CZ Trend Coefficients (pc)", y = "Frequency") +
  annotate("text", x = percentiles$p25trend_pc, y = 65, label = "25th Percentile", color = "coral", angle = 90, vjust = -0.5) +
  annotate("text", x = percentiles$p75trend_pc, y = 65, label = "75th Percentile", color = "slateblue", angle = 90, vjust = 1.5) +
  theme_minimal()

trend_hist / trend_pc_hist

# Declining is inconsistent in 21.5% of cases
cz_trends %>% 
  filter(declining != declining_pc) %>% nrow()/nrow(cz_trends)

# Declining extreme is inconsistent in 15.4% of cases
cz_trends %>% 
  filter(declining_extreme != declining_pc_extreme) %>% nrow()/nrow(cz_trends)

# Growing extreme is inconsistent in 11.9% of cases
cz_trends %>% 
  filter(growing_extreme != growing_pc_extreme) %>% nrow()/nrow(cz_trends)

theme_update(plot.background = element_rect(fill = "#fafaf5", color = "#fafaf5"),
             panel.background = element_rect(fill = NA, color = NA),
             panel.border = element_rect(fill = NA, color = NA),
             panel.grid.major.x = element_blank(),
             panel.grid.minor = element_blank(),
             axis.text.x = element_blank(),
             axis.text.y = element_text(size = 10),
             axis.ticks = element_blank(),
             axis.title.y = element_text(size = 13,
                                         margin = margin(r = 10)),
             legend.title = element_text(size = 9),
             plot.margin = margin(10, 25, 10, 25))

cz_trends_plot <- cz_trends %>% 
  left_join(., distinct(select(mines_cz, unit, state)), by = "unit")

cz_trends_plot$state = sapply(cz_trends_plot$state, get_state) 
cz_trends_plot$region = sapply(cz_trends_plot$state, get_region)

cz_states <- cz_trends_plot %>% 
  group_by(state) %>% 
  arrange(state, trend_pc) %>% 
  mutate(midpt = ifelse(row_number() == round((max(row_number()) - min(row_number()))/2),1, NA)) %>% 
  ungroup %>% 
  mutate(midpt = row_number() * midpt) %>% 
  mutate(unit = factor(unit, levels = unit)) %>%
  ggplot(aes(unit, trend_pc)) +
  geom_segment(aes(x=unit ,xend=unit, y=0, yend=trend_pc, color = state)) +
  geom_point( color="darkblue", size=0.5) +
  geom_label(aes(midpt, 0.15,
                   label = state,
                   color = state),
               fill = NA,
               #family = "Special Elite",
               fontface = "bold",
               label.padding = unit(.2, "lines"),
               label.r = unit(.25, "lines"),
               label.size = .05,
             size = 3) +
  coord_flip() +
  labs(x = "Commuting Zones by State", y = "Trend Coefficient") +
  theme(axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        legend.position = "none")

cz_trend <- cz_trends_plot %>% 
  arrange(trend_pc) %>% 
  mutate(unit = factor(unit, levels = unit)) %>% 
  ggplot(aes(unit, trend_pc)) +
  geom_segment(aes(x=unit ,xend=unit, y=0, yend=trend_pc, color = unit)) +
  geom_point( color="darkblue", size=0.5) +
  coord_flip() +
  labs(x = "Commuting Zones", y = "Trend Coefficient") +
    theme(axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        legend.position = "none")

cz_regions <- cz_trends_plot %>% 
  group_by(region) %>% 
  arrange(region, trend_pc) %>% 
  mutate(midpt = ifelse(row_number() == round((max(row_number()) - min(row_number()))/2),1, NA)) %>% 
  ungroup %>% 
  mutate(midpt = row_number() * midpt) %>% 
  mutate(unit = factor(unit, levels = unit)) %>%
  ggplot(aes(unit, trend_pc)) +
  geom_segment(aes(x=unit ,xend=unit, y=0, yend=trend_pc, color = region)) +
  geom_point( color="darkblue", size=0.5) +
  geom_label(aes(midpt, 0.08,
                   label = region,
                   color = region),
               fill = NA,
               #family = "Special Elite",
               fontface = "bold",
               label.padding = unit(.2, "lines"),
               label.r = unit(.25, "lines"),
               label.size = .05,
             size = 4) +
  coord_flip() +
  labs(x = "Commuting Zones by Region", y = "Trend Coefficient") +
  theme(axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        legend.position = "none") +
 scale_color_brewer(palette = "Set2")


cz_regions + cz_states + cz_trend

```

### Running IV models on declining vs. growing sub-groups {.appendix}

The following implements an employment based Bartik instrument for various industries available from the Quarterly Census of Employment and Wages. 


```{r, echo = FALSE}

mines_cz_decl <- cz_trends %>% 
  select(unit, contains("trend"), contains("growing"), contains("declining")) %>% 
  left_join(mines_cz, ., by = "unit")

# print("Declining")
# run_model(selected_iv_models, filter(mines_cz_decl, declining_pc)) %>% etable(headers = c("INSTR: Total Active Prod", "INSTR: (l1) Total Active Prod","INSTR: Total Active Prod", "INSTR: (l1) Total Active Prod"))
# print("Growing")
# run_model(selected_iv_models, filter(mines_cz_decl, !declining_pc)) %>% etable(headers = c("INSTR: Total Active Prod", "INSTR: (l1) Total Active Prod","INSTR: Total Active Prod", "INSTR: (l1) Total Active Prod"))
# 
# print("Extreme Decline (25th percentile of growth rates)")
# run_model(selected_iv_models, filter(mines_cz_decl, declining_pc_extreme)) %>% etable(headers = c("INSTR: Total Active Prod", "INSTR: (l1) Total Active Prod","INSTR: Total Active Prod", "INSTR: (l1) Total Active Prod"))
# 
# print("Extreme Growth (75th percentile of growth rates)")
# run_model(selected_iv_models, filter(mines_cz_decl, growing_pc_extreme)) %>% etable(headers = c("INSTR: Total Active Prod", "INSTR: (l1) Total Active Prod","INSTR: Total Active Prod", "INSTR: (l1) Total Active Prod"), title = "Hello")

```

### Running base models on declining vs. growing sub-groups

```{r, echo = FALSE, results = 'asis'}
run_model(selected_twfe_models[4], filter(mines_cz_decl, declining_pc)) %>% etable(tex = TRUE)
run_model(selected_twfe_models[4], filter(mines_cz_decl, !declining_pc)) %>% etable(tex = TRUE)

run_model(selected_twfe_models[4], filter(mines_cz_decl, declining_pc_extreme)) %>% etable(tex = TRUE)
run_model(selected_twfe_models[4], filter(mines_cz_decl, growing_pc_extreme)) %>% etable(tex = TRUE)

```

```{r, echo = FALSE, cache = TRUE, include = FALSE}

decl <- filter(mines_cz_decl, declining_pc)
grow <- filter(mines_cz_decl, !declining_pc)

decl_extr <- filter(mines_cz_decl, declining_pc_extreme)
grow_extr <- filter(mines_cz_decl, growing_pc_extreme)

dfs <- list("All" = mines_cz, "Declining" = decl, "Hyper-Declining" = decl_extr, "Growing" = grow, "Hyper-Growing" = grow_extr)

```

```{r, echo = FALSE}

mods <- list()
for(ss in c("ss_2d", "ss_3d")){
  for(df in names(dfs)){
    # IV regression using shift-share instrument
    iv_model <- feols(
   as.formula(paste0("log_real_Elem_Educ_Total_Exp_pp ~ log_real_Total_IG_Revenue_pp + log_real_gdp_total_pc | unit + year | log_hpi ~ ", ss)),
   data = left_join(dfs[[df]], rename(ss_temp, unit = cz_id), by = c("year", "unit"))
    )
    mods[[ss]][[df]] <- iv_model
  }
}

```


```{r, echo = FALSE, cache = TRUE, results = 'asis'}

for(k in names(mods)){
  etable(mods[[k]], title = k, tex = TRUE, headers = names(mods[[k]])) %>% print()
}

```


```{r appendix_ss, echo = FALSE, cache = TRUE, include = FALSE}

append_to_appendix("## Groups",
                   "Industry-level shift-share_instrument")

# compute_ss takes the source data "QCEW" or "QWI", a base year for the Bartik, whether to compute at CZ or fips level. This si then passed to plot_ss() which returns the instrumetn for a specific industry code and a plot. 
ss_temp <- compute_ss_old(source = "QCEW", base_year = 2004, unit_id = "cz_id")

# mods <- list()
# inds <- ind_codes %>% filter(nchar(industry_code) == 2 & industry_code != 99) %>% pull(industry_code) %>% unique
# for(k in inds){
#   ss_inst <- ss_temp %>% 
#     plot_ss_old(., k, "gr_natl_annual_avg_wkly_wage_", "cz_id", ind_codes)
#   
#   name <- ind_codes %>% filter(industry_code == k) %>% pull(industry_title) 
#   
#   # IV regression using shift-share instrument
#   iv_model <- feols(
#     as.formula(paste0("log_real_Elem_Educ_Total_Exp_pp ~ log_real_gdp_total_pc | unit + year | log_hpi ~ ", paste0("ss_", k))),
#     data = left_join(filter(mines_cz), rename(ss_inst, unit = cz_id), by = c("year", "unit"))
#   )
#   mods[[name]] <- iv_model
# }
# 
# mods %>% etable(tex = TRUE)
# 
# # Filter the list of models for significant log_real_gdp_total_pc coefficients
# significant_mods <- mods[sapply(mods, function(m) {
#   coefs <- summary(m)$coeftable
#   if ("fit_log_hpi" %in% rownames(coefs)) {
#     return(coefs["fit_log_hpi", "Pr(>|t|)"] < 0.05)
#   } else {
#     return(FALSE)
#   }
# })]
# 
# # Print table of only significant models
# etable(significant_mods[2:4])
# names(significant_mods[2:3])

# list(summary(mods[["NAICS 21 Mining, quarrying, and oil and gas extraction"]], stage = 1),
# summary(mods[["NAICS 54 Professional, scientific, and technical services"]], stage = 1)) %>% 
#   etable(tex = TRUE)

ind_codes %>% filter(nchar(industry_code) == 2 & industry_code != 99)  %>% select(-keep, -industry_code) %>% xtable() %>% print(include.rownames = FALSE)

ind_mods <- list()
inds <- ind_codes %>% filter(nchar(industry_code) == 2 & industry_code != 99) %>% pull(industry_code) %>% unique
for(k in inds){
    ss_inst <- ss_temp %>% 
      plot_ss_old(., k, "gr_natl_annual_avg_wkly_wage_", "cz_id", ind_codes)
    
    name <- ind_codes %>% filter(industry_code == k) %>% pull(industry_title) 
    
    mods <- list()
    for(df in names(dfs)){
      # IV regression using shift-share instrument
      iv_model <- feols(
        as.formula(paste0("log_real_Elem_Educ_Total_Exp_pp ~ log_real_gdp_total_pc + log_real_Total_IG_Revenue_pp | unit + year | log_hpi ~ ", paste0("ss_", k))),
        data = left_join(dfs[[df]], rename(ss_inst, unit = cz_id), by = c("year", "unit"))
      )
      mods[[df]] <- iv_model
    }
    ind_mods[[k]] <- mods
}

```


```{r, echo = FALSE, cache = TRUE, results = 'asis'}

for(k in names(ind_mods)){ 
  etable(ind_mods[[k]], title = k, tex = TRUE, headers = names(ind_mods[[k]])) %>% print()
}

# Filter the list of models for significant log_real_gdp_total_pc coefficients
significant_mods <- mods[sapply(mods, function(m) {
  coefs <- summary(m)$coeftable
  if ("fit_log_hpi" %in% rownames(coefs)) {
    return(coefs["fit_log_hpi", "Pr(>|t|)"] < 0.05)
  } else {
    return(FALSE)
  }
})]

```

### Removing outliers - really high-income commuting zones!

As you can see in the scatterplot below, there is a somewhat non-linear relationship between property taxes and elementary expenditure as property taxes collected rise. This happens largely as a result of very high-income commuting zones. Therefore, I exclude any commuting zone that spends more than 28k per pupil to avoid any distorting effects. This removes 12 counties (\~2% of the sample) This could benefit from more robust outlier detection. This outlier exclusion weakens our results (and the validity of our instrument choice) in the production-based IV regression. Worth noting and thinking about!!

```{r, echo = FALSE, cache = TRUE}

mines_no_outliers <- mines_cz %>% 
  group_by(unit) %>% 
  filter(!any(log_real_Elem_Educ_Total_Exp_pp > 10.25)) %>% 
  ungroup

mines_cz %>% 
  ggplot(aes(x = log_real_Elem_Educ_Total_Exp_pp, y = log_real_Property_Tax_pp, colour = share_own_discrete)) +
  geom_jitter() +
    #geom_smooth(method=lm, colour = "black", linetype = "dashed") +
  labs(title = "Elem Education Expenditure pp vs Property Tax pp") +
  geom_abline(slope = 1, intercept = 0, linetype = 'dashed') +
  geom_vline(xintercept = 10.25, linetype = 'dashed') +
  theme_bw() +
  theme(title = element_text(size = 9)) +
  labs(colour = "Reliance on Local Sources")

# run_model(iv_prod_tax, mines_no_outliers) %>% etable(tex = TRUE)
# run_model(iv_prod_tax, mines_cz) %>% etable(tex = TRUE)
# run_model(iv_coaln_tax, mines_no_outliers) %>% etable(tex = TRUE)

```


## Panel VAR Specification


$$
Y_{it} = \alpha_i +  \sum_{k = 1}^{4} \gamma_{k}A_{i,t-k} + \beta X_{it} + \varepsilon_{it}
$$

Where we approach a level and per capita value expression of the relationship between total educaiton expenditure, intergovernmental revenue, house prices conditioned on GDP and wage levels. 

$$
Y_{it} = 
\begin{bmatrix}
\log(\text{real Total Educ. Exp.})_{it} \\
\log(\text{real Total IG Revenue})_{it} \\
\log(\text{HPI})_{it}
\end{bmatrix},
\quad
X_{it} = 
\begin{bmatrix}
\log(\text{real GDP})_{it} \\
\log(\text{wage})_{it}
\end{bmatrix}
$$

- $A_1, A_2, A_3, A_4$ are $3 \times 3$ coefficient matrices  
- $\beta$ is a $3 \times 2$ matrix of coefficients on the exogenous variables  
- $\alpha_i$ is a vector of unit fixed effects  
- $\varepsilon_{it}$ is the error term



Where:

$$
Y_{it} = 
\begin{bmatrix}
\log(\text{real Own Source Rev. per person})_{it} \\
\log(\text{real IG Revenue per person})_{it} \\
\log(\text{wage})_{it} \\
\log(\text{HPI})_{it}
\end{bmatrix},
\quad
X_{it} = 
\begin{bmatrix}
\log(\text{real GDP per capita})_{it}
\end{bmatrix}
$$

- $A_1, A_2, A_3, A_4$ are $4 \times 4$ coefficient matrices  
- $B$ is a $4 \times 1$ coefficient matrix  
- $\alpha_i$: unit fixed effects  
- $\varepsilon_{it}$: error term

```{r, echo = FALSE, cache = TRUE}

pvar_data <- mines_cz %>%
  #select(unit, year, contains("real_Total_Educ_Total_Exp"), contains("real_gdp_total")) %>%
  drop_na() %>% 
  data.frame()

# Estimate PVAR with 1 lag
pvar_model_levels <- pvarfeols(
  dependent_vars = c("log_real_Total_Educ_Total_Exp", 
                     #"log_real_Total_Rev_Own_Sources",
                     #"log_real_gdp_total", 
                     #"log_real_Property_Tax",
                     "log_real_Total_IG_Revenue", #"log_real_Total_Fed_IG_Revenue_pp", 
                     #"log_weighted_annual_avg_wkly_wage", 
                     "log_hpi"),
  exog_vars = c("log_real_gdp_total", "log_weighted_annual_avg_wkly_wage"), #"share_own", 
  lags = 4,
  #transformation = "demean",   # alternative: "firstdiff"
  data = pvar_data,
  panel_identifier = c("unit", "year")
)

pvar_model_levels_pc <- pvarfeols(
  dependent_vars = c(#"log_real_Total_Educ_Total_Exp_pp", #"log_real_gdp_total_pc", 
                     "log_real_Total_Rev_Own_Sources_pp",
                     #"log_real_Property_Tax_pp",
                     "log_real_Total_IG_Revenue_pp", 
                     "log_weighted_annual_avg_wkly_wage", #"log_real_Total_State_IG_Revenue_pp", "log_real_Total_Fed_IG_Revenue_pp", 
                     "log_hpi"),
  exog_vars = c("log_real_gdp_total_pc"), #"share_own", 
  lags = 4,
  #transformation = "demean",   # alternative: "firstdiff"
  data = pvar_data,
  panel_identifier = c("unit", "year")
)

for(mod in list(pvar_model_levels, pvar_model_levels_pc)){
  #summary(mod) %>% print
  
  # Impulse response function
  irf_result <- mod %>% girf(n.ahead = 10, ma_approx_steps= 10)

  # irf_result_bootstrapped <- bootstrap_irf(mod, typeof_irf = c("GIRF"),
  #           n.ahead = 10,
  #           nof_Nstar_draws = 3,
  #           confidence.band = 0.95,
  #           mc.cores = 5)
  # Plot IRFs
  plot(irf_result, scales = "free") %>% print()
}


# # Get shock variables (names of shock sources)
# shock_vars <- names(irf_result)
# irf_df <- map_dfr(shock_vars, function(shock) {
#   lower_matrix <- irf_result_bootstrapped$Lower[[shock]]
#   upper_matrix <- irf_result_bootstrapped$Upper[[shock]]
# 
#   # Calculate mean pointwise IRF from bootstrap draws
#   mean_matrix <- (lower_matrix + upper_matrix) / 2
# 
#   expand.grid(
#     horizon = seq_len(nrow(mean_matrix)),
#     response = colnames(mean_matrix)
#   ) %>%
#     mutate(
#       shock = shock,
#       irf = as.vector(mean_matrix),
#       lower = as.vector(lower_matrix),
#       upper = as.vector(upper_matrix)
#     )
# })
# ggplot(irf_df, aes(x = horizon, y = irf)) +
#   geom_line(color = "steelblue") +
#   geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2, fill = "steelblue") +
#   facet_grid(response ~ shock, scales = "free_y") +
#   labs(
#     title = "Impulse Response Functions with 95% Confidence Intervals",
#     x = "Horizon",
#     y = "Response"
#   ) +
#   theme_minimal()

```

# Property Prices

```{r, echo = FALSE, results = 'asis'}
# is <- isatpanel(
#       data = data.frame(mines_cz),
#       formula = as.formula("log_hpi ~ log_weighted_annual_avg_wkly_wage + l1_log_weighted_annual_avg_wkly_wage + l2_log_weighted_annual_avg_wkly_wage"),
#       index = c("unit", "year"),
#       effect = "twoways",
#       #iis = TRUE,
#       fesis = TRUE,
#       #ar = 1,
#       t.pval = 0.01,
#       max.block.size = 5
#     )

fun_list <- c(log_hpi ~ log_weighted_annual_avg_wkly_wage + l1_log_weighted_annual_avg_wkly_wage + l2_log_weighted_annual_avg_wkly_wage + log_real_gdp_total | unit + year,
  
gr_hpi ~ gr_weighted_annual_avg_wkly_wage + l1_gr_weighted_annual_avg_wkly_wage + l2_gr_weighted_annual_avg_wkly_wage | unit + year,

log_real_Elem_Educ_Total_Exp ~ log_weighted_annual_avg_wkly_wage + l1_log_weighted_annual_avg_wkly_wage + l2_log_weighted_annual_avg_wkly_wage + log_real_gdp_total + l1_log_real_gdp_total + l2_log_real_gdp_total | unit + year,

diff_log_real_Elem_Educ_Total_Exp ~ gr_weighted_annual_avg_wkly_wage + l1_gr_weighted_annual_avg_wkly_wage + l2_gr_weighted_annual_avg_wkly_wage + diff_log_real_gdp_total + l1_diff_log_real_gdp_total + l2_diff_log_real_gdp_total | unit + year,

log_real_Elem_Educ_Total_Exp_pp ~ log_weighted_annual_avg_wkly_wage + l1_log_weighted_annual_avg_wkly_wage + l2_log_weighted_annual_avg_wkly_wage + log_real_gdp_total_pc + l1_log_real_gdp_total_pc + l2_log_real_gdp_total_pc | unit + year,

diff_log_real_Elem_Educ_Total_Exp_pp ~ gr_weighted_annual_avg_wkly_wage + l1_gr_weighted_annual_avg_wkly_wage + l2_gr_weighted_annual_avg_wkly_wage + diff_log_real_gdp_total_pc + l1_diff_log_real_gdp_total_pc + l2_diff_log_real_gdp_total_pc | unit + year)

run_model(fun_list, mines_no_outliers) %>% etable(tex = TRUE)
```


```{r, echo = FALSE, results = 'asis'}
# General-to-Specific model selection using fixest
gets_fixest <- function(dep_var, indep_vars, data, fe = NULL, pval_cutoff = 0.1) {
  remaining_vars <- indep_vars
  
  repeat {
    # Build formula
    rhs <- paste(remaining_vars, collapse = " + ")
    formula_str <- as.formula(paste(dep_var, "~", rhs, if (!is.null(fe)) paste("|", fe) else ""))
    
    # Estimate model
    model <- feols(formula_str, data = data)
    coefs <- summary(model)$coeftable
    
    # Filter out only the coefficients from the explanatory variables
    pvals <- coefs[, "Pr(>|t|)"]
    pvals <- pvals[names(pvals) %in% remaining_vars]
    
    # Stop if all variables are below the cutoff or no variables remain
    if (length(pvals) == 0 || all(pvals < pval_cutoff)) break
    
    # Remove the variable with the highest p-value
    worst_var <- names(which.max(pvals))
    remaining_vars <- setdiff(remaining_vars, worst_var)
  }
  
  # Return the final reduced model
  final_formula <- paste(dep_var, "~", paste(remaining_vars, collapse = " + "), if (!is.null(fe)) paste("|", fe) else "")
  return(final_formula)
}

# Example usage
# Replace 'your_data' with your actual data frame name
final_model <- gets_fixest(
  dep_var = "log_real_Elem_Educ_Total_Exp_pp",
  indep_vars = c("log_weighted_annual_avg_wkly_wage",
                 "l1_log_weighted_annual_avg_wkly_wage",
                 "l2_log_weighted_annual_avg_wkly_wage", 
                 "log_real_gdp_total_pc", 
                 "l1_log_real_gdp_total_pc",
                 "l2_log_real_gdp_total_pc", 
                 "log_real_Property_Tax_pp",
                 #"log_real_Total_State_IG_Revenue_pp",
                 #"log_real_Total_Fed_IG_Revenue_pp",
                 "log_hpi"),  # replace with your actual variable names
  data = mines_cz,
  fe = "unit + year",        # optional fixed effects
  pval_cutoff = 0.1         # significance threshold
)

# View results
# At a 10% significance level, we retain a 2-timeperiod lag of real_gdp_pc, contemporaneous wage (not likely), property_tax_pp, state_revenue_pp, hpi
feols(as.formula(final_model), data = mines_cz) %>% etable(tex = TRUE)


# I want to allow the coefficient to vary on the weekly wage treatment variable
feols(as.formula(gsub("log_weighted_annual_avg_wkly_wage", "i(share_own_discrete, log_weighted_annual_avg_wkly_wage)", final_model)), data = mines_cz) %>% etable(tex = TRUE)

```


```{r, child = "appendix_generated.qmd"}
```

