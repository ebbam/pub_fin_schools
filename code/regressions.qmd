---
title: "Uneven Wage Growth and Public Goods"
subtitle: "The Case of US Public Education"
author:
  - name: Ebba Mark
    affiliation: University of Oxford
format:
  pdf:
    documentclass: article
    toc: true
    keep-tex: true
    number-sections: true
    fontsize: 10pt
    pdf-engine: xelatex
    include-in-header: header.tex
    include-before-body:
    - text: |
        \begin{abstract}
        \input{abstract.tex}
        \end{abstract}
    cite-method: natbib 
    biblio-style: unsrt     
editor: 
  markdown: 
    wrap: 72
bibliography: pub_fin_md.bib
editor_options: 
  chunk_output_type: console
---

```{r setup-appendix-writer, include=FALSE}

library(here)
BUILDING_APPENDIX <- TRUE
appendix_file <- "appendix_generated.qmd"

# Initialize the file with appendix header only (overwrite if exists)
writeLines(c(
  "# Appendices {-}",
  "",
  "```{=latex}",
  "\\appendix",
  "```",
  ""
), here(paste0("code/", appendix_file)))


# Append Qmd code chunks to appendix
append_to_appendix <- function(title, description_lines) {
  if (!BUILDING_APPENDIX) return(invisible(NULL))

  chunk_label <- knitr::opts_current$get("label")
  lines <- c(
    title,
    "",
    paste(description_lines, collapse = "\n"),
    "",
    sprintf("```{r, ref.label='%s', echo = FALSE, eval=TRUE, results = 'asis'}", chunk_label),
    "```",
    ""
  )
  write(lines, file = here("code", appendix_file), append = TRUE)
}

# Append additional tex SI files
append_to_appendix_tex <- function(tex_file) {
    lines <- c(
    "",
    "```{=latex}",
    paste0("\\input{", tex_file, "}"),
    "```",
    ""
  )
  write(lines, file = here("code", appendix_file), append = TRUE)
}

```

```{r si_tex_docs, include = FALSE, echo = FALSE}

append_to_appendix_tex(here("code/si_tex_docs/si.tex"))

```

<!-- # Working Notes {#sec-procedural-notes} -->

<!-- \textcolor{violet}{The following are notes to keep in mind while the project is still underway.} -->

<!-- Items to be adjusted: -->

<!-- \begin{itemize} -->

<!--   \item Include additional control variables (migration, poverty, rurality, home ownership rates, private school enrollment) -->

<!--   \item Local CPI. Is local GDP a sufficient proxy for price levels? -->

<!--   \item Spatial autocorrelation term -->

<!--   \item Include discussion of CFESIS result (preliminary testing indicates coefficient breaks in 2006 and 2013 which neatly bookends the financial crisis/housing market collapse - interesting?) -->

<!--   \item Separate shift-share on more coarse industrial categories (ie. high and low-wage areas correcting for local CPI) - in other words, to better answer the research question, divide industries by those whose wages line up with productivity growth and those that do not? -->

<!-- \end{itemize} -->

<!-- Note: Any warnings about "missing observations" or "NA being removed" -->

<!-- relates to the lags incorporated. -->

<!-- \listoffigures -->

<!-- \listoftables -->

# Introduction

**Since the 1970s, a persistent divergence between productivity growth and wage growth has emerged in the United States @hoffmann2020, @stansbury, @economicpolicyinstitute, @elsby2013.** While labour productivity has continued to rise, the earnings of typical workers have increased far more slowly, leading to a substantial decoupling between the two trends. Economists cite various contributors to this phenomenon from human capital @autor2014, @katz1992, @acemoglu2012, @autor2011 to competition @stansbury, @deb2022, @yeh2022, @azar2022, @wilmers2018 to institutional and policy forces @egger2019, @lee1999, @mishel2021, @barkai2020, @autor2016, @card2001, @bivens2013, @stansbury2020 .[^1] Though its causes are hotly debated, the fact itself is well-documented, especially for lower- and middle-income workers, contributing to what is often termed the "hollowing of the middle class" @komlos2018. [^2]

[^1]: Summers & Stansbury 2018 argue that productivity growth still exerts a positive influence on wages overall, but that institutional and structural changes have weakened the link for large segments of the workforce (@summers2018 @stansbury). They point to declining union density, erosion of the minimum wage, globalization, and increased market concentration as key factors that have shifted bargaining power away from workers and reduced labour’s share of national income @autor2014. Furthermore, additional evidence finds that this decoupling is far from a universal phenomenon. Rather, decoupling applies almost strictly to lower- and medium-wage earners, while already higher wages manage to keep up (relatively) with productivity growth rates.

[^2]: Though authors find that wage inequality growth has stagnated in the last decade this is not a result of a "catch-up" effect of lower- or middle-income earners with top income earners, but rather wage growth at the bottom of the wage distribution @aeppli2022. Additionally, further evidence indicates that metric choice can influence the ambiguity of earnings and wage inequality conclusions @parolin2025.

**The direct consequences of this decoupling are clear.** Though households and individuals often have stakes in firm productivity by means other than wages, wages remain the most direct link between aggregate productivity growth and local economic health. Therefore, aggregate productivity growth is not sufficient to secure broad-based improvements in living standards if the most direct link between productivity and livelihoods is weak @mishel2021. Furthermore, in a context in which the benefits of economic growth have already accrued unevenly across communities in the United States by virtue of economic history and industrial concentration, allowing this pattern to continue could have adverse consequences for households and communities @bauluz, @rickard2020, @fee2025, @storper2009 @fallah2011 @benmelech.

<!-- **Regardless of the distribution of wage growth across the country, its -->

<!-- unequal growth has implications for inequality.** Where inequality is -->

<!-- not spatially segregated and high- and low-income households share the -->

<!-- same local markets, the divergence between wages and productivity is -->

<!-- likely to generate upward pressure on prices that disproportionately -->

<!-- burdens lower- and middle-income earners. On the other hand, where -->

<!-- inequality is spatially segregated, patterns of regional divergence -->

<!-- could emerge. -->

**A link that has been far less explored in this context is the spillover effect of local wages to local wealth-building and its effect on public goods.** Wage growth is an important contributor to local wealth-building, allowing households and communities to invest more in local public goods @boustan2013. Communities whose wages rise in line with productivity growth will likely reap the benefits of economic growth whereas those who do not, risk falling behind. This link is particularly important in the US given the structure of local public financing. Majority of local public services are funded via property taxes. This funding structure entrenches a mechanism for generating inequality of opportunity between diversely affluent regions of the country @manduca2025 @weir2021 @schechtl2024 @mettler2011 .[^3] Put plainly, given the structure of US public services, wherein they are tied to asset values, inequality in wealth-building can have significant effects for the quality of local public services. Furthermore, a sometimes lacking, or at best under-performing, federal equalisation systems perpetuates this structural force @beland2017 @biasi2023 @hoxby1998 @mccabe2019 @baker2016 .

[^3]: A burgeoning literature points to the role of racial segregation and its enduring legacy in perpetuating inequality in local economic health, wealth, and public service expenditure @avenancio-león2022 @trounstine2016 @trounstine2021 .

**Community well-being and public expenditure in the US is already characterised by a high degree of spatial heterogeneity @manduca2025, @obrien2025, @feler2017 .** Evidence of how income inequality perpetuates other forms of inequality (opportunity, health, infrastructure quality, and broader well-being) is steadily increasing @chetty2016, @logan2012, @semuels2016, @Avancena2021, @flavin2009. @boustanEffectRisingIncome2013 find that greater income inequality leads to higher public expenditure across all public goods indicating that a presence of higher-earners in a local area contributes to higher levels of expenditure. Though this does not support an unambiguous denunciation of inequality in itself, it provides additional evidence for the fact that local incomes affect public expenditure raising the potential for "superstar" and "left behind" regions to emerge absent even income growth.

**One public service that has particularly important ties to ensuring generational resilience to economic decline is education.** Public schools around the US are responsible for educating over 80% of school-age children. In 2019, governments around the US (including the federal government) spent a total of \$870 billion on public education, roughly \$17,013 per pupil @nationalcenterforeducationstatistics2023. However, the quality of services delivered varies widely across the country @biolsi2022. Take Connecticut for example. In 2016, according to the Connecticut State Department of Education, the town of Greenwich town, one of the highest-income towns in the country, spent \$22,000 per pupil while Bridgeport, although only located 40Km away, spent \$14,000 @semuels2016.

**The quality of public education, especially at an early age, can have long-lasting consequences for personal and economic well-being over an individual's lifetime as well as generations following them @alfonso2020, @zheng2022@unicef .** Although only a small piece of the puzzle that determines quality public education, expenditure levels ensure adequate funding for facilities, teachers, administrators, and other services @baker2017 @baker2025 @jackson2016 . Furthermore, evidence suggests that progressive spending delivers efficiency gains in school performance @rauscher2022 . Therefore, ensuring that local or regional economic decline does not disrupt or worsen the quality of education delivered is of paramount importance to ensure greater equality in the long-run. Altogether, this evidence points to the value of identifying the extent to which expenditure on public education is reliant on local wage growth across the country.

<!-- [^6]: One investigation assessed the dependence of local public revenues -->

<!--     on fossil fuel production finding that such production generated -->

<!--     about \$138 billion annually for US localities, states, tribes, and -->

<!--     the federal government @raimi2022 . This amount is forecast to -->

<!--     decline by 2050 even in a business-as-usual scenario (assuming no -->

<!--     changes in climate policy stringency). Wyoming, North Dakota, -->

<!--     Alaska, and New Mexico are the states most dependent on fossil fuel -->

<!--     revenues with at least 14% of state and local revenues generated -->

<!--     from the fossil fuel industry (Wyoming's dependence is above 50%). -->

<!--     The work makes a demonstrative statement about the link between this -->

<!--     revenue stream and essential services like schools, public health, -->

<!--     and infrastructure, but stops short of an empirical analysis into -->

<!--     the impact of fossil fuel decline on revenues and associated -->

<!--     expenditure, even at the state level. -->

**This study therefore determines whether elasticities of public elementary education expenditure to local wage growth are non-zero.** If productivity gains translate unevenly into wages across regions, then the fiscal capacity of local governments may be shaped as much by institutional and structural conditions as by the distribution of aggregate economic growth. We investigate the following questions:

*RQ1:* Do local wage gains affect public education expenditure in levels?

*RQ2:* If so, is this relationship constant across commuting zones? What sources of heterogeneity mediate this relationship?

*RQ3:* In light of recent reforms to intergovernmental education funding aimed at reducing disparities in educational expenditure, do intergovernmental transfers mitigate wealth-driven inequalities in public education spending?

## Theoretical Motivation and Empirical Approach

Any study of the linkage between two or more local socio-economic outcomes presents considerable endogeneity challenges. In the context of this study, wages and public education expenditure are undoubtedly endogenous. Higher-income families may self-select into districts with greater education spending, confounding causal inference. Lower-income families likely struggle financially to make similar mobility decisions. Local education contributes to the quality of local human capital impacting wages and potentially preferences for education.

Therefore, we approach causal identification by instrumenting local wages using a shift-share instrumental variable design. More precisely, to interrogate the elasticity of public education expenditure to wages across US commuting zones, we construct a shift-share instrument that combines fixed local industry employment shares with national industry-level changes real value added using data from the US Bureau of Labor Statistics and Bureau of Economic Analysis. This instrument generates plausibly exogenous local variation by exploiting how different regions are differentially exposed to common national trends, while abstracting from endogenous local dynamics. It is particularly well suited in this setting, since the local tax base, and thus education spending, likely depends on industries that are unevenly distributed across regions but subject to similar industry-specific wage shocks. Finally, we use this instrument to identify the effect of wage shocks on local public education expenditure as reported by the US Census Bureau's Annual Survey of State and Local Government Finances.

Given the substantial heterogeneity across U.S. states arising both from structural sources (such as differences in tax systems, regulatory environments, and legislative institutions) and from evolved characteristics (including industrial composition, income levels, inequality, and broader measures of economic diversity) the scope for identifying a policy-relevant single national average treatment effect is inherently limited. Therefore, we proceed in two steps. First, we provide an initial benchmark using a pooled estimation to establish a baseline relationship between wages and education expenditure that generalizes reasonably across the national economy. Second, we investigate the regional and industrial heterogeneity that these pooled estimates mask via a state-by-state estimation, industry-by-industry estimation, and grouping commuting zones by their historic wage and GDP growth trajectories to improve comparability of treatment and control groups in our instrumental variable design. In the latter heterogeneity analysis, we construct commuting zone growth rates as idiosyncratic variables absent state and national-level growth rates, understanding that *relative* growth rates are of particular importance in a landscape where local economies determine the actual *value* of wage levels.

## Detailed results

1.  Public education expenditure is not agnostic to local economic conditions. We establish a strong positive causal link between public education expenditure and local wages, wherein a 10% increase in local wages drives a 2.2% increase in public elementary education expenditure, with a long-run increase of 4.6%.
2.  Estimating the instrumental variable model separately for each state reveals substantial heterogeneity in the relationship between wages and education expenditure. Only a third of the 40 states analysed in this study show persistent causal relationships between wages and education expenditure, indicating that these carry the weight of national-level identification. Majority of the states in which we identify a statistically significant effect rely on an above-average share of education funding coming from local sources rather than intergovernmental transfers. Across these states the wage elasticity varies between 2-10% increases in response to a 10% increase in local wages, with Colorado, Florida, and South Dakota exhibiting highest wage elasticities.
3.  Furthermore, we find that this elasticity is strongest (weakest) in magnitude and statsitical significance for commuting zones whose wage growth rates are low (high) relative to those of other regions, indicating the potential risk for depressed education expenditure in regions where wages are stagnating or potentially declining.

In the sections that follow, we outline the various data sources used in @sec-data; provide a detailed overview of our shift-share construction and methodological approach @sec-methods with accompanying results; and conclude with a discussion of policy implications in @sec-discussion.

```{r, echo = FALSE, message = FALSE, cache = FALSE, include = FALSE, eval = TRUE}

options(width = 500)
knitr::opts_chunk$set(echo = FALSE, cache = TRUE, warning = FALSE, message = FALSE, fig.width = 10, fig.height = 10, dev = "ragg_png")

library(tidyverse)
library(conflicted)
library(stargazer)
library(quantreg)
library(purrr)
library(zoo)
library(tidycensus)
library(plm)
library(here)
library(viridis)
library(viridisLite)
library(datasets)
library(broom)
library(xtable)
library(fipio)
library(panelvar)
library(fixest)
library(paletteer)
library(readxl)
library(ggrepel)
library(plm)
library(getspanel)
library(usmap)
library(patchwork)
library(kableExtra)
library(estimatr)
library(lattice)
library(lubridate)
library(stringr)
library(xts)
library(urca)
library(dynlm)
library(tikzDevice)
library(tseries)
library(quantmod)
library(lmtest)
library(sandwich)
library(patchwork)
library(vars)
library(assertthat)
library(ggridges)
library(grid)
library(RColorBrewer)
library(ragg)
library(ggplotify)
extrafont::loadfonts(quiet = TRUE)
source(here('code/source_code/useful_functions.R'))
source(here('code/source_code/dicts.R'))
source(here('code/reg_forms.R'))
source(here('code/source_code/cz_cleaning.R'))
conflict_prefer_all("dplyr", quiet = TRUE)

fitstat_register("iv_fstat", 
                function(x) if (!is.null(x$iv_fstat)) x$iv_fstat else NA, 
                "First-stage F")

fitstat_register("iv_fstat_p", 
                function(x) if (!is.null(x$iv_fstat_p)) x$iv_fstat_p else NA, 
                "F p-value")

fitstat_register("wh_manual", 
                function(x) if (!is.null(x$wu_hausman)) x$wu_hausman else NA, 
                "Wu-Hausman")

fitstat_register("wh_manual_p", 
                function(x) if (!is.null(x$wu_hausman_p)) x$wu_hausman_p else NA, 
                "WH p-value")

fitstat_register("sargan_manual", 
                function(x) if (!is.null(x$sargan)) x$sargan else NA, 
                "Sargan")

fitstat_register("sargan_manual_p", 
                function(x) if (!is.null(x$sargan_p)) x$sargan_p else NA, 
                "Sargan p-value")

# Register marginal F-statistic
fitstat_register("iv_fstat_marg", 
                function(x) if (!is.null(x$iv_fstat_marginal)) x$iv_fstat_marginal else NA, 
                "First-stage F (marginal)")

fitstat_register("iv_fstat_marg_p", 
                function(x) if (!is.null(x$iv_fstat_marginal_p)) x$iv_fstat_marginal_p else NA, 
                "F (marg) p-value")

setFixest_etable(fitstat = ~ . + ivf1 + ivf1.p + iv_fstat + iv_fstat_p + wh + wh.p + ivwaldall + ivwaldall.p + kpr, se.below = TRUE)

#iv_fitstats = ~ n + r2_firststage + ar2_firststage + ivfall + ivfall.p + iv_fstat + iv_fstat_p + wh + wh.p + ivwaldall + ivwaldall.p

iv_fitstats = c("n", "r2", "wr2","iv_fstat", "iv_fstat_p", "wh", "wh.p", "ivwaldall", "ivwaldall.p", "ivf1", "ivf1.p", "iv_fstat_marg", "iv_fstat_marg_p", "wh_manual", "wh_manual_p", "sargan_manual", "sargan_manual_p")

default_iv_note = c("", "Note that the R2 and Adjusted R2 values for second-stage regressions are irrelevant information here. I have not yet figured out how to suppress them from the regression tables but will do so for the final version.")

plot_annotation_theme = theme(
      text = ggplot2::element_text(
    family = "Latin Modern Roman"),
  plot.title = element_text(family = "LMRoman10-Bold",  # Use the exact bold font name
                            size = 16, 
                            face = "bold"),
      plot.subtitle = element_text(size = 12))

unit_id = "cz_id"
new_ss_calculation = FALSE
latex_tables = TRUE

bootstrap_se_spec = TRUE
n_boots = 399
parallel_spec = TRUE

source(here("code/source_code/pull_data.R"))

```

# Data {#sec-data}

We compile a panel dataset of the following indicators across 636 commuting zones (CZ) in 40 US states annually between 2001-2021.

**Expenditure and Revenue:** This work relies on a harmonised repository from Willamette University of the data collected annually as part of the US Census Bureau's Annual Survey of State & Local Government Finances (SLGF). The SLGF is the 'only comprehensive source of information on the finances of local governments in the United States' @pierson. The data includes county-level revenue, property taxes, and expenditure on public education including disaggregated values by revenue source (federal, state, or other intergovernmental revenue) and expenditure item (lunches, wages, debt). All values are reported in real US dollars. We aggregate school district measures up to the commuting zone-level to ensure the availability of adequate control and treatment variables. We choose to conduct the analysis on the commuting zone level because it is a more accurate picture of a local labor market area @carpenterWhenUseCommuting2022. [^4] Our main outcome variable is per pupil spending on elementary education.

[^4]: The database is provided for six different levels of government: state, county, municipal, township, special district, and school district. Reporting is only mandated in Census years (every five years), and even then missing data remains a challenge. This means that data provided at any other level of government suffers from significant levels of missing data, with a high level of selection bias correlated with administrative capacity. However, strengthened by a partnership with the National Center for Education Statistics, observations for US school districts exhibit near-complete coverage between 1997-2021 (@pierson).

**Population controls:** We source commuting-zone level population statistics by aggregating data from county-level populations statistics from the US Census Bureau

**Local GDP:** We gather local GDP control variables by aggregating county-level GDP data from the Bureau of Economic Analysis (BEA). This BEA data is only available after 2001, defining the lower limit of our panel's time dimension. We primarily rely on private industry GDP as a control variable given a large remaining portion of GDP is government expenditure which includes public education expenditure.

**Property Prices:** The US Federal Housing Finance Agency maintains an annual county-level Housing Price Index (HPI) metric, a geographically linked measure of the movement of single-family house prices. The HPI is a weighted, repeat-sales index, measuring average price changes in repeat sales or refinancings on the same properties. This information is obtained by reviewing repeat mortgage transactions on single-family properties whose mortgages have been purchased or securitized by Fannie Mae or Freddie Mac (two US government-sponsored enterprises that guarantee most US mortgages) @usfederalhousingfinanceagency. We aggregate to the commuting zone level via a population-weighted mean.

**Race Controls:** The National Institute of Health National Cancer Institute's Surveillance, Epidemiology, and End Results (SEER) Program provides annual estimates of total White, Black, American Indian/Alaska Native, Asian/Pacific Islander populations at the county level, optionally by Hispanic or non-Hispanic origin @nationalcancerinstitutedccpssurveillanceresearchprogram . Though the US Census Bureau provides county-level estimates of racial make-up of local areas in the American Community Survey, this data is unavailable prior to 2009 and is considered less accurate than those provided by the National Cancer Institute's SEER Database.

**Adequate Education Spending**: The University of Wisconsin's School Finance Indicators Database provides provides detailed data on School Funding Adequacy, measured as the dollar estimate needed per pupil to achieve U.S. average test scores @baker.

This data aggregation results in a complete and balanced panel of 636 US commuting zones across 40 states between 2001-2021. [^5] All data used is reported annually at the commuting zone level. [^6] Therefore, apart from an indicator of a commuting zone's state, all variables are time-variant.

[^5]: 20% of US states are missing from the dataset because (1) we impose an exclusion restriction wherein any commuting zone reporting more than five \$0 values for property taxes collected is excluded due to likely measurement error and (2) Connecticut, Maryland, North Carolina, and Virginia have been excluded due to unconventional or incomplete public school district reporting.

[^6]: In line with similar work on US economic geography, commuting zones were chosen as the unit of analysis as they are a far less arbitrary and more accurate representation of local labour market areas/economies (\href{https://www.ddorn.net/data.htm\#Local\%20Labor\%20Market\%20Geography}{David Dorn's Resource Page}) (\href{https://www.nature.com/articles/s41597-024-03829-5]}{Fowler et al. 2024}).

```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 10, cache = TRUE}

mean_df <- mines_cz %>% 
  group_by(year) %>%
             summarise(real_Total_Educ_Total_Exp = mean(real_Total_Educ_Total_Exp, na.rm = TRUE),
                       real_Total_Educ_Total_Exp_pp = mean(real_Total_Educ_Total_Exp_pp, na.rm = TRUE),
                       real_log_Total_Educ_Total_Exp = mean(log_real_Total_Educ_Total_Exp, na.rm = TRUE),
                       real_log_Total_Educ_Total_Exp_pp = mean(log_real_Total_Educ_Total_Exp_pp, na.rm = TRUE))

```

```{r, eval = FALSE, echo = FALSE, cache = TRUE}

is.pbalanced(mines_cz, index = c("cz_id", "year"))

```

\autoref{tbl_desc_stats} reports summary statistics across relevant variables. All (dollar) values are reported in (real 2017-chained) thousands except for the House Price Index. \autoref{tab:tbl_order_of_integration} represents the order of integration of relevant variables calculated using a unit root test designed for heterogeneous panels @im2003. All variables are integrated I(0) indicating minimal concern for non-stationarity except in the case of enrollment and population numbers.

```{r, results = 'asis', message = FALSE}
# Create pdata for order of integration data:
pdata_mines_cz <- pdata.frame(arrange(mines_cz, unit, year), index = c("unit", "year"))
pdata_mines_cz_diff <- pdata.frame(arrange(filter(mines_cz, year != 2001), unit, year), index = c("unit", "year"))
log_transform = TRUE

# Function for testing stationarity
test_panel_stationarity <- function(pdata, var_name, exog = "intercept", test_type = "ips") {
  #print(var_name)
  if(var_name == "hpi"){
    pdata <- pdata %>% group_by(unit) %>% filter(!all(is.na(hpi))) %>% ungroup
  }
    result <- purtest(pdata[[var_name]],
                     test = test_type,
                     exo = exog,  # use "trend" if variables have trends
                     lags = "AIC",
                     pmax = 4)
    #print(result)

    return(list(
      statistic = result$statistic$statistic,
      p_value = result$statistic$p.value,
      is_stationary = result$statistic$p.value < 0.05
    ))
}

# Determine integration order
vars_to_test <- c("Enrollment", "pop_total", "real_Elem_Educ_Total_Exp_pp",
                  "real_Property_Tax_pp", "real_Total_IG_Revenue_pp",
                  "real_Total_State_IG_Revenue_pp", "real_gdp_total_pc",
                  "real_gdp_priv_ind_pc")#, "hpi")
if(log_transform){
  vars_to_test <- paste0("log_", vars_to_test)
}

# Test levels
level_results <- lapply(vars_to_test, function(v) {
  test_panel_stationarity(pdata_mines_cz, v)
})
names(level_results) <- vars_to_test

integration_orders <- sapply(vars_to_test, function(v) {
  if (level_results[[v]]$is_stationary) {
    return(list(order = "I(0)", diff_p_value = ""))
  } else {
    # Test first difference
    diff_test <- test_panel_stationarity(pdata_mines_cz_diff, paste0("diff_", v), exo = "intercept")
    if (diff_test$is_stationary) {
      return(list(order = "I(1)", diff_p_value = round(diff_test$p_value, 4)))
    } else {
      # # Test second difference if needed
      # # Assuming you have second differences with prefix "diff2_"
      # diff2_test <- test_panel_stationarity(pdata_mines_cz_diff2, paste0("diff2_", v), exo = "intercept")
      # return(list(order = "I(2)", diff_p_value = round(diff2_test$p_value, 3)))
      return()
    }
  }
}, simplify = FALSE)

# Display results with cleaner structure
results_df <- tibble(
  Variable = names(integration_orders),
  `Order of Integration` = sapply(integration_orders, function(x) x$order),
  `I(0) test p-value` = sapply(level_results, function(x) ifelse(round(x$p_value, 4) == 0, "<0.0001",  round(x$p_value, 3))),
  `I(1) test p-value` = sapply(integration_orders, function(x) ifelse(x$diff_p_value == 0, "<0.0001", ""))
)

# Variables of interest for descriptive statistics
vars <- c("Property_Tax", "Total_IG_Revenue", "Total_Fed_IG_Revenue", "Total_State_IG_Revenue", "Total_Educ_Total_Exp", "Elem_Educ_Total_Exp") # Total_Revenu

mines_cz %>%
  select(Enrollment, pop_total, real_Elem_Educ_Total_Exp_pp, real_Property_Tax_pp, real_Total_IG_Revenue_pp,# real_Total_Fed_IG_Revenue_pp, 
         real_Total_State_IG_Revenue_pp, 
         real_gdp_total_pc, real_gdp_priv_ind_pc, #real_gdp_o_g_mining_quarr_21_pc, 
         hpi, pct_black, pct_white, pct_hispanic) %>% 
         #real_Elem_Educ_Total_Exp, real_Property_Tax, real_Total_IG_Revenue, real_Total_Fed_IG_Revenue, 
         #real_Total_State_IG_Revenue, real_gdp_total, real_gdp_priv_ind, real_gdp_o_g_mining_quarr_21, total_active_n, total_active_prod) %>% 
  mutate(across(c(Enrollment, pop_total), ~./1000)) %>%  # gdp_govt, 
          data.frame() %>%
          stargazer(digits = 2, digits.extra = 3, 
                    type = ifelse(latex_tables, "latex", "text"), covariate.labels = c(
         "Enrollment",
         "Population",
         "Elementary Expenditure per pupil",
         "Property Tax per pupil",
         "Intergovernmental (IG) Revenue per pupil", 
         #"Federal IG Revenue per pupil", 
         "State IG Revenue per pupil",
         "GDP per capita",
         "GDP pc - Private Industry",
         "House Price Index",
         "% Black",
         "% White", 
         "% Hispanic"),
         header = FALSE, label = "tbl_desc_stats")
         #"GDP pc - Oil, gas, mining",
         #"Elem. Expenditure",
         #"Property Tax",
         #"IG Revenue", 
         #"Federal IG Revenue", 
         #"State IG Revenue",
         #"GDP",
         #"GDP - Private Industry", 
         #"GDP - Oil, gas, mining",
         #"Active Coal Mines",
         #"Coal Produced (k short tons)"))

results_df %>% 
  mutate(Variable = case_when(Variable == "log_Enrollment" ~ "Enrollment",
         Variable == "log_pop_total" ~ "Population",
         Variable == "log_real_Elem_Educ_Total_Exp_pp" ~ "Elementary Expenditure per pupil",
         Variable == "log_real_Property_Tax_pp" ~ "Property Tax per pupil",
         Variable == "log_real_Total_IG_Revenue_pp" ~ "Intergovernmental (IG) Revenue per pupil", 
         Variable == "log_real_Total_State_IG_Revenue_pp" ~ "State IG Revenue per pupil",
         Variable == "log_real_gdp_total_pc" ~ "GDP per capita",
         Variable == "log_real_gdp_priv_ind_pc" ~ "GDP pc - Private Industry")) %>% 
   kable(.,format = ifelse(latex_tables, "latex", "simple"),
        caption = "Order of Integration",
        booktabs = TRUE,  # This is key for stargazer-like lines
        align = c("l", "c", "c", "c"),  # left, center, center, center
        col.names = c("Variable", "Order of Integration", "I(0) test p-value", "I(1) test p-value"), label = "tbl_order_of_integration") %>%
  kable_styling(full_width = FALSE) %>% 
  footnote(general = "Order of integration determined using the Im-Pesaran-Shin (IPS) panel unit root test with intercept. Lag length selected via AIC with maximum of 4 lags. The null hypothesis is non-stationarity; rejection at the 5% level indicates stationarity. I(0) denotes stationarity in levels and I(1) denotes stationarity in first differences. All variables are log-transformed prior to testing to account for heteroskedasticity.",
           footnote_as_chunk = TRUE,
           threeparttable = TRUE)


```

<!-- ##Descriptive Regression Results - Appendix -->

```{r appendix1, include = FALSE, echo = FALSE, results = 'asis'}

append_to_appendix("# Descriptive Regression Results",
"In the following set of results, I report descriptive regressions to establish relationships between property taxes, education expenditure, GDP (total, private industry, O&G&mining), etc.
All regression models that follow include TWFE (CZ- and year- fixed effects) and standard errors clustered by commuting zone.
All functional forms in the feols() functions below are of the form Y ~ X In the cases in which multiple estimations are included via sw(Xa, Xb, Xc + Xd), the function will return results for Y~Xa, Y~Xb, Y ~ Xc + Xd.")

```

```{r appendix2, include = FALSE, echo = FALSE, results = 'asis'}

append_to_appendix("## Property Tax ~ GDP",
               "GDP has a highly relevant relationship to property taxes. A 1% increase in GDP (per capita) leads to a 0.38% (0.32%) increase in property taxes collected (per capita) (\\autoref{tbl_proptax_gdp}).")

run_model(prop_taxes, mines_cz) %>%
  etable(tex = latex_tables, adjustbox = TRUE, label = "tbl_proptax_gdp")

```

```{r appendix3, include = FALSE, echo = FALSE, results = 'asis'}

append_to_appendix("## Education Expenditure ~ Revenue Sources",
               "The below regressions are included to establish the relationship between education expenditure and its component parts (ie. the largest form of IG revenue is state funding and Own Source revenue is largely sourced from Property Taxes).")

run_model(educ_source, mines_cz) %>% etable(adjustbox = TRUE, tex = latex_tables)

```

```{r appendix4, include = FALSE, echo = FALSE, results = 'asis'}

append_to_appendix("## Education Expenditure ~ GDP",
               "A 1% increase in GDP pc is associated with a 0.19% increase in education expenditure per pupil, dominated by the effect of GDP from private industry (0.16%). I include here also the GDP generated from the oil, gas, mining, and quarrying sector. The effect is small and statistically insignificant.")

run_model(educ_gdp, mines_cz) %>% etable(adjustbox = TRUE, tex = latex_tables)

```

```{r KRs, include = FALSE, echo = FALSE, results = 'asis'}

append_to_appendix("# Key Relationships between Economic Variables",
               "Below we display key relationships between several of the economic variables in our study.")

gdp_plot <- mines_cz %>%
  ggplot(aes(x = log_real_gdp_priv_ind_pc, y = log_real_Elem_Educ_Total_Exp_pp)) +
    geom_jitter(colour = "darkorange2", alpha = 0.5) +
    geom_smooth(method=lm, colour = "black")  +
    labs(x = "log Priv. Industry GDP pc", y = "log Education Expenditure pp") +
    common_theme

hpi_plot <- mines_cz %>%
  ggplot(aes(x = log_hpi, y = log_real_Elem_Educ_Total_Exp_pp)) +
    geom_jitter(colour = "maroon", alpha = 0.5) +
    geom_smooth(method=lm, colour = "black")  +
    labs(x = "log House Prices (Index Value)", y = "log Education Expenditure pp") +
    common_theme

wage_plot <- mines_cz %>%
  ggplot(aes(x = log_weighted_annual_avg_wkly_wage, y = log_real_Elem_Educ_Total_Exp_pp)) +
    geom_jitter(colour = "darkorchid", alpha = 0.5) +
    geom_smooth(method=lm, colour = "black")  +
    labs( x = "log Annual Average Weekly Wage", y = "log Education Expenditure pp") +
    common_theme

pop_plot <- mines_cz %>%
  ggplot(aes(x = log_Enrollment, y = log_real_Elem_Educ_Total_Exp_pp)) +
    geom_jitter(colour = "steelblue", alpha = 0.5) +
    geom_smooth(method=lm, colour = "black")  +
    labs(x = "log Enrollment", y = "log Education Expenditure pp") +
    common_theme 

wage_prop_values <- mines_cz %>%
  ggplot(aes(x = log_weighted_annual_avg_wkly_wage, y = log_hpi)) +
    geom_jitter(colour = "darkgreen", alpha = 0.5) +
    geom_smooth(method=lm, colour = "black")  +
    labs( x = "log Wage", y = "log House Prices (Index Value)") +
    common_theme

(gdp_plot + hpi_plot) / (wage_plot + pop_plot)+ plot_annotation(title = "Key Relationships Between Economic Varables and Ed.Exp.",
                                                                 subtitle = "Commuting Zone Level. 2001-2020.",
                                                                 theme = plot_annotation_theme) 


cat("    \n")
cat("    \n")
cat("    \n")
cat("    \n")


mines_cz %>%
  ggplot(aes(x = log_real_gdp_priv_ind_pc, y = log_real_Total_IG_Revenue_pp)) +
    geom_jitter(, colour = "brown", alpha = 0.5) +
    geom_smooth(method=lm, colour = "black")  +
    labs(title = "IG Transfers (pp) vs. GDP pc", x = "log Priv. Industry GDP pc", y = "log IG Revenue pp") +
    common_theme

```

```{r, echo = FALSE}
# Create reference data frame with state abbreviations and names
states_helper <- data.frame(
  state.abb = state.abb,
  state.name = state.name,
  state.region = state.region
)

# Read your data
wallethub_ranking <- read.csv(here("data/raw/wallethub_ed_ranking/public-school-rankings-by-state-2025.csv")) %>% 
  rename(wallethub_ranking = PublicSchoolRankingsOverallRank_2024,
         usnews_ranking = US_News_Best_States_Education)
# Keeping in case we wish to add more education rankings
rankings <- wallethub_ranking %>% 
  rename(state_full = state)
# # Convert state column to state_name using merge or match
# # Option 1: Using merge
# rankings <- merge(wallethub_ranking, 
#                            states_helper[, c("state.abb", "state.name")], 
#                            by.x = "state", 
#                            by.y = "state.name", 
#                            all.x = TRUE)
# colnames(rankings)[colnames(wallethub_ranking) == "state.name"] <- "state.abb"

# Option 2: Using match (simpler, preserves row order)
rankings$state_name <- states_helper$state.abb[match(rankings$state_full, states_helper$state.name)]
```

```{r, echo = FALSE}

adequ <- read_xlsx(here('data/raw/school_adequacy_indicators/StateIndicatorsDatabase_2025.xlsx'), sheet = 2) %>% 
  filter(year == 2017) %>% 
  # Missing Hawaii, Alaska, Vermont
  select(state_name, stabbr, necm_predcost_state) %>% 
  rename(state_full = state_name, state_name = stabbr) %>% 
  mutate(necm_predcost_state = necm_predcost_state/1000)

```

Figure 1 demonstrates the spread of elementary education expenditure per pupil by commuting zone, grouped by state. Each state's population-weighted mean expenditure per pupil is represented in black. There is considerable within-state variation in per-pupil expenditure levels. Notably, Texas, Montana, and Idaho have commuting zones that spend nearly twice as much as other zones in the same state. Furthermore, the mean level of expenditure is nearly four times as high in the highest-spending state (New York) as in the lowest-spending state, Idaho. We additionally display these values in relation to the estimated "adequate" level of expenditure required for students to achieve U.S. average test scores, represented by the green and red arrows. Majority of states fall short of the deemed adequate expenditure value. Mississippi boasts the greatest shortfall in spending while Wyoming boasts the greatest overshoot in spending. Figure 1 demonstrates the considerable within state variability in spending rates as well as between state variation in levels and student needs.

```{r, echo = FALSE, fig.height = 7, fig.width = 8, fig.cap = "Per Pupil Education Expenditure"}

cz_mean_test <- mines_cz %>% 
  group_by(unit, state) %>% 
  summarise(real_Elem_Educ_Total_Exp_pp = mean(real_Elem_Educ_Total_Exp_pp, na.rm = TRUE),
            pop_total = mean(pop_total, na.rm = TRUE)) %>% 
  ungroup

cz_mean_test$state_name <- sapply(cz_mean_test$state, get_state)

# Calculate scaling factors
expenditure_range <- range(cz_mean_test$real_Elem_Educ_Total_Exp_pp, na.rm = TRUE)
ranking_range <- range(rankings$wallethub_ranking, na.rm = TRUE)
scale_factor <- diff(expenditure_range) / diff(ranking_range)
offset <- expenditure_range[1] - ranking_range[1] * scale_factor

cz_mean_test %>%
  group_by(state_name) %>%
  mutate(state_mean = weighted.mean(real_Elem_Educ_Total_Exp_pp, pop_total, na.rm = TRUE)) %>%
  ungroup() %>%
  left_join(., rankings, by = "state_name") %>% 
  left_join(., adequ, by = "state_name") %>% 
  mutate(state_name = fct_reorder(state_name, state_mean),
         adequacy_ind = necm_predcost_state >= state_mean) %>%
  ggplot(aes(x = state_name, y = real_Elem_Educ_Total_Exp_pp, color = state_name)) +
  geom_jitter(width = 0.2, alpha = 0.4, size = 1.2) +
  geom_point(aes(x = state_name, y = state_mean), shape = 18, size = 3, color = "black") +
    geom_point(data = . %>% filter(adequacy_ind), aes(x = state_name, y = necm_predcost_state), shape = 25, fill = "tomato", color = "tomato", size = 2) +
      geom_point(data = . %>% filter(!adequacy_ind), aes(x = state_name, y = necm_predcost_state), shape = 24, fill = "springgreen4", color = "springgreen4", size = 2) +
      geom_segment(data = . %>% filter(!adequacy_ind), aes(x = state_name, xend = state_name, y = necm_predcost_state, yend = state_mean), size = 0.2, color = "springgreen4") +
   geom_segment(data = . %>% filter(adequacy_ind), aes(x = state_name, xend = state_name, y = necm_predcost_state, yend = state_mean), size = 0.2, color = "tomato") +

  
  # Add rankings (scaled to primary axis, inverted)
  # geom_point(aes(y = (max(wallethub_ranking, na.rm = TRUE) + min(wallethub_ranking, na.rm = TRUE) - wallethub_ranking) * scale_factor + offset), 
  #            shape = 17, size = 1, color = "red", alpha = 0.7) +
  # geom_point(aes(y = (max(usnews_ranking, na.rm = TRUE) + min(usnews_ranking, na.rm = TRUE) - usnews_ranking) * scale_factor + offset),
  #            shape = 17, size = 1, color = "red", alpha = 0.7) +
  
  # Secondary axis (reversed) - use proper formula syntax
  scale_y_continuous(
    name = "Expenditure per pupil (real $)",
    sec.axis = sec_axis(
      trans = ~ max(ranking_range) + min(ranking_range) - ((.) - offset) / scale_factor, 
      name = "State Ranking"
    )
  ) +
  
  labs(
    x = "State (ordered by mean expenditure per pupil)",
    y = "Real Elementary Education Expenditure per Pupil",
    title = "Education expenditure per pupil by commuting zone",
    subtitle = "Scattered points: commuting zones\nBlack diamond: pop-weighted state mean\nRed/green triangle: Predicted adequate K-12 expenditure per pupil (School Finance Indicators Database - University of Wisconsin)"
  ) +
  #geom_hline(yintercept = 13.5) +
  theme_minimal(base_size = 12) +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    plot.subtitle = element_text(size = 10),
    axis.text.x = element_text(angle = 45, hjust = 1),
    panel.grid.minor = element_blank(),
    panel.background = element_blank(),
    legend.position = "none"
  ) +
  ylim(7,25) + 
  common_theme

ggsave(here("output/per_pupil_spending_plot.png"), width = 12, height = 8)
  
```

Figure 2 demonstrates the trajectories of local wages from an initial level in 2001, demonstrating, the diverging wage growth trajectories of commuting zones in our sample. Blue commuting zones represents those exhibiting relatively high wage growth trajectories as deemed by the calculation in @sec-growthrates. The black dashed line represents the annual national wage growth rate.

![Wages and Productivity](../output/wage_trends_plot.png){#fig-wages fig-cap="Wages and Productivity over Time"}

# Methods {#sec-methods}

## Identification Strategy

We are centrally interested in the effect of changes in local wages on public education expenditure where there is an evident endogeneity concern between public education expenditure and wage. First, there is a likely attracting factor of high levels of education expenditure for higher-income families. Second, absent migration, education systems provision local labour markets with individuals with diverse human capital.

\begin{figure}[H]
\centering
\caption{Instrumental Variable Path Diagram}
\begin{tikzpicture}
% nodes %
\node[rectangle] (z) at (0,0) {Instrument};
\node (t) at (4,0) {Local Wages};
\node (y) at (8,0) {Education Expenditure};
\node (u) at (6,-2) {Omitted variable};

% edges %
\draw[->, line width=1] (z) -- (t);
\draw[->, line width=1] (t) -- (y);
\draw[->, line width=1, violet, dashed] (u) -- (t);
\draw[->, line width=1, violet, dashed] (u) -- (y);
\draw[->, line width=1, red, bend right=40, dashed] (y) to (t);
\end{tikzpicture}
\label{fig:iv-approach}
\end{figure}

### Shift-share Instrument

Therefore, we adopt a causal identification strategy via a shift-share instrument. Shift-share or *Bartik* instruments have gained popularity in empirical work as a method of handling endogeneity issues in panel data (@ferri2022, @goldsmith-pinkham2020, @bartik1991).[^7] Such instruments combine time-variant, unit-invariant changes in aggregate economic variables (i.e., national changes in industry value added levels) with time-invariant, unit-variant shares in exposure to these macro-level changes (i.e., local shares of employment in particular industries). This decomposition of local-level changes delocalises variation over space and time. In doing so, it provides a defensible strategy for ‘de-endogenising’ the treatment, as local exposure is predetermined with respect to contemporaneous shocks. Moreover, by construction, the approach enables the examination of how macro-level phenomena propagate to and affect local units, as it generates local shocks that are driven by national industry trends weighted but the community exposure to this industries.[^8]

[^7]: Autor et al. use a shift-share instrument to assess the effect of Chinese import competition on manufacturing employment in US commuting zones (@autor2013). As an extension, @feler2017 use a similar shift-share instrument to assess the effect of the same shock on the size of local government. @baccini2021 employ a shift-share instrument for manufacturing layoffs to tease out the effect of a decline in manufacturing on both economically motivated and racial identity voting patterns in the US.

[^8]: An additional popular indicator for modelling industrial shocks is *oil price* as values are often assumed to be exogenous to local and even national conditions (@scheer2022). Third, various indicators for measuring *deindustrialisation* have been proposed including the manufacturing share of employment, value added, and GDP @tregenna2009, @tregenna2020. Finally, in rare instances, exogeneity can be secured due to *geographical, climatological, or geological factors*. For example, @borge2015 obtain an exogenous measure of local revenue by "instrumenting the variation in hydropower revenue, and thus total revenue, by topology, average precipitation and meters of river in steep terrain." Certain authors have argued that the fact that the location of hydrocarbon deposits is dictated by geomorphological processes provides a plausible argument for exogeneity @esposito2021, @chen2022.

In the context of this work, we construct the instrument by interacting commuting-zone level industrial employment shares held constant at a base period with national real value added growth by industry. The literature on Bartik instruments allows for an argument of plausible exogeneity via various channels. First, authors argue that local industry shares are exogenous by imposing that shares be fixed to a particular base year and are therefore unable to adapt to changes in national-level growth rates. Such a shift-share instrument is designed as in @eq-ref-bartik.

$$
Z_{it} = \sum_{j=1}^{k} S_{ij\tau}G_{njt}
$$ {#eq-ref-bartik}

where $S_{ij\tau}$ is the local share of unit $i$'s economy (measured using metrics like employment, wages, revenue) in industry $j$ at a fixed base year $\tau$ and $G_{njt}$ is the growth rate of industry $j$ at a national level $n$ at time $t$.

Alternatively, authors may argue that the claim of exogeneity in the national-level growth rates is unlikely to be violated even when allowing the local shares to vary over time. This approach is likely to come at significant expense to instrument exogeneity. It is constructed as follows:

$$
Z_{it} = \sum_{j=1}^{k} S_{ijt}G_{njt}
$$

Finally, authors might be concerned about the implausible exogeneity of both shares and national-level growth rates in which case they construct the instrument as in @eq-ref-bartik-2 where the local shares are fixed at a common base year and industry-specific growth rates $G$ are derived from data on other similar regions $o$ rather than national-level changes that are inherently comprised of local-level shifts. This approach likely comes at significant expense to instrument relevance.

$$
Z_{it} = \sum_{j=1}^{k} S_{0jt}G_{ojt}
$$ {#eq-ref-bartik-2}

Finally, the authors can make an additional design choice about whether the effect of these instruments should be assumed common to an aggregate local-level wage growth indicator or allowed to vary by industry. In other words, whether to construct the first-stage relationship of the 2SLS as...:

$$
X_{it} = \alpha_i + \beta\sum_{j=1}^{k}S_{ijt}G_{njt} + \epsilon_{it}
$$

...or...:

$$
X_{it} = \alpha_i + \sum_{j=1}^{k}\beta_{j}S_{j}G_{jt} + \epsilon_{it}
$$

We employ the formulation in @eq-ref-bartik, assuming that base-period local industry shares and time-varying national rates are exogenous to local outcomes and construct the former of the first-stage relationship assuming a common $\beta$ to the sum of these shares.

Using data from the Bureau of Economic Analysis, we construct a shift-share Bartik instrument at the commuting zone level using local employment shares by industry and national changes in industry-specific real value added represented in @eq-bartik. $G_{njt}$ represents national-level changes in value added in industry $j$ in time $t$ and $\frac{N_{ij\tau}}{N_{i\tau}}$ represents the 'sensitivity' of a CZ to these national shocks proxied by an initial share of local employment in industry $j$ in a baseline time period $\tau$. The product of these two values defines the shift-share indicator $\tilde{Z}_{i,t,s}$. In order to construct the share portion, we compute the total local share of employment in a particular industry $j$. Due to challenges with missing data, we compute an average share across 2001-2005 as our 'base year'.

We compute the relevant shift-share instrument across 19 two-digit NAICS industrial categories listed in \autoref{tbl_naics_codes}. Given industry-level disaggregation of local employment data requires data suppression for anonymity reasons, Figure 2 displays the data coverage of our commuting zone level shift-share instruments. Given the high degree of missingness in the 3-digit categorisation we proceed with the 2-digit NAICS codes.

In the Appendices, we provide an additional estimation using a wage-based shift-share instrument constructed using data from the US Bureau of Labor Statistics' Quarterly Census of Employment and Wages (QCEW). This shift-share instrument is constructed as described above using industry-level changes in real wages. Concerns about endogeneity between the instrument and outcome variable are greater using this shift-share instrument and is therefore excluded from the main text. \footnote{We explore the sensitivity of results to the choice of base period
    $\tau$ by constructing the instrument for various base periods as
    well as a rolling window.}

$$
    \tilde{Z}_{it} = \sum_{j=1}^{k}G_{njt} *  \frac{N_{ij\tau}}{N_{i\tau}} 
$$ {#eq-bartik}

### Empirical Estimation

This yields a 2SLS AR(1) model defined by the first- and second-stage regressions represented in @eq-first-stage and @eq-second-stage. Due to the likely presence of time-dynamic effects, we include contemporaneous, 1-year, 2-year time lags as instruments.

$$
\textbf{(First stage)}\qquad
X_{it} \;=\; \rho\,X_{i,t-1} \;+\; \phi \,Y_{i,t-1} \;+\; \sum_{\ell=0}^{2}\pi_{\ell}\,\tilde Z_{i,t-\ell}
\;+\; \boldsymbol{\theta}\mathbf{W}_{it}' \;+\; \alpha_i \;+\; \lambda_t \;+\; u_{it},
$$ {#eq-first-stage}

$$
\textbf{(Second stage)}\qquad
Y_{it} \;=\; \phi^\ast \,Y_{i,t-1} \;+\; \beta\,\widehat{X}_{it}
\;+\; \boldsymbol{\delta}\mathbf{W}_{it}'\;+\;  \alpha_i \;+\; \lambda_t \;+\; \varepsilon_{it}
$$ {#eq-second-stage}

<!-- "Explanation for excluded growth rates: the AR1 beta is nowhere near 1 -->

<!-- and therefore growth rate does not work. the coefficient is a long way -->

<!-- from one which means I do not have to worry about unit roots.", -->

where $W_{it}$ is a vector of control variables. We control for enrollment levels to account for scaling factors in education expenditure, intergovernmental transfers to account for the significant role of such transfers in funding education expenditure, percentage of the population that is Black, percentage of the population that is Hispanic, and private industry GDP per capita levels to account for local price levels.

$Y_{it}$ is the natural logarithm of elementary (serving ages 6-12) education expenditure per pupil for CZ $i$ in year $t$. We focus on elementary education for two reasons. First, this restriction partly shields against a justifiable concern about the endogeneity between wages and quality of local public education. Whereas funding for high school could likely affect local wages given such students are of working age, funding for elementary education is unlikely to impact wage rates via a human capital or skills channel. Second, in terms of public impact, elementary education is of foundational importance in the lives of children. Slips in public education provision at a young age could have scarring effects.

$\alpha_i$ represents a CZ fixed effect and $\lambda_t$ represents year-fixed effects, with stage-relevant superscripts. $\varepsilon_{it}$ and $u_{it}$ represents the error term of the second and first stage, respectively.

We additionally adopt a dynamic specification by including lagged dependent variables in both stages of the IV estimation to avoid spurious correlation identification arising from persistence in expenditure and wage levels, as well as better accounting for heterogeneity across units. Education spending likely exhibits inertia due to slowly evolving budgetary and relevant policy cycles (i.e., property tax rate setting). Similarly, local wage levels are well-predicted by a previous year's wage levels. Failing to account for these dynamics, our estimates would conflate the causal effect of wage innovations with mechanical persistence in levels. This yields a more conservative and interpretable elasticity, though we demonstrate that the exclusion of the AR(1) term in the second-stage yields a contemporaneous effect estimate nearly identical to the long-run wage effect as derived from the dynamic specification in \autoref{tbl_va_ss_baseline}.

### Interpretation

The elasticity of public education expenditure to local wages has an ambiguous interpretation. A positive elasticity would suggest that higher wages increase household savings rates and willingness to invest in local public goods, consistent with standard wealth effects. However, this relationship raises concerns about possible divergence wherein wage growth in high-earning regions could amplify educational investment, potentially widening spatial inequality in public education quality aligning with patterns of income inequality.

Conversely, a negative elasticity could emerge through several channels. Any response in needs-based intergovernmental revenue mechanisms may partially offset local fiscal capacity, creating an inverse relationship between wages and education spending. Alternatively, in more affluent communities, rising wages may enable households to substitute towards private education, crowding out or reducing demand for public expenditure. Furthermore, such a relationship could provide additional empirical support for a "resource curse" dynamic[^9] wherein local communities reprioritise fiscal windfalls toward government expenditure other than public education.

[^9]: Perhaps the most prominent and often-cited relationship between education and extractive industries is through the lens of the 'resource curse.' The validity and empirical existence of a 'resource curse' has been tested since its conception with disparate results [@ahlerup2020, @badeeb2017, @blanco2012, @borge2015, @brunnschweiler2008, @cockx2014, @cockx2016, @deacon2011, @dialga2022, @douglas2017, @haber, @menaldo2016, @ross2018, @ross2015, @sincovich2018, @wiens2014]. The literature is divided into two strands focusing on either political (the relationship between resource wealth and governance) [@ross2015, @ross2015, @wiens2014, @deacon2011] or economic (the relationship between resource wealth and economic growth or human capital) resource curses. Empirical investigation of the economic resource curse has explored the effect of resource dependence on economic growth, public health and education expenditure and outcomes, mainly at a national level [@borge2015, @cockx2016, @douglas2017, @sincovich2018]. In the case of education, the distinct outcome measured is level of educational attainment, in other words, whether the presence of a booming resource extraction economy provides disincentives to education for young people. It is worth noting that this literature has been repeatedly questioned on theoretical and conceptual grounds as institutional context often dictates whether a resource curse exists and empirical analyses seem to be very sensitive to methodological choices [@ross2018, @ross2015, @dialga2022]. Although awareness of this strand of literature is of relevance to this work, the unresolved nature of the 'debate' surrounding its existence requires caution if eventually utilised as a theoretical framework for answering the research question. @ahlerup2020 find that for 30 countries in Africa, the presence of gold mines during adolescence have a significant effect on educational attainment. @badeeb2017 investigates whether resource dependence slows economic growth with no explicit mention of education. @blanco2012 find that in Latin America, petroleum export has a significant long-run negative relationships with human capital. @borge2015 find support for the paradox of plenty hypothesis in Norway - that higher local public revenue negatively affects the efficiency of local public good provision. @brunnschweiler2008 critically evaluate 'the empirical basis for the so-called resource curse and find that, despite the topic's popularity in economics and political science research, this apparent paradox may be a red herring. The most commonly used measure of “resource abundance” can be more usefully interpreted as a proxy for “resource dependence”-endogenous to underlying structural factors. In multiple estimations that combine resource abundance and dependence, institutional, and constitutional variables, we find that (i) resource abundance, constitutions, and institutions determine resource dependence, (ii) resource dependence does not affect growth, and (iii) resource abundance positively affects growth and institutional quality.' @cockx2014 use a panel on 140 countries from 1995-2009 and find an inverse relationship between resource dependence and and public health spending over time. @cockx2016 investigate a panel of 140 countries from 1995-2009 to find an adverse effect of resource depdence on public education expenditures relative to GDP. @dialga2022 find disparate results for health and education controlling for institutional quality. @douglas2017 "measure the effect of resource-sector dependence on long-run income growth using the natural experiment of coal mining in 409 Appalachian counties selected for homogeneity. Using a panel data set (1970–2010), we find a one standard deviation increase in resource dependence is associated with 0.5–1 percentage point long-run and a 0.2 percentage point short-run decline in the annual growth rate of per capita personal income. We also measure the extent to which the resource curse operates through disincentives to education, and find significant effects, but this “education channel” explains less than 15 percent of the apparent curse.' @haber focus on authoriarian regimes. @menaldo2016 argues again that this is an institutions curse and not a resource curse issure. @sincovich2018 provide a literature review of resource curse investigations in the Australian context.

In either case, the consequence of a non-zero elasticity, whether positive or negative, has potential adverse consequences for spatial inequality of public education delivery by either boosting public education in affluent areas or dampening investment in less affluent areas.

Finally, a near-zero elasticity either has a modelling or policy-relevant implication. On the modelling side, a near-zero elasticity could indicate either that the wage-public goods relationship operates on a longer time scale than that examined in this work. This would indicate the need for an alternative identification strategy. Alternatively, a near-zero elasticity could indicate that local public education systems are effectively insulated from local wage changes partly because intergovernmental transfers successfully equalise funding across regions.

### Results

```{r baseline, include = FALSE, echo = FALSE, results = 'asis'}

panel_lines <- c("We descriptively establish foundational relationships between
local economic conditions that seem to reasonably generalise across the
country using an AR(1) two-way fixed effects ordinary least-squares
panel model with standard errors clustered by commuting zone. We outline
the model specification immediately below:",
"\n",
"$$
Y_{it} = \\beta_{0} + \\beta_{x}X_{it} + \\theta Y_{it-1} + \\delta_1 Enrollment_{it} + \\delta_2 IGR_{it} + \\delta_3 Black_{it} + \\delta_3 Hispanic_{it} + \\alpha_i + \\gamma_t + \\varepsilon_{it}
$$ {#eq-desc_function}",
"\n",
"$Y_{it}$ is the natural logarithm of elementary (serving ages 6-12)
education expenditure per pupil for CZ $i$ in year $t$. We focus on
elementary education for two reasons. First, this restriction partly
shields against a justifiable concern about the endogeneity between
wages and quality of local public education. Whereas funding for high
school could likely affect local wages given such students are of
working age, funding for elementary education is unlikely to impact wage
rates via a human capital or skills channel. Second, in terms of public
impact, elementary education is of foundational importance in the lives
of children. Slips in
public education provision at a young age could have scarring effects.
$\\alpha_i$ represents a CZ fixed effect and $\\gamma_t$ represents
year-fixed effects, respectively. $\\varepsilon_{it}$ represents the
error term. We control for enrollment to account for scaling factors in
education expenditure and intergovernmental transfers to account for the
significant role of such transfers in funding education expenditure.
$X_{it}$ takes three forms represented by @eq-gdp-function,
@eq-wage-function, @eq-hpi-function where $h$ represents $h$-year time
lags. We estimate all equations in levels and growth rates.",
"\n",
"$$
X_{it}^{GDP} = \\sum_{h=0}^{2} \\beta_h^{\text{GDP}} \\log(\text{GDP}_{i,t-h})
$$ {#eq-gdp-function}",
"\n",
"$$
X_{it}^{Wage} = \\sum_{h=0}^{2} \\beta_h^{\text{Wage}} \\log(\text{Wage}_{i,t-h})
$$ {#eq-wage-function}",
"\n",
"$$
X_{it}^{HPI} = \\sum_{h=0}^{2} \\beta_h^{\text{HPI}} \\log(\\text{HPI}_{i,t-h})
$$ {#eq-hpi-function}",
"\n",
"\\autoref{tbl_desc_res_lev} reports the results from regressions of log
elementary education expenditure per pupil on contemporaneous and lagged
measures of local economic activity. \\autoref{tbl_desc_res_gr} presents
the analogous specifications using annualized growth rates to capture
short-run dynamics. The estimates in \\autoref{tbl_desc_res_lev} show
that per-pupil education spending is systematically higher in commuting
zones with 'stronger' local economies measured in local wages,
industrial GDP, and house prices.",
"\n",
"Lagged economic indicators, particularly private industry GDP and
average weekly wages, are positively and significantly associated with
education spending. In the baseline specification (Column 1), the
elasticity of education spending with respect to local GDP per capita
(private industry) is positive and statistically significant once lagged
values are included.",
"\n",
"A one-percent increase in local GDP per capita two years prior is
associated with roughly a 0.1% increase in current education expenditure
per pupil, suggesting that fiscal capacity effects unfold gradually over
time. In the case of industry GDP, the magnitude of the coefficients
increases with the number of lags, suggesting a gradual adjustment
process by which local economic growth translates into higher public
investment in education over time. For example, a 1% increase in lagged
(t–2) real private GDP per capita is associated with a 0.06% increase in
per-pupil spending. The house price index also enters positively and
significantly but only contemporaneously reflecting the immediate link
between house prices and the property taxes that fund public education.
This points to the fundamental relationship between community asset
wealth and public education expenditure.",
"\n",
"Intergovernmental revenue per pupil emerges as the strongest and most
consistent predictor of education expenditure after the auto-regressive
coefficient. A 1% increase in intergovernmental transfers is associated
with approximately a 0.2% increase in per-pupil education spending,
controlling for CZ and year fixed effects. This finding highlights the
importance of state and federal aid in sustaining local education
budgets.",
"\n",
"The growth rate regressions, while explaining less variance overall,
largely confirm the patterns observed in the level specifications.
Intergovernmental revenue growth remains a strong and highly significant
determinant of education expenditure growth, with coefficients greater
than 0.3%. Lagged wage and GDP growth also emerge as important
predictors, particularly at longer lags. Notably, wage growth two years
prior is associated with a 0.31% increase in education spending growth,
suggesting that labor market improvements take at least a year to
materialize in local education budgets hinting at the relevance of our
primary identifying relationship.",
"\n",
"Taken together, these results offer three key insights. First, public
education investment is strongly mediated by external fiscal flows,
reaffirming the role of intergovernmental transfers in equalizing local
education finance. Second, local labor market conditions, captured
through wages and GDP, exert lagged effects on education spending
consistent with lagged effects of local economic conditions to
industrial change. Third, local housing markets play a significant role
shaping education budgets, reflecting the link between property values
and tax revenues which respond contemporaneously as a result of the
direct mechanical link between property values and local public revenue
generation.",
"\n",
"Additionally, in both levels and growth rates, the consistently negative
coefficient on enrollment indicates a scaling relationship in which
expenditure per pupil declines as enrollment sizes grow.",
"\n",
"We provide additional robustness checks of these relationships in the
Appendix including estimation using state-level fixed effects. However,
given our interest in commuting-zone specific outcomes, we proceed with
commuting zone level fixed effects. Finally, we approach the estimation
using levels. The coefficient on our AR(1) term is far from 1 which
indicates that unit roots are unlikely to confound our estimation."
)

append_to_appendix("## Baseline Estimates",
  panel_lines
)
  
baseline_sw <- "log_real_Elem_Educ_Total_Exp_pp ~ sw(log_real_gdp_priv_ind_pc + l1_log_real_gdp_priv_ind_pc + l2_log_real_gdp_priv_ind_pc, log_weighted_annual_avg_wkly_wage + l1_log_weighted_annual_avg_wkly_wage + l2_log_weighted_annual_avg_wkly_wage, log_hpi + l1_log_hpi + l2_log_hpi) + l1_log_real_Elem_Educ_Total_Exp_pp + log_real_Total_IG_Revenue_pp + log_Enrollment + pct_black + pct_hispanic"

baseline_sw_short <- "log_real_Elem_Educ_Total_Exp_pp ~ sw(log_real_gdp_priv_ind_pc + l1_log_real_gdp_priv_ind_pc + l2_log_real_gdp_priv_ind_pc, log_weighted_annual_avg_wkly_wage + l1_log_weighted_annual_avg_wkly_wage + l2_log_weighted_annual_avg_wkly_wage, log_hpi + l1_log_hpi + l2_log_hpi + l3_log_hpi + l1_log_real_Elem_Educ_Total_Exp_pp ) + log_real_Total_IG_Revenue_pp + log_Enrollment + pct_black + pct_hispanic"

baseline_full <- "log_real_Elem_Educ_Total_Exp_pp ~ log_real_gdp_priv_ind_pc + l1_log_real_gdp_priv_ind_pc + l2_log_real_gdp_priv_ind_pc + log_weighted_annual_avg_wkly_wage + l1_log_weighted_annual_avg_wkly_wage + l2_log_weighted_annual_avg_wkly_wage + log_hpi + l1_log_hpi + l2_log_hpi + l1_log_real_Elem_Educ_Total_Exp_pp + log_real_Total_IG_Revenue_pp + log_Enrollment + pct_black + pct_hispanic"

baseline_gr_sw <- "diff_log_real_Elem_Educ_Total_Exp_pp ~ l1_diff_log_real_Elem_Educ_Total_Exp_pp + + sw(diff_log_real_gdp_priv_ind_pc + l1_diff_log_real_gdp_priv_ind_pc + l2_diff_log_real_gdp_priv_ind_pc,  gr_weighted_annual_avg_wkly_wage + l1_gr_weighted_annual_avg_wkly_wage + l2_gr_weighted_annual_avg_wkly_wage, gr_hpi + l1_gr_hpi + l2_gr_hpi) + diff_log_real_Total_IG_Revenue_pp + diff_log_Enrollment + pct_black + pct_hispanic"

baseline_gr_full <- "diff_log_real_Elem_Educ_Total_Exp_pp ~ l1_diff_log_real_Elem_Educ_Total_Exp_pp + diff_log_real_gdp_priv_ind_pc + l1_diff_log_real_gdp_priv_ind_pc + l2_diff_log_real_gdp_priv_ind_pc + gr_weighted_annual_avg_wkly_wage + l1_gr_weighted_annual_avg_wkly_wage + l2_gr_weighted_annual_avg_wkly_wage + gr_hpi + l1_gr_hpi + l2_gr_hpi + diff_log_real_Total_IG_Revenue_pp + diff_log_Enrollment + pct_black + pct_hispanic"

c(c(run_model(paste0(baseline_sw, ' | unit + year'), mines_cz)),
     c(run_model(paste0(baseline_full, ' | unit + year'), mines_cz))) %>% etable(adjustbox = TRUE, tex = latex_tables, caption = "Descriptive Results in Levels", label = "tbl_desc_res_lev")

c(c(run_model(paste0(baseline_gr_sw, ' | unit + year'), mines_cz)),
  c(run_model(paste0(baseline_gr_full, ' | unit + year'), mines_cz))) %>% etable(adjustbox = TRUE, tex = latex_tables, caption = "Descriptive Results in Growth Rates", label = "tbl_desc_res_gr")




```

```{r baseline_regs_state_fe, include = FALSE, echo = FALSE, results = 'asis'}

append_to_appendix("## Baseline Regressions with State Fixed Effects",
               "Regressions establishing baseline relationships between local economic variables and elementary education expenditure using state-fixed effects rather than commuting-zone level effects.")

run_model(c(log_real_Elem_Educ_Total_Exp_pp ~ sw(
  log_real_gdp_priv_ind_pc + l1_log_real_gdp_priv_ind_pc + l2_log_real_gdp_priv_ind_pc,
   log_real_gdp_priv_ind_pc + l1_log_real_gdp_priv_ind_pc + l2_log_real_gdp_priv_ind_pc + l1_log_real_Elem_Educ_Total_Exp_pp,
  log_weighted_annual_avg_wkly_wage + l1_log_weighted_annual_avg_wkly_wage + l2_log_weighted_annual_avg_wkly_wage,
  log_weighted_annual_avg_wkly_wage + l1_log_weighted_annual_avg_wkly_wage + l2_log_weighted_annual_avg_wkly_wage + l1_log_real_Elem_Educ_Total_Exp_pp,
  log_hpi + l1_log_hpi + l2_log_hpi + l3_log_hpi + l4_log_hpi,
  log_hpi + l1_log_hpi + l2_log_hpi + l3_log_hpi + l4_log_hpi + l1_log_real_Elem_Educ_Total_Exp_pp
) + log_real_Total_IG_Revenue_pp + log_Enrollment  + pct_black + pct_hispanic | state + year), mines_cz) %>% etable(adjustbox = TRUE, tex = latex_tables)

run_model(c(diff_log_real_Elem_Educ_Total_Exp_pp ~ sw(
  diff_log_real_gdp_priv_ind_pc + l1_diff_log_real_gdp_priv_ind_pc + l2_diff_log_real_gdp_priv_ind_pc,
  diff_log_real_gdp_priv_ind_pc + l1_diff_log_real_gdp_priv_ind_pc + l2_diff_log_real_gdp_priv_ind_pc+ l1_diff_log_real_Elem_Educ_Total_Exp_pp,
  gr_weighted_annual_avg_wkly_wage + l1_gr_weighted_annual_avg_wkly_wage + l2_gr_weighted_annual_avg_wkly_wage,
  gr_weighted_annual_avg_wkly_wage + l1_gr_weighted_annual_avg_wkly_wage + l2_gr_weighted_annual_avg_wkly_wage + l1_diff_log_real_Elem_Educ_Total_Exp_pp,
  gr_hpi + l1_gr_hpi + l2_gr_hpi + l3_gr_hpi + l4_gr_hpi,
  gr_hpi + l1_gr_hpi + l2_gr_hpi + l3_gr_hpi + l4_gr_hpi+ l1_diff_log_real_Elem_Educ_Total_Exp_pp) + diff_log_real_Total_IG_Revenue_pp + diff_log_Enrollment + pct_black + pct_hispanic | state + year), mines_cz) %>% etable(adjustbox = TRUE, tex = latex_tables)



```

\FloatBarrier

```{r funding_share_interaction, include = FALSE, echo = FALSE, results = 'asis'}

append_to_appendix("## Funding Share Interaction",
                   c("Furthermore, given the heterogeneity in reliance on intergovernmental
transfers (largely coming from the state), we interact all economic
predictors above with a variable that represents the share of total
elementary education expenditure (as a continuous variable) coming from
state-level funding.",
"\n",
"\\textcolor{red}{1. heatmap of effect vs. share when varying the share in a linear combinantion of interactive and stand-alone beta. 2. Make sure you can reconcile table 4 and table 2 together by showing that the linear combination of the coefficients using the mean share is the same as in table 2.}"))

selected_twfe_models_state_share_interaction =
  c(log_real_Elem_Educ_Total_Exp_pp ~ sw(state_share*(log_weighted_annual_avg_wkly_wage + l1_log_weighted_annual_avg_wkly_wage + l2_log_weighted_annual_avg_wkly_wage), state_share*(log_hpi + l1_log_hpi + l2_log_hpi + l3_log_hpi + l4_log_hpi)) + log_real_Total_Fed_IG_Revenue_pp + log_Enrollment  + pct_black + pct_hispanic | unit + year,
    log_real_Elem_Educ_Total_Exp_pp ~ sw(state_share*(log_real_gdp_priv_ind_pc + l1_log_real_gdp_priv_ind_pc + l2_log_real_gdp_priv_ind_pc), state_share*(log_weighted_annual_avg_wkly_wage + l1_log_weighted_annual_avg_wkly_wage + l2_log_weighted_annual_avg_wkly_wage), state_share*(log_hpi + l1_log_hpi + l2_log_hpi + l3_log_hpi + l4_log_hpi)) + log_real_Total_Fed_IG_Revenue_pp + log_Enrollment  + pct_black + pct_hispanic | unit + year)
    # log_real_Elem_Educ_Total_Exp_pp ~ sw(state_share*(log_weighted_annual_avg_wkly_wage + l1_log_weighted_annual_avg_wkly_wage + l2_log_weighted_annual_avg_wkly_wage), state_share*(log_hpi + l1_log_hpi + l2_log_hpi + l3_log_hpi + l4_log_hpi + l5_log_hpi)) + log_real_Total_Fed_IG_Revenue_pp + log_Enrollment + l1_log_real_Elem_Educ_Total_Exp_pp | unit + year)


run_model(selected_twfe_models_state_share_interaction, mines_cz) %>% etable(adjustbox = TRUE, tex = latex_tables, order = c("GDP", "Wage", "House Price"), caption = "Descriptive Results with Funding Source Interaction Effects")
#run_model(selected_twfe_models_levs_state_share_interaction[1:2], mines_cz) %>% etable(tex = latex_tables)
#run_model(selected_twfe_models_levs_state_share_interaction[3:4], mines_cz) %>% etable(tex = latex_tables)

```

<!-- ### Incorporating state-level trends -->

<!-- The below take the Education Expenditure \~ GDP models and incorporate -->

<!-- deterministic state time trends. -->

<!-- ```{r, message = FALSE, warning = FALSE, results = 'asis'} -->

<!-- # run_model(selected_twfe_models_state_trend[1:2], mines_cz) %>% -->

<!-- #   etable(drop = "*time", tex = TRUE) -->

<!-- run_model(selected_twfe_models_state_trend[3:4], mines_cz) %>% -->

<!--   etable(drop = "*time", tex = TRUE, adjustbox = TRUE) -->

<!-- ``` -->

```{r load_industry_shares, include = FALSE, echo = FALSE, cache = TRUE}
# Draw the functions needed to calculate the SS instruments from the following script.
source(here("data/raw/QCEW/industry_shares_cleaning.R"))
```

```{r appendix_industry_shares_display, include = FALSE, echo = FALSE, fig.width=10, fig.height=8, results='asis'}

# This chunk has a clean environment - safe to call append_to_appendix
append_to_appendix("## SS Construction Visual",
                   "Plots of the data inputs to the shift-share instrument.")

# Display the plots
p1
cat("\n\n")
p2
cat("\n\n")
p3
```

```{r compute_ss, echo = FALSE, cache = TRUE}

if(new_ss_calculation){
  ss_shares <- compute_shares(source = "QCEW", base_year = 2004, unit_id = "cz_id", flat = FALSE)

  coverage <- ss_shares %>% select(coverage_2digit_naics, coverage_3digit_naics) %>% distinct

  ss_temp <- compute_ss(ss_shares)

  saveRDS(ss_temp, here("code/ss_cache_manual/ss_temp.RDS"))
  saveRDS(coverage, here("code/ss_cache_manual/coverage_ss.RDS"))
}else{
  ss_temp <- readRDS(here("code/ss_cache_manual/ss_temp.RDS"))
  coverage <- readRDS(here("code/ss_cache_manual/coverage_ss.RDS"))
}

```

```{r, echo = FALSE, cache = FALSE, results = 'asis', message = FALSE}

rel_inds <- c("Agriculture, Forestry, Fishing, and Hunting" = "11",
"Mining" = "21",
"Construction" = "23",
"Manufacturing" = "31_33",
"Wholesale Trade" = "42",
"Retail Trade" = "44_45",
"Transportation and Warehousing" = "48_49",
"Utilities" = "22",
"Information" = "51",
"Finance and Insurance" = "52",
"Real Estate and Rental and Leasing" = "53",
"Professional, Scientific, and Technical Services" = "54",
"Management of Companies and Enterprises" = "55",
"Administrative and waste management services" = "56",
"Educational Services" = "61",
"Health Care and Social Assistance" = "62",
"Arts, Entertainment, and Recreation" = "71",
"Accommodation and Food Services" = "72",
"Other Services, except government" = "81",
"Public Administration" = "92")

data.frame("NAICS.Code" = unname(rel_inds), "Industry" = names(rel_inds))  %>% 
  mutate(NAICS.Code = gsub("_", "-", NAICS.Code)) %>% 
  xtable(label = "tbl_naics_codes", caption = "Industry Categories") %>% print(include.rownames = FALSE, comment = FALSE)

```

```{r fig_wage_elasticity, echo = FALSE, cache = TRUE, fig.height = 8, fig.width = 8, fig.cap = "Data Coverage of Industry-level Employment as Share of Total Reported Employed"}

probs <- c(0.05, 0.25, 0.75, 0.95)
percentiles_coverage <- quantile(
  coverage$coverage_2digit_naics,
  probs = probs,
  na.rm = TRUE
)

# convert to data frame for plotting
percentile_df <- data.frame(
  x = percentiles_coverage,
  label = paste0(names(percentiles_coverage))
)

coverage %>%
  ggplot() +
  geom_histogram(aes(x = coverage_3digit_naics, fill = "3-digit NAICS Codes"), alpha = 0.8, bins = 30) +
  geom_histogram(aes(x = coverage_2digit_naics, fill = "2-digit NAICS Codes"), alpha = 0.8, bins = 30) +
geom_vline(data = percentile_df,
             aes(xintercept = x),
             linetype = "dashed", color = "black", linewidth= 0.3) +
  geom_text(data = percentile_df,
            aes(x = x, y = 80, label = label),
          vjust = -0.5, hjust = 1,
            size = 2.5) +
  labs(x = "% Coverage of CZ's Employed by NAICS sub-categorisation",
       y = "No. CZs",
       title = "Data Coverage of Industry-level Employment as Share of Total Reported Employed",
       subtitle = "Data coverage is calculated as the fraction of total local employment accounted for in the industry-specific employment values. \n Percentage labels represent proportion of commuting zones (percentiles) falling below a coverage value.",
       fill = "NAICS Specificity") +
  common_theme +
  theme(legend.position = "bottom") +
  scale_fill_brewer(palette = "Pastel1")

```

```{r, echo = FALSE, cache = TRUE}

if(new_ss_calculation){
  temp_new <- shares_flat_filled %>%
    select(!contains("share")) %>%
    filter(year <= 2005) %>%
    group_by(unit) %>%
    # Creates a mean employment level across 2001-2005 - 5 year mean to deal with missing data
    summarise(across(!year, ~mean(., na.rm = TRUE))) %>%
    ungroup  %>%
    rename(fips = unit)

    if(unit_id == "cz_id"){
      czs_new <- czs %>%
        #select(-old_fips) %>%
        rename(old_fips = fips) %>%
        mutate(fips = case_when(!is.na(getfips[old_fips]) ~ getfips[old_fips],
                                TRUE ~ old_fips),
               cz_id = as.character(cz_id))

      missing_fips <- czs_new %>%
        pull(fips) %>%
        unique %>%
        setdiff(unique(temp_new$fips), .)

      if (length(missing_fips) > 0) {
        message("Warning: Some FIPS codes are missing from czs.")
      }

      temp <- temp_new %>%
        select(fips, matches("^annual_avg_emplvl_\\d{2}$"), annual_avg_emplvl_10_filled) %>%
        left_join(., czs_new, by = "fips", multiple = "first") %>%
        rename("unit" = cz_id) %>%
        select(-c(fips, old_fips, cz_population, cz_id_1990)) %>%
        relocate(unit)

    }else if(unit_id == "fips"){
      temp <- temp %>%
        rename(unit = fips)
    }


  shift_share_filled <- temp %>%
      group_by(unit) %>%
      summarise(across(everything(), ~sum(., na.rm = TRUE))) %>%  # , total_annual_wages)
                #annual_avg_wkly_wage = mean(annual_avg_wkly_wage, na.rm = TRUE)) %>%
      ungroup %>%
    mutate(across(contains("avg_emplvl"), ~./annual_avg_emplvl_10_filled, .names = "share_{.col}")) %>%
    select(unit, contains('share')) %>%
    mutate(year = 2001) %>%
    complete(unit, year = 2001:2022) %>%
    group_by(unit) %>%
    fill(everything(), .direction = "updown") %>%
    ungroup

  assert_that(nrow(shift_share_filled) == n_distinct(shift_share_filled$unit) * n_distinct(shift_share_filled$year))

  ss_temp_fill <- shift_share_filled %>%
        select(unit, year, contains("share")) %>%
        left_join(., natl_rates, by = "year", relationship = "many-to-one") %>%
        rename(!!unit_id := unit) %>%
        select(-ends_with("10"))

  ss_temp_filled <- compute_ss(ss_temp_fill)
  saveRDS(ss_temp_filled, here("code/ss_cache_manual/ss_temp_filled.RDS"))

}else{
  ss_temp_filled <- readRDS(here("code/ss_cache_manual/ss_temp_filled.RDS"))
}

ss_temp_old <- ss_temp
ss_temp <- ss_temp_filled


```

```{r, echo = FALSE, results = 'asis'}

iv_lev_form <- "log_real_Elem_Educ_Total_Exp_pp ~  l1_log_real_Elem_Educ_Total_Exp_pp + log_real_Total_IG_Revenue_pp + log_real_gdp_priv_ind_pc + log_Enrollment + pct_black + pct_hispanic | unit + year | "

iv_lev_form_prop <- "log_hpi ~ l1_log_hpi + log_real_gdp_priv_ind_pc + pct_black + pct_hispanic | unit + year | "

iv_gr_form <- "diff_log_real_Elem_Educ_Total_Exp_pp ~ diff_log_real_Total_IG_Revenue_pp + diff_log_real_gdp_priv_ind_pc + diff_log_Enrollment + fd_pct_black + fd_pct_hispanic | unit + year | "

ss_lev_gr_va <- "log_weighted_annual_avg_wkly_wage ~ l1_log_weighted_annual_avg_wkly_wage + gdp_ss_2d + l1_gdp_ss_2d + l2_gdp_ss_2d"

ss_gr_gr_va <- "gr_weighted_annual_avg_wkly_wage ~ gdp_ss_2d + l1_gdp_ss_2d + l2_gdp_ss_2d"

ss_lev_lev_va <- "log_weighted_annual_avg_wkly_wage ~ l1_log_weighted_annual_avg_wkly_wage + lev_gdp_ss_2d + l1_lev_gdp_ss_2d + l2_lev_gdp_ss_2d"

ss_gr_lev_va <- "gr_weighted_annual_avg_wkly_wage ~ lev_gdp_ss_2d + l1_lev_gdp_ss_2d + l2_lev_gdp_ss_2d"
# mines_cz <- mines_cz %>% 
#   filter(state != 28)

df_ivs <- left_join(mines_cz, rename(ss_temp, unit = cz_id), by = c("year","unit")) %>% 
    group_by(unit) %>% 
    arrange(year) %>% 
    mutate(l1_lev_ss_2d = lag(lev_ss_2d, 1),
           l2_lev_ss_2d = lag(lev_ss_2d, 2),
           l1_ss_2d = lag(ss_2d, 1),
           l2_ss_2d = lag(ss_2d, 2),
           l1_gdp_ss_2d = lag(gdp_ss_2d,1),
           l2_gdp_ss_2d = lag(gdp_ss_2d, 2),
           l1_lev_gdp_ss_2d = lag(lev_gdp_ss_2d, 1),
           l2_lev_gdp_ss_2d = lag(lev_gdp_ss_2d, 2),
           fd_pct_black = pct_black - lag(pct_black),
           fd_pct_hispanic = pct_hispanic - lag(pct_hispanic)) %>% 
  ungroup

```

```{r wage_ss_res, include = FALSE, echo = FALSE, results = 'asis'}

panel_lines <- c("First, we display the results for a 2SLS estimation using our wage-based
shift-share instrument.",
"\n",
"In Table 5, the instrumental variable estimates provide evidence of a
robust causal relationship between local wages and public education
expenditure. Utilising our wage-based shift-share instrument we see
highly significant and relevant first-stage relationships when the
shift-share instrument is imposed in levels (except in column 5). In
each case except columns 5-6 (l1 SS, CZ FE), the first-stage regression
yields a statistically significant
\textcolor{violet}{and economically large coefficient}. Varying the
time-lag and inclusion of state or commuting zone fixed effects, we see
that a 1% increase in the shift-share measure (which can be interpreted
as a natural logarithm) is associated with a 0.02-0.06% increase in
average weekly wages (p \\< 0.01), with an F-statistic between 11-103
(near or above conventional weak instrument thresholds) confirming
instrument relevance. The Wu-Hausman tests reject the null of
exogeneity, confirming that OLS estimates are biased and IV estimation
is appropriate. Wald tests of joint significance further support the
strength of the instruments.",
"\n",

"Using wage shocks in levels yields strong instruments, high first-stage
F-statistics, and stable second-stage estimates: higher local wages
robustly increase education spending. Furthermore, given the dependent
variable measures per pupil expenditure, this result implies direct
effects in experience per student. In contrast, when shocks are measured
in growth rates (Table 6), the instruments lose predictive power
(first-stage F-statistics \\~1–2), resulting in weak identification. The
second-stage coefficients become unstable and often insignificant, while
Hausman tests fail to reject exogeneity. This suggests that the
growth-rate specification is poorly identified and cannot provide
reliable causal inference, whereas the level specification produces
credible and consistent results.",

"\n",

"The specification that uses wage shocks in levels provides the most
credible identification strategy. Since levels capture the
cross-sectional fiscal variation that drives differences in property
values and school spending, the level specification is more consistent
with the economic mechanisms of interest and delivers more reliable
causal estimates. At the same time, the weakness of the growth-rate
specification does raise concerns about the robustness of the results.
If the relationship between wages, house prices, and education
expenditure is driven by common non-stationary trends, then regressions
in levels risk spurious correlation. The fact that the IV design loses
power when variables are differenced into growth rates may suggest that
part of the strong level results reflect long-run trends rather than
short-run causal shocks. While the large first-stage F-statistics and
Hausman tests in the level specification support its validity, the weak
performance of the growth-rate version cautions that the results could
be sensitive to issues of persistence and trending in the data. Taken
together, these results suggest that while the level specification
provides strong identification and compelling evidence of a positive
causal effect of local wages on education spending, the weak performance
of the growth-rate specification highlights the need for caution, as the
strength of the findings may partly reflect long-run trending
relationships rather than purely exogenous shocks. However, examining
the structure of the growth rate shock, the instability of the variable
is likely causing the poor identification in the growth rate
regressions.")

append_to_appendix("## Wage-based Shift Share Instrument Results",
               panel_lines)


iv_model_2d_lev_gr <- feols(as.formula(paste0(iv_lev_form, " log_weighted_annual_avg_wkly_wage ~ ss_2d + l1_ss_2d + l2_ss_2d")) ,
    data = df_ivs, panel.id = c("unit", "year"), cluster = "unit")

iv_model_2d_gr_gr <- feols(as.formula(paste0("diff_log_real_Elem_Educ_Total_Exp_pp ~  l1_diff_log_real_Elem_Educ_Total_Exp_pp + diff_log_real_Total_IG_Revenue_pp + diff_log_real_gdp_priv_ind_pc + diff_log_Enrollment | unit + year | ", "gr_weighted_annual_avg_wkly_wage ~ ss_2d + l1_ss_2d + l2_ss_2d")), data = df_ivs, panel.id = c("unit", "year"), cluster = "unit")


iv_model_2d_lev_lev <- feols(as.formula(paste0(iv_lev_form, " log_weighted_annual_avg_wkly_wage ~ lev_ss_2d + l1_lev_ss_2d + l2_lev_ss_2d")),
    data = df_ivs, panel.id = c("unit", "year"), cluster = "unit")

# iv_model_2d_gr_gr <- feols(
#     as.formula(paste0("diff_log_real_Elem_Educ_Total_Exp_pp ~  l1_diff_log_real_Elem_Educ_Total_Exp_pp + diff_log_real_Total_IG_Revenue_pp + diff_log_real_gdp_priv_ind_pc + diff_log_Enrollment | unit + year | gr_weighted_annual_avg_wkly_wage ~ gdp_ss_2d + l1_gdp_ss_2d + l2_gdp_ss_2d")),
#     data = df_ivs, panel.id = c("unit", "year"), cluster = "unit")

# iv_model_2d_lev_gr_state_fe <- feols(   iv_formula = paste0(iv_lev_form, " | state + year | log_weighted_annual_avg_wkly_wage ~ l(gdp_ss_2d,0:2)")),
#     data = df_ivs, panel.id = c("unit", "year"), cluster = "unit")
# 
# iv_model_2d_lev_lev_state_fe <- feols(
#     as.formula(paste0(iv_lev_form, " | state + year | log_weighted_annual_avg_wkly_wage ~ l(lev_gdp_ss_2d,0:2)")),
#     data = df_ivs, panel.id = c("unit", "year"), cluster = "unit")
# 
# iv_model_2d_lev_gr_l1_state_fe <- feols(   iv_formula = paste0(iv_lev_form, " | state + year | log_weighted_annual_avg_wkly_wage ~ l(gdp_ss_2d,0:2)")),
#     data = df_ivs, panel.id = c("unit", "year"), cluster = "unit")
# 
# iv_model_2d_lev_lev_l1_state_fe <- feols(
#     as.formula(paste0(iv_lev_form, " | state + year | log_weighted_annual_avg_wkly_wage ~ l(lev_gdp_ss_2d,0:2)")),
#     data = df_ivs, panel.id = c("unit", "year"), cluster = "unit")


etable(iv_model_2d_lev_lev, iv_model_2d_lev_gr, iv_model_2d_gr_gr, adjustbox = TRUE, stage = 1:2,fitstat = iv_fitstats, tex = latex_tables, caption = "IV Estimation Using Wage-based Shift-share instrument (l0, l1, l2) in Levels varying state and CZ fixed effects and lags.")

```

```{r}

# library(modelsummary)
# 
# 
# df <- df_ivs %>%
#   group_by(unit) %>%
#   arrange(year, .by_group = TRUE) %>%
#   mutate(
#     lev_ss_2d_l0 = lev_ss_2d,
#     lev_ss_2d_l1 = lag(lev_ss_2d, 1),
#     lev_ss_2d_l2 = lag(lev_ss_2d, 2)
#   ) %>%
#   ungroup()
# 
# # IV formula components
# iv_rhs <- "log_weighted_annual_avg_wkly_wage"
# controls <- "log_real_Total_IG_Revenue_pp + log_real_gdp_priv_ind_pc + log_Enrollment"
# instruments <- "lev_ss_2d_l0 + lev_ss_2d_l1 + lev_ss_2d_l2"
# 
# # feols
# iv_feols <- feols(
#   as.formula(paste0("log_real_Elem_Educ_Total_Exp_pp ~ ", controls,
#                     " | unit + year | ", iv_rhs, " ~ ", instruments)),
#   data = df, cluster = "unit")
# 
# # iv_robust
# iv_est <- iv_robust(
#   as.formula(paste0("log_real_Elem_Educ_Total_Exp_pp ~ ", iv_rhs, " + ", controls,
#                     " | ", instruments, " + ", controls)),
#   fixed_effects = ~ unit + year,
#   data = df, clusters = unit)
# 
# # Compare
# modelsummary(list(iv_feols, iv_est))
# # USING IV_ROBUST
# iv_robust_mod1 <-   iv_robust(
#     as.formula("log_real_Elem_Educ_Total_Exp_pp ~ log_weighted_annual_avg_wkly_wage + log_real_Total_IG_Revenue_pp + 
#     log_real_gdp_priv_ind_pc + log_Enrollment | lev_ss_2d + lag(lev_ss_2d, 
#     1) + lag(lev_ss_2d, 2) + log_real_Total_IG_Revenue_pp + log_real_gdp_priv_ind_pc + 
#     log_Enrollment"), fixed_effects = ~ unit + year, data = df_ivs, clusters = unit)


#modelsummary(list(iv_robust_mod1,iv_model_2d_lev_lev, iv_model_2d_lev_lev_l1), stars = TRUE)

# iv_model_2d_lev_gr_l1 <- iv_robust(as.formula(paste0(iv_lev_form, log_weighted_annual_avg_wkly_wage ~ ss_2d  + lag(ss_2d,1) + lag(ss_2d,2)")),
#     data = df_ivs, cluster = "unit")
# 
# iv_model_2d_lev_lev_l1 <- feols(
#     as.formula(paste0(iv_lev_form, log_weighted_annual_avg_wkly_wage ~ lev_ss_2d + l1_lev_ss_2d + l2_lev_ss_2d")),
#     data = df_ivs, panel.id = c("unit", "year"), cluster = "unit")
# 
# etable(iv_model_2d_lev_lev, iv_model_2d_lev_lev_l1, adjustbox = TRUE,   headers = list("Stage" = c("1st", "2nd")), stage = 1:2, fitstat = iv_fitstats, tex = FALSE, caption = "IV Estimation Using Wage-based Shift-Share Instrument (l0, l1) in Levels varying state and CZ fixed effects and lags.")
# 
# etable(iv_model_2d_lev_gr, iv_model_2d_lev_gr_l1, adjustbox = TRUE, stage = 1:2, fitstat = iv_fitstats, tex = FALSE, caption = "IV Estimation Using Wage-based Shift-Share Instrument (l0, l1) in Growth Rates varying state and CZ fixed effects and lags.")

```

In \autoref{tbl_va_ss_baseline}, we demonstrate a strong and highly significant first-stage relationship wherein our shift-share instrument indicates a strong positive contemporaneous relationship with local wages. Our main specification in Columns 1-2 indicates that a 10% nicrease in local wages leads to a 2.23% increase in per-pupil education expenditure in the short run. The first-stage F-statistic substantially exceeds conventional weak instrument thresholds. The Wu-Hausman test definitevely rejects the exogeneity of wages, validating our instrumental variable approach. However, the Wald over-identification test suggests potential instrument invalidity, though this is likely an artifact of the inclusion of AR(1) terms in the first-stage and not an indictment of the exclusion restriction itself. The implied long-run elasticity is near 0.46, indicating that the cumulative effect of a 10% wage increase is a 4.6% increase in education spending.

In Columns 3-4, we corroborate this long-run effect by removing the AR(1) term in the second-stage regression. The statistically significant causal effect of the treatment approaches this long-run effect of 4.6% (5.6%), capturing the total association between wages and expenditures, including both the immediate and long-run effects. This near-equivalence in the estimated effect reflects the fact that the underlying data-generating process is defined by dynamics, validating our use of a fully dynamic system.

Understanding that wage shocks are likely transmitted to education expenditure through property taxes, we test this potential mechanism in columns 5-6 (adjusting the set of control variables to better suit the first-stage relationship in theory). We find a highly significant house price elasticity, wherein a 10% increase in wages generate an 8.4% increase in local house prices. Note that the sample size decreases because of missing data in the housing price index for several of our commuting zones.

Our findings indicate that, in a decentralised education system, local labour market strength affects public education expenditure. Regions experiencing wage growth see spillovers into public education expenditure, whereas communities facing wage stagnation or decline might see their educational spending erode as a result.

```{r, echo = FALSE, results = 'asis'}

iv_model_2d_lev_gr <- feols(as.formula(paste0(iv_lev_form, ss_lev_lev_va)), data = df_ivs, panel.id = c("unit", "year"), cluster = "unit")

iv_model_2d_gr_gr <- feols(as.formula(paste0(iv_gr_form, ss_gr_gr_va)), data = df_ivs, panel.id = c("unit", "year"), cluster = "unit")

iv_model_2d_gr_lev <- feols(as.formula(paste0(iv_gr_form, ss_gr_lev_va)), data = df_ivs, panel.id = c("unit", "year"), cluster = "unit")

iv_model_2d_gr_lev_lev_ed <- feols(as.formula(paste0(iv_lev_form, ss_gr_lev_va)), data = df_ivs, panel.id = c("unit", "year"), cluster = "unit")

iv_model_2d_lev_lev <- feols(as.formula(paste0(iv_lev_form, ss_lev_lev_va)), data = df_ivs, panel.id = c("unit", "year"), cluster = "unit")

iv_model_2d_lev_lev_prop <- feols(as.formula(paste0(iv_lev_form_prop, ss_lev_lev_va)), data = df_ivs, panel.id = c("unit", "year"), cluster = "unit")
# No AR
iv_model_2d_lev_lev_test <- feols(as.formula("log_real_Elem_Educ_Total_Exp_pp ~  log_real_Total_IG_Revenue_pp + log_real_gdp_priv_ind_pc + log_Enrollment + pct_black + pct_hispanic | unit + year | log_weighted_annual_avg_wkly_wage ~ lev_gdp_ss_2d + l1_lev_gdp_ss_2d + l2_lev_gdp_ss_2d"), data = df_ivs, panel.id = c("unit", "year"), cluster = "unit")
# SS AR
iv_model_2d_lev_lev_test2 <- feols(as.formula("log_real_Elem_Educ_Total_Exp_pp ~ l1_log_real_Elem_Educ_Total_Exp_pp + log_real_Total_IG_Revenue_pp + log_real_gdp_priv_ind_pc + log_Enrollment + pct_black + pct_hispanic | unit + year | log_weighted_annual_avg_wkly_wage ~ lev_gdp_ss_2d + l1_lev_gdp_ss_2d + l2_lev_gdp_ss_2d"), data = df_ivs, panel.id = c("unit", "year"), cluster = "unit")
# Full AR
iv_model_2d_lev_lev_test3 <- feols(as.formula("log_real_Elem_Educ_Total_Exp_pp ~ l1_log_real_Elem_Educ_Total_Exp_pp + log_real_Total_IG_Revenue_pp + log_real_gdp_priv_ind_pc + log_Enrollment + pct_black + pct_hispanic | unit + year | log_weighted_annual_avg_wkly_wage ~ l1_log_weighted_annual_avg_wkly_wage + lev_gdp_ss_2d + l1_lev_gdp_ss_2d + l2_lev_gdp_ss_2d"), data = df_ivs, panel.id = c("unit", "year"), cluster = "unit")
# FS AR
iv_model_2d_lev_lev_test4 <- feols(as.formula("log_real_Elem_Educ_Total_Exp_pp ~ log_real_Total_IG_Revenue_pp + log_real_gdp_priv_ind_pc + log_Enrollment + pct_black + pct_hispanic | unit + year | log_weighted_annual_avg_wkly_wage ~ l1_log_weighted_annual_avg_wkly_wage + lev_gdp_ss_2d + l1_lev_gdp_ss_2d + l2_lev_gdp_ss_2d"), data = df_ivs, panel.id = c("unit", "year"), cluster = "unit")

etable(iv_model_2d_lev_lev, iv_model_2d_lev_lev_test4, iv_model_2d_lev_lev_prop, adjustbox = TRUE, stage = 1:2,fitstat = iv_fitstats, tex = latex_tables, caption = "IV Estimation Using VA-based Shift-share instrument (l0, l1, l2) in Levels with CZ and year fixed effects and lags.", label = "tbl_va_ss_baseline")
# 
# etable(iv_model_2d_lev_lev, iv_model_2d_lev_lev_test3, iv_model_2d_lev_lev_test, adjustbox = TRUE, stage = 1:2, fitstat = iv_fitstats, tex = TRUE, caption = "IV Estimation Using VA-based Shift-share instrument (l0, l1, l2) in Levels with CZ and year fixed effects and lags.", label = "tbl_va_ss_baseline", headers = c("(FS) Manual IV - Full AR", "(SS) Manual IV - Full AR", "(FS) Full AR", "(SS) Full AR", "(FS) No AR", "(SS) No AR"))
# 
# etable(iv_model_2d_lev_lev_test2, iv_model_2d_lev_lev_test4, iv_model_2d_lev_lev_test3,  adjustbox = TRUE, stage = 1:2, fitstat = iv_fitstats, tex = TRUE, caption = "IV Estimation Using VA-based Shift-share instrument (l0, l1, l2) in Levels with CZ and year fixed effects and lags.", label = "tbl_va_ss_baseline", headers = c("(FS) SS AR", "(SS) SS AR", "(FS) FS AR", "(SS) FS AR", "(FS) Full AR", "(SS) Full AR"))


```

```{r, echo = FALSE, include = FALSE, results = 'asis'}

iv_model <- iv_model_2d_lev_lev

df_ivs_w_lags <- df_ivs %>% 
  group_by(unit) %>% 
  arrange(year) %>% 
  mutate(l1_lev_gdp_ss_2d = lag(lev_gdp_ss_2d, 1),
         l2_lev_gdp_ss_2d = lag(lev_gdp_ss_2d, 2)) %>% 
  ungroup

iv_model <- feols(
  as.formula(paste0(iv_lev_form, ss_lev_lev_va)),
  data = df_ivs_w_lags, panel.id = c("unit", "year"), cluster = "unit"
)

# 1) get fitted first-stage values
x_hat <- fitted(iv_model, stage = 1)

# 2) convert iv_model$obs_selection to a logical selector (rows used)
obs_sel_raw <- iv_model$obs_selection

n_data <- nrow(df_ivs_w_lags)

make_obs_used <- function(obs_sel_raw, n_data) {
  # If it's already logical and matches data length -> done
  if (is.logical(obs_sel_raw) && length(obs_sel_raw) == n_data) {
    return(obs_sel_raw)
  }

  # If it's numeric: positive or negative indices of removed rows
  if (is.numeric(obs_sel_raw) && length(obs_sel_raw) > 0) {
    # If values are negative, take absolute as removed indices
    removed <- ifelse(obs_sel_raw < 0, abs(obs_sel_raw), obs_sel_raw)
    removed <- unique(as.integer(removed))
    obs_used <- rep(TRUE, n_data)
    # guard removed values within bounds
    removed <- removed[removed >= 1 & removed <= n_data]
    obs_used[removed] <- FALSE
    return(obs_used)
  }

  # If it's a list with element 'obsRemoved' (fixest sometimes stores removed indices there)
  if (is.list(obs_sel_raw) && "obsRemoved" %in% names(obs_sel_raw)) {
    rem_vec <- unlist(obs_sel_raw$obsRemoved)
    removed <- ifelse(rem_vec < 0, abs(rem_vec), rem_vec)
    removed <- unique(as.integer(removed))
    obs_used <- rep(TRUE, n_data)
    removed <- removed[removed >= 1 & removed <= n_data]
    obs_used[removed] <- FALSE
    return(obs_used)
  }

  stop("Unrecognised iv_model$obs_selection format. Please provide the data used to fit the model and ensure it is the same row order.")
}

obs_used <- make_obs_used(obs_sel_raw, n_data)

# 3) subset data to rows used
df_used <- df_ivs_w_lags %>% slice(which(obs_used))

# Ensure lengths match
if (nrow(df_used) != length(x_hat)) {
  stop("Length mismatch after aligning rows. nrow(df_used) = ", nrow(df_used),
       " but length(x_hat) = ", length(x_hat),
       ". Make sure `df_ivs_w_lags` is exactly the same dataset (same row order) passed to feols().")
}

# 4) Extract instrument and original X on those used rows
z_used <- df_used$lev_gdp_ss_2d                      # instrument you want to plot
z1_used <- df_used$l1_lev_gdp_ss_2d 
z2_used <- df_used$l2_lev_gdp_ss_2d 
x_orig_used <- df_used$log_weighted_annual_avg_wkly_wage  # original endogenous regressor

# 5) F-stat
fs_sum <- tryCatch(summary(iv_model, stage = 1), error = function(e) NULL)
ftest <- fitstat(iv_model, 'ivf')
fstat <- ftest[[1]]$stat
fstat_pval <- ftest[[1]]$p

# 6) Plot: fitted X_hat vs Z (used rows)
ggplot(data.frame(z = z_used, z1 = z1_used, z2 = z2_used, x_hat = x_hat, x_orig = x_orig_used)) +
  geom_point(aes(x = z, y = x_hat), alpha = 0.6, color = "steelblue") +
  #geom_smooth(method = "lm", se = FALSE, color = "darkred", lwd = 1) +
  geom_point(aes(x = z1, y = x_hat), alpha = 0.6, color = "darkred") +
  geom_point(aes(x = z2, y = x_hat), alpha = 0.6, color = "purple") +
  labs(
    x = "Instrument (Z)",
    y = expression(hat(X)),
    title = "First-stage: Fitted X vs. instrument Z (rows used by model)",
    subtitle = capture.output(ftest)
  ) +
  theme_minimal(base_size = 13) + 
  common_theme


```

\FloatBarrier

## Accounting for Heterogeneity

In order to make meaningful policy-related insights, we need to unmask the substantial heterogeneity obscured by national-level average treatment effects. These national-level estimates are unlikely to apply uniformly across states and commuting zones, especially given heterogeneity in local tax regimes.

Therefore, we (1) use data on local wages and GDP to create indicators for whether regions are exhibiting relative decline or growth compared to other commuting zones to partition our sample in a data-driven manner, employ (2) industry-by-industry and (2) state-by-state estimations in our IV specifications using our VA-based shift-share instrument.

For completeness, we provide results of average treatment effects for all implemented estimations in the Appendices.

### Declining vs. Growing Regions {#sec-growthrates}

First, we identify declining and growing regions by estimating commuting-zone wage and private industry GDP growth rates conditional on state and national level growth rates and partition our sample across this distribution.

```{r, include = FALSE, cache = TRUE}

cz_labels <- read_xls(here('data/out/cz00_eqv_v1.xls')) %>%
  clean_names %>% 
  select(commuting_zone_id_2000, metropolitan_area_2003) %>%
  rename(unit = commuting_zone_id_2000) %>% 
  distinct %>% 
  arrange(unit) %>% 
  filter(!is.na(metropolitan_area_2003)) %>% 
  mutate(unit = as.character(unit)) %>% 
  group_by(unit) %>%
  summarise(
    msa = paste(sort(unique(metropolitan_area_2003)), collapse = ";\n"),
    n_msa = n_distinct(metropolitan_area_2003),   
    .groups = "drop"
  )

```

```{r, include = FALSE, cache = TRUE}

# Select variabls necessary for IVs without draggin all individual shift-share instrument variables
mines_cz_short <- df_ivs %>% select(names(mines_cz), 
                                    lev_ss_2d,
                                    l1_lev_ss_2d, 
                                    l2_lev_ss_2d,
                                    ss_2d,
                                     l1_ss_2d,
                                     l2_ss_2d,
                                    gdp_ss_2d,
                                     l1_gdp_ss_2d,
                                     l2_gdp_ss_2d,
                                    lev_gdp_ss_2d,
                                     l1_lev_gdp_ss_2d,
                                     l2_lev_gdp_ss_2d)
state_lev <- mines_cz_short %>%
  group_by(state, year) %>%
  summarise(across(c(real_gdp_priv_ind, real_gdp_total, pop_total), ~sum(., na.rm = TRUE))) %>%
  ungroup %>%
  mutate(real_gdp_priv_ind_pc = real_gdp_priv_ind/pop_total,
         real_gdp_total_pc = real_gdp_total/pop_total,
         across(!c(state, year), ~log(. + 1), .names = "log_{.col}")) %>%
  group_by(state) %>%
  mutate(across(contains("log"), ~.- dplyr::lag(., 1), .names = "diff_{.col}")) %>%
  ungroup

natl_lev <- mines_cz_short %>%
  group_by(year) %>%
  summarise(across(c(real_gdp_priv_ind, real_gdp_total, pop_total), ~sum(., na.rm = TRUE))) %>%
  ungroup %>%
  mutate(real_gdp_priv_ind_pc = real_gdp_priv_ind/pop_total,
         real_gdp_total_pc = real_gdp_total/pop_total,
         across(!c(year), ~log(. + 1), .names = "log_{.col}"),
         across(contains("log"), ~.- dplyr::lag(., 1), .names = "diff_{.col}"))

growth_rates <- mines_cz_short %>%
  select(unit, names(state_lev)) %>%
  left_join(., state_lev, by = c("state", "year"), suffix = c("", "_state")) %>%
  left_join(., natl_lev, by = c("year"), suffix = c("", "_natl"))
```

In order to identify declining and growing commuting zones, we estimate separate time series models by commuting zone as follows. These models allow for the identification of commuting-zone level growth rates while controlling for state and national trends in a two-step framework. First, we orthogonalize the state-level growth rate with respect to the national trend, isolating state-specific fluctuations unrelated to the national business cycle:

$$
\widetilde{\Delta \log GDPpc}^{state}_{t} 
= \Delta \log GDPpc^{state}_{t} 
- \hat{\gamma}\, \Delta \log GDPpc^{nat}_{t}
$$ Second, we regress commuting zone growth on both the national growth rate and the orthogonalized state residuals, thereby decomposing local growth into national, state, and idiosyncratic components. This approach identifies commuting zones whose trajectories systematically diverge from higher-level aggregate patterns, providing a clean measure of relative local economic performance.

$$
\Delta \log GDPpc^{CZ}_{t} 
= \alpha_{g} 
+ \beta_{n} \, \Delta \log GDPpc^{nat}_{t} 
+ \beta_{s} \, \widetilde{\Delta \log GDPpc}^{state}_{t} 
+ \varepsilon_{t}
$$

In these equations, each GDP term represents the private industry GDP per capita at the CZ, state, or national level, denoted by superscript.

<!-- \textcolor{red}{I think this can be supported by interesting literature from the "left behind" and "geographies of discontent" literature in which 'relative' economic performance is what matters most for individuals' happiness. Might be a conceptual leap but an interesting connection?} -->

Intuitively, this specification measures how much of each CZ’s growth can be explained by broader aggregate trends versus localized factors. By controlling for orthogonalized state and national variation, the estimated intercept ($\alpha_{g}$) and residual terms capture persistent, region‐specific trends that are not driven by common macroeconomic forces. This allows us to identify which commuting zones are systematically growing or declining relative to their state and national baselines, thereby providing a purer measure of local economic dynamics that is robust to shared higher-level shocks.\footnote{We provide similar analysis of gross GDP in the Appendix.}

We perform the same trend deviation calculation for wages where each wage variable represents the commuting zone, state, and national level growth rate in the weekly average wage as reported in QCEW.

<!-- $$\Delta (log) Wage^{CZ}_{t} = \alpha + \Delta (log) Wage^{state}_{t} + \Delta (log) Wage^{national}_{t} + \epsilon_t$$ -->

<!-- New implementation:  -->

<!-- % --- Original specification --- -->

<!-- $$ -->

<!-- \Delta \log Wage^{CZ}_{t}  -->

<!-- = \alpha  -->

<!-- + \beta_{s} \, \Delta \log Wage^{state}_{t}  -->

<!-- + \beta_{n} \, \Delta \log Wage^{nat}_{t}  -->

<!-- + \varepsilon_{t} -->

<!-- $$ -->

$$
\widetilde{\Delta \log Wage}^{state}_{t} 
= \Delta \log Wage^{state}_{t} 
- \hat{\gamma}\, \Delta \log Wage^{nat}_{t}
$$

$$
\Delta \log Wage^{CZ}_{t} 
= \alpha_{w} 
+ \beta_{n} \, \Delta \log Wage^{nat}_{t} 
+ \beta_{s} \, \widetilde{\Delta \log Wage}^{state}_{t} 
+ \varepsilon_{t}
$$

Figure 5 plots the distribution of values of $\alpha_g$, $\alpha_w$, and the distribution of commuting-zone level loadings on national and state-level growth rates. The figure demonstrates that commuting zones load more variably onto state-level growth rates and more consistently onto national-level growth rates. These distributions are expected by design as the state-level growth rates provide variation that the national level rates do not. <!-- \textcolor{red}{I recently attended a talk that noted this is a common distribution for personal income growth rates. Might be interesting to note that here.} -->

Next, Figure 6 demonstrates the considerable variability in GDP-level growth rates across commuting zones in the US between 2001-2021. Visualising the per capita growth rate deviations by state and region demonstrates heterogeneity in this variability across states and regions. For example, Texas, Montana, North Dakota, and Colorado have outstanding positive outliers in the distribution whereas Kentucky, Louisiana, South Dakota have outstanding negative outliers. The grey lines represent the commuting zones value of $\alpha_w$, indicating that in a large share of cases, wage growth rates are defined by a different sign than the GDP growth rates, indicating even potential local divergence in growth rates. Though the calculations above could lead to insignificant such relationships because the growth rates are calculated in reference to different data, the volume of states exhibiting diverging wage and GDP per capita growth rates indicate that such a divergence is likely a fact of life in many commuting zones.

To account for this inherent incomparability of the growth rates $\alpha_w$ and $\alpha_g$, we display a standard Pearson correlation coefficient between teh commuting zone time series of GDP per capita and wages, indicating that several states house commuting zones whose wages do not track GDP growth. Many states see nearly exclusively positive correlation coefficients, whereas others see a mix of commuting zones where the relationship is positive or negative.

<!-- \textcolor{violet}{This makes intuitive sense but I should make this more clear with text labels in the plot. I have marked the negatively trending outliers and they are all from Louisiana, Oklahoma, and Wyoming which makes sense. I will make this outlier marking clearer.} -->

<!-- \textcolor{violet}{I wonder if there is a potential interpretation for the right skew of the betas. I will look into this.} -->

```{r, echo = FALSE, eval = TRUE, include = FALSE, fig.height = 10, fig.width = 10, warning = FALSE, cache = TRUE, fig.cap = c("Distribution of GDP Trend Coefficients", "Lollipop Plot of GDPpc Growth Rates")}


## ---------------------------------------------------------
## 1. Orthogonalise state growth relative to national growth
## ---------------------------------------------------------
growth_rates_orthog <- growth_rates %>%
  group_by(state) %>%
  group_modify(~{
    # state-total residual
    m1 <- lm(diff_log_real_gdp_priv_ind_state ~ diff_log_real_gdp_priv_ind_natl,
             data = .x, na.action = na.exclude)
    .x$state_resid <- residuals(m1)

    # state-per-capita residual
    m2 <- lm(diff_log_real_gdp_priv_ind_pc_state ~ diff_log_real_gdp_priv_ind_pc_natl,
             data = .x, na.action = na.exclude)
    .x$state_resid_pc <- residuals(m2)

    .x
  }) %>%
  ungroup()

## ---------------------------------------------------------
## 2. Regression forms
## ---------------------------------------------------------
trend_forms <- list(
  trend    = diff_log_real_gdp_priv_ind    ~ state_resid    + diff_log_real_gdp_priv_ind_natl,
  trend_pc = diff_log_real_gdp_priv_ind_pc ~ state_resid_pc + diff_log_real_gdp_priv_ind_pc_natl
)

## ---------------------------------------------------------
## 3. Helper to extract coefficients safely
## ---------------------------------------------------------
extract_coefs <- function(formula_obj, data){
  fit <- lm(formula_obj, data = data)
  cf  <- coef(fit)

  tibble(
    intercept = unname(cf["(Intercept)"]),
    beta_nat  = unname(cf[grepl("natl", names(cf))]),
    beta_state= unname(cf[grepl("state_resid", names(cf))])
  )
}

## ---------------------------------------------------------
## 4. Run regressions by commuting zone
## ---------------------------------------------------------
cz_trends <- growth_rates_orthog %>%
  group_by(unit) %>%
  group_modify(~ extract_coefs(trend_forms$trend, .x)) %>%
  ungroup() %>%
  rename(trend = intercept)

cz_trends_pc <- growth_rates_orthog %>%
  group_by(unit) %>%
  group_modify(~ extract_coefs(trend_forms$trend_pc, .x)) %>%
  ungroup() %>%
  rename(trend_pc = intercept,
         beta_nat_pc = beta_nat,
         beta_state_pc = beta_state)

# join them
cz_trends <- cz_trends %>% left_join(cz_trends_pc, by = "unit")

## ---------------------------------------------------------
## 4. Percentiles for classification
## ---------------------------------------------------------
percentiles <- cz_trends %>%
  summarize(
    p25trend     = quantile(trend, 0.25, na.rm = TRUE),
    p75trend     = quantile(trend, 0.75, na.rm = TRUE),
    p25trend_pc  = quantile(trend_pc, 0.25, na.rm = TRUE),
    p75trend_pc  = quantile(trend_pc, 0.75, na.rm = TRUE)
  )

cz_trends <- cz_trends %>%
  mutate(declining = trend < 0,
         declining_extreme = trend < percentiles$p25trend,
         growing_extreme   = trend > percentiles$p75trend,
         declining_pc = trend_pc < 0,
         declining_pc_extreme = trend_pc < percentiles$p25trend_pc,
         growing_pc_extreme   = trend_pc > percentiles$p75trend_pc)

## ---------------------------------------------------------
## 5. Histograms of intercepts
## ---------------------------------------------------------
my_color <- viridis_pal(option = "rocket")(6)

trend_hist <- cz_trends %>%
  ggplot() +
  geom_histogram(aes(x = trend), bins = 75, fill = my_color[2], alpha = 0.7) +
  geom_vline(aes(xintercept = percentiles$p25trend), linetype = "dashed") +
  geom_vline(aes(xintercept = percentiles$p75trend), linetype = "dashed") +
  labs(x = "CZ Intercept (trend)", title = "Distribution of CZ GDP Trend Coefficients", y = "Frequency") +
  common_theme

trend_pc_hist <- cz_trends %>%
  ggplot() +
  geom_histogram(aes(x = trend_pc), bins = 75, fill = my_color[4], alpha = 0.7) +
  geom_vline(aes(xintercept = percentiles$p25trend_pc), linetype = "dashed") +
  geom_vline(aes(xintercept = percentiles$p75trend_pc), linetype = "dashed") +
  labs(x = "CZ Intercept (trend_pc)", title = "Distribution of CZ GDPpc Trend Coefficients", y = "Frequency") +
  common_theme

#trend_hist / trend_pc_hist

## ---------------------------------------------------------
## 6. Plot coefficients by state/region (like your version)
## ---------------------------------------------------------
cz_trends_plot <- cz_trends %>%
  left_join(distinct(select(mines_cz_short, unit, state)), by = "unit")

cz_trends_plot$state = sapply(cz_trends_plot$state, get_state)
cz_trends_plot$region = sapply(cz_trends_plot$state, get_region)

n_states <- dplyr::n_distinct(cz_trends_plot$state)
tmp <- colorRampPalette(brewer.pal(9, "Oranges"))(n_states + 10)
myOranges <- tmp[-c(1:10)]
myOranges <- myOranges[1:n_states]

cz_states <- cz_trends_plot %>%
  group_by(state) %>%
  arrange(state, trend_pc) %>%
  mutate(midpt = ifelse(row_number() == round((max(row_number()) - min(row_number()))/2),1, NA)) %>%
  ungroup() %>%
  mutate(midpt = row_number() * midpt) %>%
  mutate(unit = factor(unit, levels = unit)) %>%
  ggplot(aes(unit, trend_pc)) +
  geom_segment(aes(x=unit ,xend=unit, y=0, yend=trend_pc, color = state)) +
  geom_point(color="darkblue", size=0.5) +
  coord_flip() +
    geom_label(aes(midpt, 0.09,
                   label = state),
               fill = NA,
               #family = "Special Elite",
               fontface = "bold",
               label.padding = unit(.2, "lines"),
               label.r = unit(.25, "lines"),
               label.size = .05,
             size = 3) +
  labs(x = "Commuting Zones by State", y = "GDPpc Trend") +
  common_theme + 
  theme(axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        legend.position = "none") +
  scale_color_manual(values = myOranges)



cz_trend <- cz_trends_plot %>%
  arrange(trend_pc) %>%
  mutate(unit = factor(unit, levels = unit)) %>%
  ggplot(aes(unit, trend_pc)) +
  geom_segment(aes(x=unit ,xend=unit, y=0, yend=trend_pc, color = unit)) +
  geom_point(color="darkblue", size=0.5) +
  coord_flip() +
  labs(x = "Commuting Zones", y = "GDPpc Trend") +
  common_theme +
  theme(axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        legend.position = "none") +
  scale_color_viridis(discrete = TRUE, option = "rocket", direction = -1)

add_labels(cz_trend, cz_trends_plot, "trend_pc", 5) -> cz_trend

cz_regions <- cz_trends_plot %>%
  group_by(region) %>%
  arrange(region, trend_pc) %>%
  mutate(midpt = ifelse(row_number() == round((max(row_number()) - min(row_number()))/2),1, NA)) %>%
  ungroup %>%
  mutate(midpt = row_number() * midpt) %>%
  mutate(unit = factor(unit, levels = unit)) %>%
  ggplot(aes(unit, trend_pc)) +
  geom_segment(aes(x=unit ,xend=unit, y=0, yend=trend_pc, color = region)) +
  geom_point(color="darkblue", size=0.5) +
  coord_flip() +
  labs(x = "Commuting Zones by Region", y = "GDPpc Trend") +
    geom_label(aes(midpt, 0.09,
                   label = region),
               fill = NA,
               #family = "Special Elite",
               fontface = "bold",
               label.padding = unit(.2, "lines"),
               label.r = unit(.25, "lines"),
               label.size = .05,
             size = 3) +
  common_theme +
  theme(axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        legend.position = "none") +
  scale_color_brewer(palette = "Reds")

cz_regions + cz_states +  cz_trend + 
  plot_annotation(
    title = "Commuting Zone GDP pc Growth Rates",
    subtitle = "Intercepts from regressions controlling for national growth and state-specific residual growth", theme = plot_annotation_theme
  ) + 
  common_theme

```

```{r, echo = FALSE,include = FALSE, eval = TRUE, fig.height = 10, fig.width = 10, warning = FALSE, cache = TRUE, fig.cap = "Beta Loadings on GDP pc Growth Rates by CZ"}


## ---------------------------------------------------------
## Scatter plot of betas
## ---------------------------------------------------------
scatter_betas <- cz_trends_plot %>%
  ggplot(aes(x = beta_nat, y = beta_state, color = region)) +
  geom_hline(yintercept = 0, linetype = "dashed", alpha = 0.5) +
  geom_vline(xintercept = 0, linetype = "dashed", alpha = 0.5) +
  geom_point(alpha = 0.7) +
  labs(
    x = expression(beta["nat"]~"(loading on national growth)"),
    y = expression(beta["state"]~"(loading on state-specific growth)"),
    title = "Commuting Zone GDPpc Growth Loadings",
    subtitle = "Coefficients from regressions on national growth and state-specific residuals",
    color = "Region"
  ) +
  common_theme + 
  scale_color_brewer(palette = "Set2")

## ---------------------------------------------------------
## 9. Histograms of betas
## ---------------------------------------------------------
hist_nat <- cz_trends_plot %>%
  ggplot(aes(x = beta_nat)) +
  geom_histogram(fill = "steelblue", alpha = 0.7, bins = 50) +
  labs(x = expression(beta["nat"]), y = "Count",
       title = "Distribution of beta_nat") + 
  common_theme

hist_state <- cz_trends_plot %>%
  ggplot(aes(x = beta_state)) +
  geom_histogram(fill = "tomato", alpha = 0.7, bins = 50) +
  labs(x = expression(beta["state"]), y = "Count",
       title = "Distribution of beta_state") + 
  common_theme

scatter_betas / (hist_nat + hist_state)

```

<!-- In Figure 7, we see that there is similar variability though the -->

<!-- patterns do not consistently indicate the same high- and low-performing -->

<!-- outliers across states indicating that GDP and wage growth are not -->

<!-- consistently correlated across regions. We demonstrate this fact in -->

<!-- Figure 8 where, although there is a positive correlation between -->

<!-- commuting zone GDPpc and wage trend deviations, the decile-decile plot -->

<!-- demonstrates a noisy relationship largely driven by certain outliers. -->

<!-- Figure 11 presents a correlation coefficient by commuting zone between -->

<!-- the two rates, providing greater detail on this relationship. -->

<!-- \autoref{fig:wage-trends-plots-1} \autoref{fig:wage-trends-plots2} -->

<!-- \autoref{fig:wage-trends-plots3} \autoref{fig:wage-trends-plots4} -->

<!-- \autoref{fig:wage-trends-plots5} \ref{fig:wage-trends-plots} -->

<!-- \autoref{fig:wage-trends-plots} -->

<!-- \textcolor{violet}{Georgia is an incredibly interesting case in which nearly all commuting zones have relatively declining GDPpc growth rates but relatively growing wage growth rates}. -->

```{r wage-trends-lollipop, eval = TRUE, include = FALSE, echo = FALSE, fig.height = 10, fig.width = 10, warning = FALSE, cache = FALSE, fig.cap = c("Distribution of Wage Trend Coefficients", "Lollipop Plot of Wage Growth Rates"), fig.align = "center"}
# 0. Prepare CZ-level wage growth + national series (you already did this earlier)
wage_growth_rates <- mines_cz_short %>%
  select(year, unit, state, gr_weighted_annual_avg_wkly_wage, natl_gr_annual_avg_wkly_wage, state_gr_annual_avg_wkly_wage) 

growth_rates_wage_orthog <- wage_growth_rates %>%
  group_by(state) %>%
  group_modify(~{
    # fit state-level series on national series (na.action = na.exclude to preserve NAs)
    fm <- try(lm(state_gr_annual_avg_wkly_wage ~ natl_gr_annual_avg_wkly_wage, data = .x, na.action = na.exclude),
              silent = TRUE)
    if(inherits(fm, "try-error")){
      .x$state_resid <- NA_real_
    } else {
      .x$state_resid <- residuals(fm)
    }
    .x
  }) %>%
  ungroup()


#wage_trend_formula <- gr_weighted_annual_avg_wkly_wage ~ natl_gr_annual_avg_wkly_wage

wage_trend_formula <- gr_weighted_annual_avg_wkly_wage ~ state_resid + natl_gr_annual_avg_wkly_wage
# wage_trend_formula <- gr_weighted_annual_avg_wkly_wage ~ natl_gr_annual_avg_wkly_wage

# 5. Helper to extract coefficients safely (same style as your GDP template)
# extract_coefs_wage <- function(formula_obj, data){
#   fit <- lm(formula_obj, data = data)
#   cf  <- coef(fit)
#   tibble(
#     intercept = unname(cf["(Intercept)"]),
#     beta_nat  = unname(cf[grepl("natl_gr", names(cf))]),
#     beta_state = unname(cf[grepl("state_resid", names(cf))])
#   )
# }

library(broom)  # optional, but useful

extract_coefs_wage <- function(formula_obj, data){
  fit <- try(lm(formula_obj, data = data), silent = TRUE)
  if(inherits(fit, "try-error")){
    return(tibble(intercept = NA_real_, beta_nat = NA_real_, beta_state = NA_real_))
  }

  coefs <- coef(fit)                    # named numeric vector
  intercept <- if("(Intercept)" %in% names(coefs)) coefs["(Intercept)"] else NA_real_
  beta_nat   <- if(any(grepl("natl_gr", names(coefs)))) coefs[grep("natl_gr", names(coefs))[1]] else NA_real_
  beta_state <- if(any(grepl("state_resid", names(coefs)))) coefs[grep("state_resid", names(coefs))[1]] else NA_real_

  tibble(
    intercept = unname(intercept),
    beta_nat  = unname(beta_nat),
    beta_state = unname(beta_state)
  )
}

# 6. Run the per-CZ regressions and extract intercept (wage_trend)
cz_wage_trends <- growth_rates_wage_orthog %>%
  group_by(unit) %>%
  group_modify(~ extract_coefs_wage(wage_trend_formula, .x)) %>%
  ungroup() %>%   # .id returns the unit label from group_map
  rename(wage_trend = intercept)

# 7. Percentiles and classification flags (same as your original)
percentiles <- cz_wage_trends %>%
  summarize(
    p25trend = quantile(wage_trend, 0.25, na.rm = TRUE),
    p75trend = quantile(wage_trend, 0.75, na.rm = TRUE)
  )

cz_wage_trends <- cz_wage_trends %>%
  mutate(declining = wage_trend <= 0,
         declining_extreme = wage_trend <= percentiles$p25trend,
         growing_extreme = wage_trend > percentiles$p75trend)

# 8. Join back CZ metadata (state) and region mapping like you do downstream
cz_wage_trends_plot <- cz_wage_trends %>%
  left_join(distinct(select(mines_cz_short, unit, state)), by = "unit")

# convert/clean state and region columns as in your working code
cz_wage_trends_plot$state  <- sapply(cz_wage_trends_plot$state, get_state)
cz_wage_trends_plot$region <- sapply(cz_wage_trends_plot$state, get_region)

my_color <- viridis_pal(option = "mako")(5)
trend_hist <- cz_wage_trends %>%
  ggplot() +
  geom_histogram(aes(x = wage_trend), bins = 75, fill = my_color[3], alpha = 0.7) +
  geom_vline(aes(xintercept = percentiles$p25trend), linetype = "dashed") +
  geom_vline(aes(xintercept = percentiles$p75trend), linetype = "dashed") +
  labs(x = "CZ Wage Trend Coefficient", title = "Distribution of CZ Wage Trend Coefficients", y = "Frequency") +
  annotate("text", x = percentiles$p25trend, y = 40, label = "25th Percentile", color = my_color[3], angle = 90, vjust = -0.5) +
  annotate("text", x = percentiles$p75trend, y = 40, label = "75th Percentile", color = my_color[3], angle = 90, vjust = 1.5) + 
  common_theme

n_states <- dplyr::n_distinct(cz_wage_trends_plot$state)

# generate more colors than you need, then drop the first k lightest
tmp <- colorRampPalette(brewer.pal(9, "Blues"))(n_states + 10)  # oversample
myBlues <- tmp[-c(1:10)]   # drop the 2 lightest shades
myBlues <- myBlues[1:n_states] 
# First, create a consistent ordering based on regions
region_order <- cz_wage_trends_plot %>%
  group_by(region) %>%
  summarise(median_trend = median(wage_trend, na.rm = TRUE)) %>%
  arrange(median_trend) %>%
  pull(region)

# Create state order that follows region order
state_region_order <- cz_wage_trends_plot %>%
  mutate(region = factor(region, levels = region_order)) %>%
  arrange(region, wage_trend) %>%
  pull(state) %>%
  unique()

# Now create the plots with consistent ordering

# LEFT PLOT: Regions (same as before)
cz_wage_regions <- cz_wage_trends_plot %>%
  mutate(region = factor(region, levels = region_order)) %>%
  group_by(region) %>%
  arrange(region, wage_trend) %>%
  mutate(midpt = ifelse(row_number() == round((max(row_number()) - min(row_number()))/2), 1, NA)) %>%
  ungroup() %>%
  mutate(
    midpt = row_number() * midpt,
    unit = factor(unit, levels = unique(unit))
  ) %>%
  ggplot(aes(unit, wage_trend)) +
  geom_segment(aes(x = unit, xend = unit, y = 0, yend = wage_trend, color = region)) +
  geom_point(color = "darkblue", size = 0.5) +
  geom_label(aes(midpt, 0.05, label = region),
             fill = NA,
             fontface = "bold",
             label.padding = unit(.2, "lines"),
             label.size = .09,
             size = 4) +
  coord_flip() +
  labs(x = "Commuting Zones by Region", y = "Wage Trend Coefficient") +
  common_theme + 
  theme(axis.text.y = element_blank(),
        axis.text.x = element_text(size = 10),
        legend.position = "none", 
        plot.background = element_rect(fill = NA),
        panel.background = element_rect(fill = NA, color = NA),
        panel.border = element_rect(fill = NA, color = NA),
             panel.grid.major.x = element_blank(),
             panel.grid.minor = element_blank(),
             axis.ticks = element_blank(),
             axis.title.y = element_text(size = 13,
                                         margin = margin(r = 10)),
          panel.grid.major = element_line(color = NA, linewidth = 0.5),
             legend.title = element_text(size = 9),
             plot.margin = margin(10, 25, 10, 25)) +
  scale_color_brewer(palette = "Greens")

# MIDDLE PLOT: States (ordered by region)
cz_wage_states <- cz_wage_trends_plot %>%
  mutate(
    region = factor(region, levels = region_order),
    state = factor(state, levels = state_region_order)
  ) %>%
  arrange(region, state, wage_trend) %>%
  mutate(unit_order = row_number()) %>%
  group_by(state) %>%
  mutate(midpt = ifelse(row_number() == round((max(row_number()) - min(row_number()))/2), 1, NA)) %>%
  ungroup() %>%
  mutate(
    midpt = unit_order * midpt,
    unit = factor(unit, levels = unique(unit))
  ) %>%
  ggplot(aes(unit, wage_trend)) +
  geom_segment(aes(x = unit, xend = unit, y = 0, yend = wage_trend, color = state)) +
  geom_point(color = "darkblue", size = 0.5) +
  geom_label(aes(midpt, 0.09, label = state),
             fill = NA,
             fontface = "bold",
             label.padding = unit(.2, "lines"),
             label.r = unit(.25, "lines"),
             label.size = .05,
             size = 3) +
  coord_flip() +
  labs(x = "Commuting Zones by State", y = "Wage Trend Coefficient") + 
    common_theme + 
  theme(axis.text.y = element_blank(),
        axis.text.x = element_text(size = 10),
        legend.position = "none", 
        plot.background = element_rect(fill = NA),
        panel.background = element_rect(fill = NA, color = NA),
        panel.border = element_rect(fill = NA, color = NA),
             panel.grid.major.x = element_blank(),
             panel.grid.minor = element_blank(),
             axis.ticks = element_blank(),
             axis.title.y = element_text(size = 13,
                                         margin = margin(r = 10)),
          panel.grid.major = element_line(color = NA, linewidth = 0.5),
             legend.title = element_text(size = 9),
             plot.margin = margin(10, 25, 10, 25)) +
  scale_color_manual(values = myBlues)

# RIGHT PLOT: All CZs (same ordering as states plot)
cz_wage_trend <- cz_wage_trends_plot %>%
  arrange(wage_trend) %>%
  mutate(unit = factor(unit, levels = unique(unit))) %>%
  ggplot(aes(unit, wage_trend)) +
  geom_segment(aes(x = unit, xend = unit, y = 0, yend = wage_trend, color = unit)) +
  geom_point(color = "darkblue", size = 0.05) +
  coord_flip() +
  labs(x = "Commuting Zones", y = "Wage Trend Coefficient") + 
    common_theme + 
  theme(axis.text.y = element_blank(),
        axis.text.x = element_text(size = 10),
        legend.position = "none", 
        plot.background = element_rect(fill = NA),
        panel.background = element_rect(fill = NA, color = NA),
        panel.border = element_rect(fill = NA, color = NA),
             panel.grid.major.x = element_blank(),
             panel.grid.minor = element_blank(),
             axis.ticks = element_blank(),
             axis.title.y = element_text(size = 13,
                                         margin = margin(r = 10)),
          panel.grid.major = element_line(color = NA, linewidth = 0.5),
             legend.title = element_text(size = 9),
             plot.margin = margin(10, 25, 10, 25)) +
  scale_color_viridis(discrete = TRUE, option = "mako", direction = -1)

# Combine plots
cz_wage_regions + cz_wage_states + cz_wage_trend + 
  plot_annotation(
    title = "Commuting Zone Wage Growth Rate Controlling for National and State Level Trends", 
    subtitle = "Calculated as idiosyncratic component of CZ growth rate, controlling for state and national fluctuations.",
   theme = plot_annotation_theme) 

ggsave(here("output/cz_wage_trends_lollipop.jpg"), height = 10, width = 16)
```

```{r corr-wage-gdp-reg, echo = FALSE, fig.height = 10, fig.width = 10, warning = FALSE, cache = FALSE, fig.cap = c("Correlation between Wage and GDPpc Trends"), fig.align = "center"}
pct_1 <- cz_trends %>% left_join(cz_wage_trends, by = "unit") %>% ggplot(., aes(x = trend_pc, y = wage_trend)) +
     geom_point(alpha = 0.2) +
     geom_smooth(method = "lm", se = TRUE, color = "maroon", fill = "maroon") +
     labs(
         x = "Real GDP pc Trend",
         y = "Wage Trend",
         title = "Relationship Between GDPpc and Wage Trends (per CZ)"
     ) +
     theme_minimal() +
  theme(axis.text.x = element_text(size = 14),
        axis.text.y = element_text(size = 14),
        title = element_text(size = 18))

pct_2 <- cz_trends %>%
  left_join(cz_wage_trends, by = "unit") %>%
  # Rank each variable into percentiles
  mutate(
    gdp_pc_percentile = percent_rank(trend_pc) * 10,
    wage_percentile   = percent_rank(wage_trend) * 10
  ) %>%
  ggplot(aes(x = gdp_pc_percentile, y = wage_percentile)) +
  geom_point(alpha = 0.3, color = "steelblue") +
  geom_smooth(method = "lm", color = "maroon", fill = "maroon", se = TRUE) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray50") +
  labs(
    x = "Percentile of Real GDP per Capita Trend",
    y = "Percentile of Wage Trend",
    title = "Percentile–Percentile Relationship Between GDPpc and Wage Trends"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    axis.text = element_text(size = 14),
    title = element_text(size = 18)
  )
```

```{r wage-trends-maps, echo = FALSE, include = FALSE, eval = TRUE, fig.height = 10, fig.width = 10, warning = FALSE, cache = FALSE, fig.cap = c("Map of Wage GR - Median", "Map of Wage Level - Median"), fig.align = "center"}
pct_1/pct_2

map_data <- mines_cz_short %>%
  select(year, unit, log_weighted_annual_avg_wkly_wage, gr_weighted_annual_avg_wkly_wage) %>%
  group_by(unit) %>%
  mutate(gr_weighted_annual_avg_wkly_wage = mean(gr_weighted_annual_avg_wkly_wage, na.rm = TRUE)) %>%
  filter(year == 2021) %>%
  select(unit, year, log_weighted_annual_avg_wkly_wage, gr_weighted_annual_avg_wkly_wage) %>%
  rename(cz_id = unit)

# map_gr_wage <- gen_czs_years(map_data) %>%
#   left_join(., map_data, by = "cz_id") %>%
#   plot_usmap(data = ., values = "gr_weighted_annual_avg_wkly_wage", regions = "counties", col = "gray90", linewidth = 0.01, exclude = c("AK", "HI")) +
#   scale_fill_gradient2(midpoint = 0.03, na.value = "palegoldenrod", low = "mediumvioletred", high = "midnightblue") +
#   #scale_fill_distiller(colours=c(bl,"white", re), name = "", direction = 1, na.value = "gray90", limits = c(-1, 1)) +
#   theme(panel.background = element_rect(color = "white", fill = "white"),
#         plot.title = element_text(face = "bold")) +
#   labs(title = "Growth Rate of Weekly Wage in Relation to Median (CZ)",
#        fill = "Growth Rate in Weekly Wage (2001-2021)")
# 
# map_lev_wage <- gen_czs_years(map_data) %>%
#   left_join(., map_data, by = "cz_id") %>%
#   plot_usmap(data = ., values = "log_weighted_annual_avg_wkly_wage", regions = "counties", col = "gray90", linewidth = 0.01, exclude = c("AK", "HI")) +
#   scale_fill_gradient2(midpoint = 6.8, na.value = "palegoldenrod", low = "mediumvioletred", high = "midnightblue" )+
#   #scale_fill_distiller(colours=c(bl,"white", re), name = "", direction = 1, na.value = "gray90", limits = c(-1, 1)) +
#   theme(panel.background = element_rect(color = "white", fill = "white"),
#         plot.title = element_text(face = "bold")) +
#   labs(title = "Weekly Wage Level (2021) in Relation to Median (CZ)",
#        fill = "(log) Annual Average Weekly Wage")
# 
# 
# map_gr_wage
# map_lev_wage



```

<!-- \autoref{fig:wage-trends-plots-1} \autoref{fig:wage-trends-plots-2} -->

<!-- \ref{fig:wage-trends-plots-3} \autoref{fig:wage-trends-plots4} -->

<!-- \autoref{fig:wage-trends-plots5} \ref{fig:wage-trends-plots} -->

<!-- \autoref{fig:wage-trends-plots} -->

```{r wage-trends-lollipop-detail, eval = TRUE, include = FALSE, echo = FALSE, fig.height = 10, fig.width = 10, warning = FALSE, cache = TRUE, fig.cap = "Lollipop Plot of Wage Growth Rates - right panel of Figure 8"}

# # Find high and low outliers
# outliers <- cz_wage_trends_plot %>%
#   left_join(., cz_labels, by = "unit") %>%
#   arrange(wage_trend) %>%
#   slice(c(1:5, (n()-4):n()))
# 
# plot_df <- cz_wage_trends_plot %>%
#   left_join(cz_labels, by = "unit") %>%
#   arrange(wage_trend) %>%
#   mutate(unit = fct_inorder(unit))   # lock order to the arrange() result
# 
# # Outliers from the same ordered df
# outliers <- bind_rows(slice_head(plot_df, n = 5), slice_tail(plot_df, n= 5))
# 

temp <-  cz_wage_trends_plot %>% 
  arrange(wage_trend) %>%
  mutate(unit = factor(unit, levels = unit)) %>%
  ggplot(aes(x = unit, y = wage_trend)) +
  geom_segment(aes(xend = unit, y = 0, yend = wage_trend, color = unit)) +
  geom_point(color = "darkblue", size = 0.6) +
  # geom_text_repel(data = add_labels(cz_wage_trends_plot, "wage_trend", 5), aes(label = msa), direction = "y",
  #                 nudge_y = 0.02, size = 3, segment.color = "grey60",
  #                 max.overlaps = Inf) +
  coord_flip() +
  scale_x_discrete(limits = levels(cz_wage_trends_plot$unit)) +  # <- enforces the order
  scale_color_viridis(discrete = TRUE, option = "mako", direction = -1) +
  labs(x = "Commuting Zones", y = "Wage Trend Coefficient", title = "Commuting Zone Wage Growth Rate Controlling for National and State Level Trends", subtitle = "Zoom in on left-most plot from above to see outlier labels.") +
  theme(axis.text.y = element_blank(), axis.ticks.y = element_blank(),
        axis.text.x = element_text(size = 14), legend.position = "none")


add_labels(temp, cz_wage_trends_plot, "wage_trend", 5)


```

```{r, echo = FALSE, include = FALSE, eval = TRUE, fig.height = 10, fig.width = 10, warning = FALSE, cache = TRUE, fig.cap = "Beta Loadings on Wage Growth Rates by CZ"}

# -Creating a safe plotting function until state wage growth rates are incorporated
safe_plot <- function(expr, fail_label = "Plot failed", text_size = 4) {
  tryCatch(
    {
      p <- eval(substitute(expr), envir = parent.frame())
      if (!inherits(p, "ggplot")) stop("Expression did not return a ggplot object")
      # Force build so errors in scales/geoms are triggered here (and caught)
      ggplot_build(p)
      p
    },
    error = function(e) {
      ggplot() +
        geom_rect(aes(xmin = 0, xmax = 1, ymin = 0, ymax = 1),
                  fill = "white", color = "grey80") +
        annotate("text", x = 0.5, y = 0.55,
                 label = fail_label,
                 size = text_size, fontface = "bold", hjust = 0.5) +
      
        theme_void()
    }
  )
}

# Example: safe scatter (will be caught if cz_wage_trends_plot or scale mismatches fail)
scatter_betas <- safe_plot({
  cz_wage_trends_plot %>%
    ggplot(aes(x = beta_nat, y = beta_state, color = region)) +
    geom_hline(yintercept = 0, linetype = "dashed", alpha = 0.5) +
    geom_vline(xintercept = 0, linetype = "dashed", alpha = 0.5) +
    geom_point(alpha = 0.7) +
    labs(
      x = expression(beta["nat"]~"(loading on national growth)"),
      y = expression(beta["state"]~"(loading on state-specific growth)"),
      title = "Commuting Zone GDPpc Growth Loadings",
      subtitle = "Coefficients from regressions on national growth and state-specific residuals",
      color = "Region"
    ) +
    theme_minimal() +
    scale_color_brewer(palette = "Set2")
}, fail_label = "Expected error: \nMissing state wage growth rates so histogram fails.")
## ---------------------------------------------------------
## 9. Histograms of betas
## ---------------------------------------------------------
hist_nat <- safe_plot({cz_wage_trends_plot %>%
  ggplot(aes(x = beta_nat)) +
  geom_histogram(fill = "steelblue", alpha = 0.7, bins = 50) +
  labs(x = expression(beta["nat"]), y = "Count",
       title = expression("Distribution of"~beta["nat"])) +
  theme_minimal()}, fail_label = "hist_nat failed")

hist_state <- safe_plot({cz_wage_trends_plot %>%
  ggplot(aes(x = beta_state)) +
  geom_histogram(fill = "tomato", alpha = 0.7, bins = 50) +
  labs(x = expression(beta["state"]), y = "Count",
       title = expression("Distribution of "~beta["state"])) +
  theme_minimal()}, fail_label = "Expected error: \nMissing state wage growth rates so histogram fails.")


scatter_betas / (hist_nat + hist_state)

```

```{r wage_gdp_trend, echo = FALSE, fig.height = 10, fig.width = 10, warning = FALSE, cache = FALSE, fig.cap = c("GDPpc and Wage Growth Rates and Loadings", "Lollipop Plot of Wage and GDPpc Growth Rates"), fig.align = "center"}

cz_trends_comb_plot <- cz_trends_plot %>% 
  left_join(rename(cz_wage_trends_plot, beta_nat_wage = beta_nat, beta_state_wage = beta_state), by = c('unit', 'state', 'region'))

# Example: safe scatter (will be caught if cz_wage_trends_plot or scale mismatches fail)
scatter_betas <- cz_trends_comb_plot %>%
    ggplot() +
    geom_point(aes(x = beta_nat_pc, y = beta_state_pc, color = "GDP pc"), alpha = 0.7) +
    geom_point(aes(x = beta_nat_wage, y = beta_state_wage, color = "Wage"), alpha = 0.7) +
    geom_hline(yintercept = 0, linetype = "dashed", alpha = 0.5) +
    geom_vline(xintercept = 0, linetype = "dashed", alpha = 0.5) +
    labs(
      x = expression(beta["nat"]~"(loading on national growth)"),
      y = expression(beta["state"]~"(loading on state-specific growth)"),
      title = "Commuting Zone GDPpc Growth Loadings",
      subtitle = "Coefficients from regressions on national growth and state-specific residuals",
      color = "Metric"
    ) +
  common_theme + 
  scale_colour_manual(values = c("seagreen","cornflowerblue","mediumvioletred")) +
    theme(legend.position = "top")


## ---------------------------------------------------------
## 9. Histograms of betas
## ---------------------------------------------------------
hist_nat <- cz_trends_comb_plot %>%
  ggplot() +
  geom_histogram(aes(x = beta_nat_pc, fill = "GDP pc"), alpha = 0.7, bins = 150) +
  geom_histogram(aes(x = beta_nat_wage, fill = "Wage"), alpha = 0.7, bins = 150) +
  #geom_histogram(aes(x = beta_nat_wage, fill = "GDP"), alpha = 0.7, bins = 50) +
  labs(x = expression(beta["nat"]), y = "Count",
       title = expression("Distribution of"~beta["nat"]),
              fill = "Metric") +
  common_theme + 
    scale_colour_manual(values = c("seagreen","cornflowerblue","mediumvioletred")) +
    scale_fill_manual(values = c("seagreen","cornflowerblue","mediumvioletred")) + 
  theme(legend.position = "top")



hist_state <- cz_trends_comb_plot %>%
  ggplot() +
  geom_histogram(aes(x = beta_state_pc, fill = "GDP pc"), alpha = 0.7, bins = 150) +
  geom_histogram(aes(x = beta_state_wage, fill = "Wage"), alpha = 0.7, bins = 150) +
  #geom_histogram(aes(x = beta_state, fill = "GDP"), alpha = 0.7, bins = 50) +
  labs(x = expression(beta["state"]), y = "Count",
       title = expression("Distribution of "~beta["state"]),
              fill = "Metric") +
   common_theme + 
      scale_colour_manual(values = c("seagreen","cornflowerblue","mediumvioletred")) +
    scale_fill_manual(values = c("seagreen","cornflowerblue","mediumvioletred")) +
  theme(legend.position = "top")

trend_coefs_hist <- cz_trends_comb_plot %>% 
  pivot_longer(!c(unit, state, region)) %>% 
  filter(name %in% c("wage_trend", "trend_pc", "trend")) %>%
  mutate(name = case_when(name == 'wage_trend' ~ "Wage",
                   name == 'trend_pc' ~ "GDP pc",
                   name == 'trend' ~ "GDP")) %>% 
  ggplot(aes(x = value)) +
  geom_histogram(aes(fill = name), alpha = 0.4, bins = 250) +
  geom_density(aes(color = name)) +
  theme(legend.position = "top")  +
  scale_colour_manual(values = c("GDP pc" = "seagreen", "Wage" = "cornflowerblue", "GDP" = "mediumvioletred"))+
  scale_fill_manual(values = c("GDP pc" = "seagreen", "Wage" = "cornflowerblue", "GDP" = "mediumvioletred")) +
  labs(title = "Histogram of Wage and GDP per capita Growth Rates by CZ",
       x = "Growth Rate Value",
       y = "Count",
       color = "Metric",
       fill = "Metric") +
  common_theme + 
    theme(legend.title = element_text(size = 12, face = "italic")) + 
   guides(color = guide_legend(
    title.position = "top",
    title.hjust = 0.5  # Center the title
  ))

(trend_coefs_hist + hist_state) / (scatter_betas + hist_nat) + plot_annotation("Commuting Zone Growth Rates and Jurisdictional Loadings", theme = plot_annotation_theme)

n_states <- dplyr::n_distinct(cz_trends_comb_plot $state)
tmp <- colorRampPalette(brewer.pal(9, "Oranges"))(n_states + 10)
myOranges <- tmp[-c(1:10)]
myOranges <- myOranges[1:n_states]

cz_states <- cz_trends_comb_plot  %>%
  group_by(state) %>%
  arrange(state, trend_pc) %>%
  mutate(midpt = ifelse(row_number() == round((max(row_number()) - min(row_number()))/2),1, NA)) %>%
  ungroup() %>%
  mutate(midpt = row_number() * midpt) %>%
  mutate(unit = factor(unit, levels = unit)) %>%
  ggplot(aes(unit, trend_pc)) +
  geom_segment(aes(x=unit ,xend=unit, y=0, yend=wage_trend), color = "lightgrey") +
  geom_segment(aes(x=unit ,xend=unit, y=0, yend=trend_pc, color = state)) +
  geom_point(color="darkblue", size=0.5) +
  #geom_point(aes(x = unit ,wage_trend), color="green", size=0.5) +
  coord_flip() +
    geom_label(aes(midpt, 0.09,
                   label = state),
               fill = NA,
               #family = "Special Elite",
               fontface = "bold",
               label.padding = unit(.2, "lines"),
               label.r = unit(.25, "lines"),
               label.size = .05,
             size = 3) +
  labs(x = "Commuting Zones by State", y = "GDPpc Trend") +
  common_theme + 
  theme(axis.text.y = element_blank(),
        axis.text.x = element_text(size = 10),
        legend.position = "none", 
        plot.background = element_rect(fill = NA),
        panel.background = element_rect(fill = NA, color = NA),
        panel.border = element_rect(fill = NA, color = NA),
             panel.grid.major.x = element_blank(),
             panel.grid.minor = element_blank(),
             axis.ticks = element_blank(),
             axis.title.y = element_text(size = 13,
                                         margin = margin(r = 10)),
          panel.grid.major = element_line(color = NA, linewidth = 0.5),
             legend.title = element_text(size = 9),
             plot.margin = margin(10, 25, 10, 25)) +
  scale_color_manual(values = myOranges)

cz_trend <- cz_trends_comb_plot  %>%
  arrange(trend_pc) %>%
  mutate(unit = factor(unit, levels = unit)) %>%
  ggplot(aes(unit, trend_pc)) +
  geom_segment(aes(x=unit ,xend=unit, y=0, yend=wage_trend), color = "lightgrey") +
  geom_segment(aes(x=unit ,xend=unit, y=0, yend=trend_pc, color = unit)) +
  geom_point(color="darkblue", size=0.5) +
  coord_flip() +
  labs(x = "Commuting Zones", y = "GDPpc Trend") +
  common_theme + 
  theme(axis.text.y = element_blank(),
        axis.text.x = element_text(size = 10),
        legend.position = "none", 
        plot.background = element_rect(fill = NA),
        panel.background = element_rect(fill = NA, color = NA),
        panel.border = element_rect(fill = NA, color = NA),
             panel.grid.major.x = element_blank(),
             panel.grid.minor = element_blank(),
             axis.ticks = element_blank(),
             axis.title.y = element_text(size = 13,
                                         margin = margin(r = 10)),
          panel.grid.major = element_line(color = NA, linewidth = 0.5),
             legend.title = element_text(size = 9),
             plot.margin = margin(10, 25, 10, 25)) +
  scale_color_viridis(discrete = TRUE, option = "rocket", direction = -1)

add_labels(cz_trend, cz_trends_plot, "trend_pc", 5) -> cz_trend

cz_regions <- cz_trends_comb_plot  %>%
  group_by(region) %>%
  arrange(region, trend_pc) %>%
  mutate(midpt = ifelse(row_number() == round((max(row_number()) - min(row_number()))/2),1, NA)) %>%
  ungroup %>%
  mutate(midpt = row_number() * midpt) %>%
  mutate(unit = factor(unit, levels = unit)) %>%
  ggplot(aes(unit, trend_pc)) +
  geom_segment(aes(x=unit ,xend=unit, y=0, yend=wage_trend), color = "lightgrey") +
  geom_segment(aes(x=unit ,xend=unit, y=0, yend=trend_pc, color = region)) +
  geom_point(color="darkblue", size=0.5) +
  coord_flip() +
  labs(x = "Commuting Zones by Region", y = "GDPpc Trend") +
    geom_label(aes(midpt, 0.09,
                   label = region),
               fill = NA,
               #family = "Special Elite",
               fontface = "bold",
               label.padding = unit(.2, "lines"),
               label.r = unit(.25, "lines"),
               label.size = .05,
             size = 3) +
common_theme + 
  theme(axis.text.y = element_blank(),
        axis.text.x = element_text(size = 10),
        legend.position = "none", 
        plot.background = element_rect(fill = NA),
        panel.background = element_rect(fill = NA, color = NA),
        panel.border = element_rect(fill = NA, color = NA),
             panel.grid.major.x = element_blank(),
             panel.grid.minor = element_blank(),
             axis.ticks = element_blank(),
             axis.title.y = element_text(size = 13,
                                         margin = margin(r = 10)),
          panel.grid.major = element_line(color = NA, linewidth = 0.5),
             legend.title = element_text(size = 9),
             plot.margin = margin(10, 25, 10, 25)) +
  scale_color_brewer(palette = "Reds")

cz_regions + 
  cz_states +  
  cz_trend + 
  plot_annotation(
    title = "Commuting Zone GDP pc and Wage Growth Rates",
    subtitle = "Intercepts from regressions controlling for national growth and state-specific residual growth",
    theme = plot_annotation_theme
  )

```

```{r, echo = FALSE, fig.height = 10, fig.width = 10, warning = FALSE, cache = TRUE, fig.cap = "Correlation Between GDP Growth Rates and Wage Growth Rates by State"}

# 1) compute unit-level correlations (if you already have this, skip this block)
unit_corr <- mines_cz_short %>%
  group_by(unit) %>%
  summarise(
    corr_gdp_wage = cor(diff_log_real_gdp_priv_ind_pc,
                        gr_weighted_annual_avg_wkly_wage,
                        use = "pairwise.complete.obs",
                        method = "pearson"),
    .groups = "drop"
  )

# join state/region and keep one row per unit
unit_corr_plot <- unit_corr %>%
  left_join(
    mines_cz_short %>% select(unit, state) %>% distinct(),
    by = "unit"
  )

# 2) order units by state then by correlation (lowest -> highest within state)
unit_corr_plot <- unit_corr_plot %>%
  arrange(state, corr_gdp_wage) %>%
  mutate(unit_ord = factor(unit, levels = unique(unit)))    # preserve order

# 3) compute midpoint (y position) for each state block so we can label it
state_positions <- unit_corr_plot %>%
  group_by(state) %>%
  summarise(
    start = min(as.integer(unit_ord)),
    end   = max(as.integer(unit_ord)),
    mid   = (start + end) / 2,
    .groups = "drop"
  )

# # 4) plot: single column of tiles, states grouped (x is constant=1)
# #p_single_column <- 
#   ggplot(unit_corr_plot) +
#   geom_tile(aes(x = 1, y = unit_ord, fill = corr_gdp_wage), color = "white", height = 0.95) +                 # tile per unit
#   scale_fill_viridis_c(option = "mako", limits = c(-1, 1), na.value = "grey90") +
#   # state separators: horizontal lines between blocks (at integer + 0.5 positions)
#   geom_hline(
#     data = state_positions %>% mutate(bound = end + 0.5),
#     aes(yintercept = bound),
#     color = "grey70", size = 0.3
#   ) +
#   #state labels positioned to the left of the tiles
#   geom_text(
#     data = state_positions,
#     aes(x = 0.7, y = mid, label = state),
#     hjust = 1, fontface = "bold", size = 3
#   ) +
#   #coord_fixed(ratio = 0.045, clip = "off") +                 # shrink tile height; allow labels outside
#   scale_x_continuous(limits = c(0.4, 1.1), expand = c(0,0)) +
#   labs(
#     title = "Per-unit correlation: GDP per capita vs wages",
#     subtitle = "Tiles grouped by state; darker = stronger positive correlation",
#     x = NULL, y = NULL,
#     fill = "Correlation"
#   ) +
#   theme_minimal(base_size = 12) +
#   theme(
#     axis.text = element_blank(),
#     axis.ticks = element_blank(),
#     panel.grid = element_blank(),
#     legend.position = "right",
#     plot.margin = margin(5, 40, 5, 80)   # give space on left for state labels
#   )
# 
# # show plot
# p_single_column


unit_corr_plot$state = sapply(unit_corr_plot$state, get_state)
unit_corr_plot$region = sapply(unit_corr_plot$state, get_region)


ggplot(unit_corr_plot %>% arrange(corr_gdp_wage) %>%
         mutate(unit = factor(unit, levels = unit)),
       aes(x = unit, y = corr_gdp_wage, fill = corr_gdp_wage)) +
  geom_col(show.legend = FALSE) +
  geom_hline(aes(yintercept = 0)) + 
  scale_fill_viridis_c(option = "cividis", limits = c(-1, 1)) +
  coord_flip() +
  labs(
    title = "Commuting Zone Correlation between GDPpc Growth and Wage Growth",
    x = "Commuting Zone (Unit)",
    y = "Correlation Coefficient"
  ) +
  facet_wrap(~state, scales = "free") +
  common_theme +
  theme(
    panel.grid = element_blank(),   # remove grid lines
    panel.background = element_blank(), # remove gray panel background
    plot.background = element_blank(),  # remove outer gray background
    strip.background = element_blank()  # remove facet label background
  )

```

```{r, echo = FALSE}
mines_cz_decl <- cz_trends %>%
  select(unit, contains("trend"), contains("growing"), contains("declining")) %>%
  left_join(mines_cz_short, ., by = "unit")

mines_cz_wage_decl <- cz_wage_trends %>%
  select(unit, contains('trend'), contains('growing'), contains('declining')) %>%
  left_join(mines_cz_short, ., by = "unit")

# print("Declining")
# run_model(selected_iv_models, filter(mines_cz_decl, declining_pc)) %>% etable(headers = c("INSTR: Total Active Prod", "INSTR: (l1) Total Active Prod","INSTR: Total Active Prod", "INSTR: (l1) Total Active Prod"))
# print("Growing")
# run_model(selected_iv_models, filter(mines_cz_decl, !declining_pc)) %>% etable(headers = c("INSTR: Total Active Prod", "INSTR: (l1) Total Active Prod","INSTR: Total Active Prod", "INSTR: (l1) Total Active Prod"))
#
# print("Extreme Decline (25th percentile of growth rates)")
# run_model(selected_iv_models, filter(mines_cz_decl, declining_pc_extreme)) %>% etable(headers = c("INSTR: Total Active Prod", "INSTR: (l1) Total Active Prod","INSTR: Total Active Prod", "INSTR: (l1) Total Active Prod"))
#
# print("Extreme Growth (75th percentile of growth rates)")
# run_model(selected_iv_models, filter(mines_cz_decl, growing_pc_extreme)) %>% etable(headers = c("INSTR: Total Active Prod", "INSTR: (l1) Total Active Prod","INSTR: Total Active Prod", "INSTR: (l1) Total Active Prod"), title = "Hello")

```

#### Sample Partitioning by Growth Rates

Using these growth rates, we partition the sample according to the percentiles described above. \autoref{tbl_gdp_ss_wage_subsamples} and \autoref{tbl_gdp_ss_gdp_subsamples} examine how the relationship between local economic conditions and elementary education expenditure per pupil varies across structurally growing and declining regions as defined in the previous section. We partition our sample into four sub-samples by their values of $\alpha_{w}$ and $\alpha_{g}$ as shown in @tbl-categories.

| Category        | Definition ($\alpha_{w}$, $\alpha_{g}$) |
|-----------------|-----------------------------------------|
| Declining       | $\alpha < 0$                            |
| Hyper-Declining | $\alpha < P_{25}$                       |
| Growing         | $\alpha > 0$                            |
| Hyper-Growing   | $\alpha > P_{75}$                       |

: Category Definitions {#tbl-categories}

Zones with negative (positive) values of $\alpha_{w}$ or $\alpha_g$ are designated as declining (growing), while those in the bottom (P25) and top (P75) quartiles are labelled hyper-declining and hyper-growing, respectively. This stratification enables comparison of fiscal responsiveness across local economies with different long-run growth trajectories.

\autoref{tbl_gdp_ss_wage_subsamples} partitions CZs by $\alpha_w$. Interestingly, we observe positive statistically significant relationships between wages and public education expenditure though the magnitude and statistical significance of this relationship declines almost uniformly as $\alpha_w$ discretely increases. We see a similar declining size and significance in the explanatory variable accounting for inter-governmental revenue, indicating that these revenues play a smaller role in regions exhibiting above-average wage growth.

<!-- \textcolor{violet}{I am thinking of a few different interpretations here but not quite sure yet...}. -->

In \autoref{tbl_gdp_ss_gdp_subsamples} partitions CZs by long-run GDP per capita trends. The statistical significance and magnitude variations in the wage response tell a less monotonic story here, likely mirroring the lack of systematic correlation between $\alpha_w$ and $\alpha_g$ When partitioning the sample by GDP growth rates, the interpretation is more straight-forward.

Regardless, all models remain well-identified, with high first stage F statistics, convincing performance on the Wu-Hausman endogeneity tests and Wald tests. Combined, these results indicate that partitioning by background wage growth rates provides greater insight into the sample's heterogeneity than diversity in GDP per capita growth rates. More precisely, given communities feel wage growth more directly than GDP per capita improvements, it is likely that the relationship between public education and wage changes is better captured by sub-sampling by wage growth rates.

```{r, include = FALSE, eval = TRUE, echo = FALSE}
library(ggrepel)

# prepare data
plot_df <- mines_cz_wage_decl %>%
  select(year, unit, state, contains('extreme'), log_weighted_annual_avg_wkly_wage,
         gr_weighted_annual_avg_wkly_wage, natl_log_annual_avg_wkly_wage,
         natl_gr_annual_avg_wkly_wage, state_gr_annual_avg_wkly_wage) %>%
  group_by(unit) %>%
  arrange(unit, year) %>%
  mutate(
    first_obs = first(log_weighted_annual_avg_wkly_wage),
    trend_t0 = log_weighted_annual_avg_wkly_wage - first_obs
  ) %>%
  ungroup()

# choose which groups to highlight
# (example: growing_extreme == TRUE and declining_extreme == TRUE columns exist)
highlight_df <- plot_df %>%
  filter(growing_extreme == TRUE | declining_extreme == TRUE) %>% 
  mutate(extreme_grouping = case_when(growing_extreme ~ "Extreme Growth", 
                                        declining_extreme ~"Extreme Decline", 
                                        TRUE ~ NA))

# compute national trend (if available) — use the natl series (one value per year)
natl_df <- plot_df %>%
  select(year, natl_log_annual_avg_wkly_wage) %>%
  distinct() %>%
  arrange(year) %>%
  mutate(natl_trend = natl_log_annual_avg_wkly_wage - first(natl_log_annual_avg_wkly_wage))

# basic plot
p <- ggplot() +
  # 1) faint spaghetti for all CZs
  geom_line(
    data = filter(plot_df, growing_extreme != TRUE & declining_extreme != TRUE),
    aes(x = year, y = trend_t0, group = unit),
    color = "grey80",
    linetype = "dashed",
    linewidth = 0.5
  ) +
  # 2) overlay highlighted groups (growing / declining)
  geom_line(
    data = filter(plot_df, growing_extreme == TRUE),
    aes(x = year, y = trend_t0, group = unit),
    color = "#2b8cbe",   # blue
    linewidth = 0.25,
    alpha = 0.8
  ) +
  geom_line(
    data = filter(plot_df, declining_extreme == TRUE),
    aes(x = year, y = trend_t0, group = unit),
    color = "#ef3b2c",   # red
    linewidth = 0.25,
    alpha = 0.8
  ) +
  # 3) national reference line (bold)
  geom_line(
    data = natl_df,
    aes(x = year, y = natl_trend),
    color = "black",
    size = 1.0,
    linetype = "dashed"
  ) +
  # 4) add labels at the end for highlighted CZs (take last-year values)
  geom_text_repel(
    data = highlight_df %>% group_by(unit) %>% filter(year == max(year)),
    aes(x = year + 0.2, y = trend_t0, label = unit, color = as.factor(extreme_grouping)),
    size = 3,
    segment.size = 0.2,
    direction = "y",
    hjust = 0,
    show.legend = FALSE
  ) +
  # cosmetics
  scale_color_manual(values = c("Extreme Growth" = "#2b8cbe", "Extreme Decline" = "#ef3b2c")) + 
  labs(
    x = "Year",
    y = "Log wage change since first obs (trend_t0)",
    title = "Commuting-zone wage trends (baseline = first observed log wage for each CZ)",
    subtitle = "All CZs faint grey; highlighted series are extreme growers or decliners; black dashed = national trend",
    caption = expression("trend[i] = log(wage[i,t]) - log(wage[i,0])")
  ) +
  common_theme +

  scale_x_continuous(breaks = scales::pretty_breaks(n = 8)) +
  scale_y_continuous(labels = scales::number_format(accuracy = 0.01))

# widen plotting area to accommodate labels slightly to the right
p + coord_cartesian(xlim = c(min(plot_df$year), max(plot_df$year) + 2))

ggsave(here("output/wage_trends_plot.png"), width = 12, height = 8)

```

```{r baseline_growth_rate_partitioning, include = FALSE, echo = FALSE, results = 'asis'}

append_to_appendix("### Baseline Models for Growth Rate Sample Partitioning",
                   "")

form <- paste0(baseline_sw_short, " | unit + year")

for(k in list(form)){
  mods_list <- list()
  mods_list["Declining"] <- run_model(k, filter(mines_cz_decl, declining_pc))
  n_forms <- mods_list[['Declining']] %>% length
  mods_list["Hyper-Declining"] <- run_model(k, filter(mines_cz_decl, declining_pc_extreme))
  mods_list["Growing"] <- run_model(k, filter(mines_cz_decl, !declining_pc))
  mods_list["Hyper-Growing"] <- run_model(k, filter(mines_cz_decl, growing_pc_extreme))
  etable(mods_list, tex = latex_tables, adjustbox = TRUE, headers = rep(names(mods_list), each = n_forms), title = "Baseline Regression Applied to Declining GDP vs. Growing GDP Regions",  label = "tab:baseline_gdp_subsamples") %>% print(.)
}


for(k in list(form)){
  mods_list <- list()
  mods_list["Declining"] <- run_model(k, filter(mines_cz_wage_decl, declining))
  n_forms <- mods_list[['Declining']] %>% length
  mods_list["Hyper-Declining"] <- run_model(k, filter(mines_cz_wage_decl, declining_extreme))
  mods_list["Growing"] <- run_model(k, filter(mines_cz_wage_decl, !declining))
  mods_list["Hyper-Growing"] <- run_model(k, filter(mines_cz_wage_decl, growing_extreme))
  etable(mods_list, tex = latex_tables, adjustbox = TRUE, headers = rep(names(mods_list), each = n_forms), title = "Baseline Regression Applied to Declining Wage vs. Growing Wage Regions",  label = "tab:baseline_wage_subsamples") %>% print(.)
}

```

\FloatBarrier

```{r, echo = FALSE}

decl <- filter(mines_cz_decl, declining_pc)
grow <- filter(mines_cz_decl, !declining_pc)

decl_extr <- filter(mines_cz_decl, declining_pc_extreme)
grow_extr <- filter(mines_cz_decl, growing_pc_extreme)

dfs <- list("All" = mines_cz_decl, "Hyper-Declining (GDP)" = decl_extr, "Declining (GDP)" = decl, "Growing (GDP)" = grow, "Hyper-Growing (GDP)" = grow_extr)


decl_wage <- filter(mines_cz_wage_decl, declining)
grow_wage <- filter(mines_cz_wage_decl, !declining)

decl_extr_wage <- filter(mines_cz_wage_decl, declining_extreme)
grow_extr_wage <- filter(mines_cz_wage_decl, growing_extreme)

dfs_wage <- list("All" = mines_cz_decl, "Hyper-Declining (Wage)" = decl_extr_wage, "Declining (Wage)" = decl_wage, "Growing (Wage)" = grow_wage, "Hyper-Growing (Wage)" = grow_extr_wage)


```

```{r, echo = FALSE}

mods <- list()
#mods_fs <- list()
for(df in names(dfs)){
    # IV regression using shift-share instrument
    iv_model <-  feols(as.formula(paste0(iv_lev_form, ss_lev_lev_va)),
   data = dfs[[df]], panel.id = c("unit", "year"), cluster = "unit")
    mods[[df]] <- iv_model#$second_stage
    #mods_fs[[df]] <- iv_model$first_stage
    gc()
}

mods_wage <- list()
#mods_wage_fs <- list()
for(df_wage in names(dfs_wage)){
    # IV regression using shift-share instrument
    iv_model <- feols(as.formula(paste0(iv_lev_form, ss_lev_lev_va)),
   data = dfs_wage[[df_wage]], panel.id = c("unit", "year"), cluster = "unit")
    mods_wage[[df_wage]] <- iv_model#$second_stage
    #mods_wage_fs[[df_wage]] <- iv_model#$first_stage
    gc()
}

```

```{r wage_ss_growth_rate_partitioning, include = FALSE, echo = FALSE, results = 'asis'}

append_to_appendix("### Wage-based SS Instrument for Growth Rate Sample Partitioning",
                   c("When applying our instrumental variable design we find that majority of
our relevant signal is picked up in regions across both trend metrics. Though the effects are more consistent across wage-trending sub-samples."))

etable(mods, tex = latex_tables, adjustbox = TRUE, headers = names(mods), fitstat = iv_fitstats, title = "Second-Stage: Wage-based Shift-Share Instrument (l1) Applied to Declining GDP vs. Growing GDP Regions")
# etable(mods, tex = latex_tables, adjustbox = TRUE, headers = names(mods), stage = 1, fitstat = iv_fitstats, title = "First-Stage: Wage-based Shift-Share Instrument (l1) Applied to Declining GDP vs. Growing GDP Regions")
etable(mods_wage, tex = latex_tables, adjustbox = TRUE, headers = names(mods_wage), fitstat = iv_fitstats, title = "Second-Stage: Wage-based Shift-Share Instrument (l1) Applied to Declining Wage vs. Growing Wage Regions")
# etable(mods_wage, tex = latex_tables, adjustbox = TRUE, headers = names(mods_wage), stage = 1, fitstat = iv_fitstats, title = "First-Stage: Wage-based Shift-Share Instrument (l1) Applied to Declining Wage vs. Growing Wage Regions")

```

\FloatBarrier

```{r, echo = FALSE}

mods <- list()
#mods_fs <- list()
for(df in names(dfs)){
    # IV regression using shift-share instrument
    iv_model <- feols(as.formula(paste0(iv_lev_form, ss_lev_lev_va)),
   data = dfs[[df]], panel.id = c("unit", "year"), cluster = "unit")
    mods[[df]] <- iv_model#$second_stage
    #mods_fs[[df]] <- iv_model$first_stage
    gc()
}

mods_wage <- list()
#mods_wage_fs <- list()
for(df_wage in names(dfs_wage)){
    # IV regression using shift-share instrument
    iv_model <- feols(as.formula(paste0(iv_lev_form, ss_lev_lev_va)),
   data = dfs_wage[[df_wage]], panel.id = c("unit", "year"), cluster = "unit")
    mods_wage[[df_wage]] <- iv_model#$second_stage
    #mods_wage_fs[[df_wage]] <- iv_model$first_stage
    gc()
}

```

<!-- The sub-sampling procedure indicates the link between public education expenditure and wages is present in hyper-growing GDP regions only. However, \textcolor{red}{and I am unsure how to interpret this}, the wage effect when using the VA-based shift-share instrument has different signs depending on rate of wage growth.  -->

```{r, echo = FALSE, results='asis'}

etable(mods_wage, tex = latex_tables, headers = names(mods_wage), adjustbox = TRUE, fitstat = iv_fitstats, title = "Second-Stage: VA-based Shift-Share Instrument (l1) Applied to Declining Wage vs. Growing Wage Regions", label = "tbl_gdp_ss_wage_subsamples")
# etable(mods_wage, tex = latex_tables, headers = names(mods_wage), adjustbox = TRUE, fitstat = iv_fitstats, title = "First-Stage: VA-based Shift-Share Instrument (l1) Applied to Declining Wage vs. Growing Wage Regions", label = "tbl_gdp_ss_wage_subsamples")
etable(mods,   tex = latex_tables, adjustbox = TRUE, headers = names(mods), fitstat = iv_fitstats, title = "Second-Stage: VA-based Shift-Share Instrument (l1) Applied to Declining GDP vs. Growing GDP Regions", label = "tbl_gdp_ss_gdp_subsamples")
# etable(mods,   tex = latex_tables, adjustbox = TRUE, headers = names(mods), fitstat = iv_fitstats, title = "First-Stage: VA-based Shift-Share Instrument (l1) Applied to Declining GDP vs. Growing GDP Regions", label = "tbl_gdp_ss_gdp_subsamples")

```

\FloatBarrier

### State-by-state estimation

Next, given the substantial heterogeneity in state-level economic makeup and public finance regimes, we investigate state-specific relationships between our variables of interest.

First, states vary in the number of commuting zones they contain. Figure 12 demonstrates that states have anywhere between 2 (Delaware) and 58 (Texas) commuting zones. This allows us to estimate panel-style regressions within each state to net out between-state variation that might be confounding our current treatment estimates. <!-- \textcolor{violet}{These --> <!-- should be interpreted with caution in those states that contain very few --> <!-- commuting zones.} -->

```{r, echo = FALSE, results = 'asis', fig.cap = "Histogram: Commuting Zones by State"}
reg_states <- mines_cz_short %>%
  pull(state) %>%
  unique
  
mines_cz_short %>%
  group_by(state) %>%
  summarise(n_czs = n_distinct(cz_id)) -> hist_states_cz

hist_states_cz$state_name = sapply(hist_states_cz$state, get_state)

outliers <- filter(hist_states_cz, n_czs > 25)

ggplot(hist_states_cz, aes(x = n_czs)) +
  geom_histogram(bins = 25, fill = "dodgerblue4", color = "white", alpha = 0.8) +
  # add invisible points for label positioning
  geom_point(data = outliers, aes(y = 0), alpha = 0) +
  geom_text_repel(
    data = outliers,
    aes(x = n_czs, y = 1, label = state_name),
    nudge_y = 3.5,
    size = 3,
    color = "black"
  ) +
  common_theme +
  labs(
    x = "Number of Commuting Zones in State",
    y = "Number of States",
    title = "Distribution of Commuting Zones per State"
  )

```

\FloatBarrier

```{r, echo = FALSE}
extract_coef_info <- function(model, state_name, iv = FALSE) {
      # Get summary
      coef_summary <- summary(model)$coeftable
  if(iv){
      ftest_summary <- fitstat(model, "ivf1.stat")[[1]]
      ftest_p_summary <- fitstat(model, "ivf1.p")[[1]]
  }

  model_r2 <- r2(model, type = "wr2")
  # Filter for relevant variables
  coef_df <- as.data.frame(coef_summary) %>%
    rownames_to_column("variable") %>%
    filter(variable %in% vars_of_interest) %>%
    mutate(
      state = state_name,
      # Calculate 95% confidence intervals
      ci_lower = Estimate - 1.96 * `Std. Error`,
      ci_upper = Estimate + 1.96 * `Std. Error`,
      p_val = `Pr(>|t|)`,
      significance = case_when(
        p_val < 0.001 ~ "***",
        p_val < 0.01  ~ "**",
        p_val < 0.05  ~ "*",
        p_val < 0.1   ~ ".",
        TRUE               ~ ""
      ),
      r2_within = model_r2)
  
  if(iv){
    coef_df %>% 
      mutate(ftest = ftest_summary,
      ftest_p = ftest_p_summary) %>%
    select(state, variable, estimate = Estimate, ci_lower, ci_upper, p_val, significance, r2_within, ftest, ftest_p) %>% return(.)
  }else{
    coef_df %>% 
    select(state, variable, estimate = Estimate, ci_lower, ci_upper, p_val, significance, r2_within) %>% return(.)
  }
}
```

```{r state_by_state_descriptive, include = FALSE, echo = FALSE, results = 'asis', fig.height = 8, fig.width = 10, fig.cap = "State-by-State Wage Effect - Descriptive"}

append_to_appendix("## State-by-State Wage Effect",
                   "We report the regression coefficients of these estimations in Figures
13-15. First, we re-employ our baseline regression in which we regress
our outcome variable on wage levels at time $t-h$ where $h = [0,2]$. The
plot below displays the cumulative effect of a 1% increase in wage
levels on education expenditure per pupil in purple. The X marks
represent the individual betas on each time lag of the treatment
variable, the linear combination of which form the total dynamic effect
represented by the purple dots. Majority of states see positive
elasticities in relation to wage changes in this descriptive
specification, but some (Kansas, Wyoming, Missouri, Washington) see
negative elasticities.")

state_mods <- list()
for(k in reg_states){
  mod <- df_ivs %>%
    filter(state == k) %>%
    feols(as.formula("log_real_Elem_Educ_Total_Exp_pp ~ diff_log_real_Elem_Educ_Total_Exp_pp + log_weighted_annual_avg_wkly_wage + l1_log_weighted_annual_avg_wkly_wage + l2_log_weighted_annual_avg_wkly_wage + log_real_Total_IG_Revenue_pp + log_real_gdp_priv_ind_pc + log_Enrollment + pct_black + pct_hispanic | unit + year"),
    data = ., panel.id = c("unit", "year"), cluster = "unit")
  state_mods[[as.character(k)]] <- mod
}

# Define variable names of interest
vars_of_interest <- c("log_weighted_annual_avg_wkly_wage",
                      "l1_log_weighted_annual_avg_wkly_wage",
                      "l2_log_weighted_annual_avg_wkly_wage")

# Apply to list of models
# Assuming: model_list is named by state names
results_df <- imap_dfr(state_mods, extract_coef_info)
results_df$state_name <- sapply(results_df$state, get_state)

results_df_cleaned <- results_df %>%
  # Add lag labels
  mutate(label = case_when(
    variable == 'log_weighted_annual_avg_wkly_wage' ~ 'l0',
    variable == 'l1_log_weighted_annual_avg_wkly_wage' ~ 'l1',
    variable == 'l2_log_weighted_annual_avg_wkly_wage' ~ 'l2'
  )) %>%
  # filter(significance != "") %>%
  # Compute total estimate and max R²
  group_by(state_name) %>%
  mutate(
    total_estimate = sum(estimate, na.rm = TRUE),
    any_significant = any(significance != ""),
    r2_within_max = max(r2_within, na.rm = TRUE)
  ) %>%
  ungroup() %>%
  # Order `state` by R²
  mutate(state_name = fct_reorder(state_name, total_estimate, .desc = TRUE)) %>%
  # Create numeric lag order (to control x-axis sorting within each state)
  mutate(
    lag_order = case_when(label == "l0" ~ 1,
                          label == "l1" ~ 2,
                          label == "l2" ~ 3),
    state_label = paste(state_name, label, sep = "_")
  ) %>%
  # Reorder state_label using combined (state, lag_order)
  arrange(state_name, lag_order) %>%
  mutate(state_label = factor(state_label, levels = unique(state_label)))


# Create axis labels: state names at 'l1' only, blanks otherwise
axis_labels <- ifelse(grepl("_l0$", levels(results_df_cleaned$state_label)),
                      gsub("_l0$", "", levels(results_df_cleaned$state_label)),
                      "")

results_df_cleaned %>%
  # Plot
  ggplot(aes(x = state_label)) +
  geom_point(aes(y = estimate, alpha = significance), shape = "x", size = 3) +
  # geom_point(
  #   data = . %>% filter(label == "l1"),
  #   aes(y = total_estimate, color = r2_within_max), size = 2
  # ) +
  geom_point(
    data = . %>% filter(label == "l1"),
    aes(y = total_estimate, color = as.numeric(any_significant)), size = 2
  ) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  common_theme +
  theme(
    legend.position = "bottom",
    axis.text.x = element_text(angle = 90, hjust = 1)
  ) +
  labs(
    title = "Effect of 1% Increase in Wage on Education Expenditure per Pupil",
    x = "States (Each with lags: l0, l1, l2)",
    y = "Coefficient Estimate",
    caption = "Effect of contemporaneous, l1, l2 lag of avg weekly wage on PP Education\n Expenditure controlling for enrollment, GDP, and intergovernmental transfers. \n Each state has 3 lagged wage coefficients (l0, l1, l2).\n X's represent coefficients on each time lag. \nPurple dots show total effect across lags, plotted at the l1 position.\n Within R^2 of state-level estimation reflected in color of point).",
    color = "Within R2 of State-level Estimation",
    alpha = "Statistical Significance"
  ) +
    scale_x_discrete(labels = axis_labels) +
  scale_color_distiller(direction = 1, palette = "Purples")

results_df_cleaned_desc <- results_df_cleaned

```

\FloatBarrier

Using our instrumental variable approach with a value-added based shift-share instrument, we corroborate the directionality and magnitude of the effect for 12 states: New Hampshire, Colorado, Florida, South Dakota, Kentucky, Louisiana, Pennsylvania, North Dakota, Oregon, Oklahoma, Arizona, and Indiana. In estimating the state-by-state regressions, we exclude any states where our F-statistic is below conventional weak instrument thresholds (F statistics \<= 12 and p-value \< 0.05) and the p-value of the second stage coefficient of interest is \< 0.1.

Examining various characteristics of these states, we find that they vary widely in demographic composition, enrollment levels, and wage levels indicating that the detected effects are not attributable to any extremes in these values. Notably, majority of them reuly on a significant share of educational expenditure from local sources rather than intergovernmental sources.

```{r, echo = FALSE, fig.height = 10, fig.width = 10, fig.cap = "State-by-State Wage Effect Using SS GDP Shock"}

f_stat_threshold = 12

state_mods_ss <- list()
for(k in reg_states){
  mod <- df_ivs %>%
    filter(state == k) %>%
    feols(as.formula(paste0(iv_lev_form, ss_lev_lev_va)),
    data = ., panel.id = c("unit", "year"), cluster = "unit")
  state_mods_ss[[as.character(k)]] <- mod#$second_stage
  gc()
}

# Define variable names of interest
vars_of_interest <- c("fit_log_weighted_annual_avg_wkly_wage", "fitted_endog")

# Apply to list of models
# Assuming: model_list is named by state names
results_df <- imap_dfr(state_mods_ss, ~extract_coef_info(.x,.y, iv = TRUE))
results_df$state_name <- sapply(results_df$state, get_state)

results_df_cleaned <- results_df %>%
  # Add lag labels
  mutate(label = case_when(
    variable == 'fit_log_weighted_annual_avg_wkly_wage' ~ 'HPI Effect'
  )) %>%
  #filter(significance != "") %>%
  # Compute total estimate and max R²
filter(r2_within > 0 & ftest >= f_stat_threshold & ftest_p < 0.05 & p_val <= 0.1) %>%
  # Order `state` by R²
  mutate(state_name = fct_reorder(state_name, estimate, .desc = TRUE)) %>%
  # Reorder state_label using combined (state, lag_order)
  arrange(state_name) %>%
  mutate(state_label = factor(state_name, levels = unique(state_name)))

# Create axis labels: state names at 'l1' only, blanks otherwise
axis_labels <- levels(results_df_cleaned$state_label)

state_by_state_sig <- results_df_cleaned %>%
  # Plot
  ggplot(aes(x = state_label)) +
# Fill layer (with alpha by significance)
# geom_point(
#   aes(y = estimate, fill = ftest),
#    size = 4) +
    geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper), width = 0.2, alpha = 0.5) +

geom_point(aes(y = estimate, size = ftest, color = r2_within), stroke = 0.25, alpha = 1) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  common_theme +
  theme(
    legend.position = "bottom",
    axis.text.x = element_text(angle = 90, hjust = 1)
  ) +
  labs(
    title = "Effect of 1% Increase in Wage (using SS GDP Instrument) on Education Expenditure per Pupil",
    subtitle = paste0("Displays only states whose second-stage coefficient is statistically significant at the 5% level and first-stage F statistic >= ", f_stat_threshold, " and p-value < 0.05"),
    x = "States",
    y = "Coefficient Estimate",
    caption = paste0("Effect of 1% increase in Wage using l1 of GDP SS Instrument on PP Education\n Expenditure controlling for enrollment, GDP, % black, % hispanic, and intergovernmental transfers.\n Within R^2 of state-level estimation reflected in color of point. \nDisplays only states whose second-stage coefficient is statistically significant at the 5% level and first-stage F statistic >= ", f_stat_threshold, " and p-value < 0.05"),
   color = "Within R2 of State-level Estimation",
    size = "F-test statistic value",
    alpha = "Statistical Significance"
  ) +
    scale_x_discrete(labels = axis_labels)  +
  scale_fill_distiller(direction = 1) #+
  # scale_shape_manual(
  # values = c(
  #   "***" = 21,
  #   "**"  = 22,
  #   "*"   = 23,
  #   "."   = 24#,
  #   #""    = 25  # non-significant
  # )
#)

ggsave(here("output/state_by_state_est_plot.png"), width = 8, height = 7)
results_df_cleaned_iv <- results_df_cleaned

testerr <- mines_cz_short %>% select(state, 
                                     share_own,  
                                     log_real_gdp_priv_ind_pc,
          log_real_gdp_priv_ind,
          log_real_Elem_Educ_Total_Exp_pp,
          log_Enrollment, 
          log_weighted_annual_avg_wkly_wage,
          log_pop_school_age,
          pct_black,
          pct_hispanic,
          pct_white,
         log_real_Property_Tax_pp) %>% group_by(state) %>% 
  summarise(across(everything(), ~mean(., na.rm = TRUE))) %>% ungroup
testerr$state_name <- sapply(testerr$state, get_state)

state_rankings <- testerr %>%
  pivot_longer(
    cols = -c(state, state_name),  # All columns except 'state'
    names_to = "variable",
    values_to = "value"
  ) %>%
  group_by(variable) %>%
  mutate(
    rank = rank(-value, ties.method = "first"),  # Higher values = better rank (rank 1)
    # Or use rank(value) if lower values should be rank 1
    in_analysis = state %in% results_df_cleaned_iv$state,  # TRUE/FALSE for coloring
    color_in_analysis = ifelse(in_analysis, state_name, NA)
  ) %>%
  ungroup() %>% 
  mutate(var_label = case_when(variable == 'log_real_gdp_priv_ind_pc' ~ "(log) Private Industry GDP per capita",
#variable == 'diff_log_real_gdp_priv_ind_pc' ~ '(GR) Private Industry GDP per capita',
#variable ==  'diff_log_real_gdp_priv_ind' ~ '(GR) Private Industry GDP',
variable == 'log_real_gdp_priv_ind' ~ "(log) Private Industry GDP",
variable == 'log_weighted_annual_avg_wkly_wage' ~ '(log) Annual Avg Weekly Wage',
#variable == 'gr_weighted_annual_avg_wkly_wage' ~ '(GR) Annual Avg Weekly Wage',
variable == 'log_Enrollment' ~ '(log) Enrollment',
variable == 'log_pop_school_age' ~ '(log) School-age Population',
variable == 'share_own' ~ 'Share of Exp from Local Sources',
variable == "log_real_Elem_Educ_Total_Exp_pp" ~ "Education Expenditure per pupil",
variable == 'log_real_Property_Tax_pp' ~ "(log) Property Taxes Collected per pupil",
variable ==  "pct_black" ~ "% Black",
variable ==  "pct_hispanic" ~ "% Hispanic",
variable ==  "pct_white" ~ "% White"))

state_rankings_plot <- ggplot(state_rankings, aes(x = var_label, y = rank)) +
  geom_point(aes(color = color_in_analysis), size = 2, alpha = 0.7) +
  geom_text(aes(label = color_in_analysis, color = color_in_analysis),
    size = 4,
    hjust = -0.2,  # Offset text to the right of points
    check_overlap = TRUE  # Prevents label overlap
  ) +
  scale_y_reverse() +  # Rank 1 at top
  # scale_color_manual(
  #   #values = c("TRUE" = "steelblue", "FALSE" = "gray60"),
  #   #labels = c("TRUE" = "In Analysis", "FALSE" = "Not in Analysis"),
  #   #name = "Included in IV Analysis"
  # ) +
  labs(
    x = "Variable",
    y = "Rank",
    title = "State Rankings Across Variables"
  ) +
  common_theme +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "none"
  )

state_by_state_sig / state_rankings_plot
# testerr <- mines_cz_short %>% select(state,  share_own) %>% group_by(state) %>%  summarise(mean_share_own = mean(share_own, na.rm = TRUE)) %>% ungroup
# testerr$state_name <- sapply(testerr$state, get_state)
# 
# testerr %>% 
#   mutate(rel_iv = state_name %in% results_df_cleaned_iv$state_label) %>%
#   arrange(-mean_share_own) %>% 
#   mutate(state_name = fct_reorder(state_name, mean_share_own, .desc = TRUE)) %>%
#   ggplot(aes(x = state_name, y = mean_share_own, color = rel_iv)) + 
#   geom_point() +
#   geom_segment(data = . %>% filter(rel_iv), aes(x = state_name, xend = state_name, y = 0, yend = mean_share_own)) +
#   labs(
#     title = "Share of Expenditure from Own Sources",
#     subtitle = "Detected causal effect refers to those states whose first-stage F statistic >= 10 and p-value < 0.05",
#     x = "States",
#     y = "Ed. Exp. coming from Own (Local) Revenue",
#    color = "Detected Causal Effect") +
#     theme(axis.text.x = element_text(angle = 45,hjust = 1),
#                                      subtitle.text = element_text(fontsize = 6),
#                                      legend.position = "bottom",
#                                      ) +
#   scale_color_brewer(palette = "Set2")
# 
# ggsave(here('output/exp_share_compared_to_iv.png'), width =  8, height = 7)
# # 
# covs <- mines_cz %>%
#   select(cz_id, state, log_real_gdp_priv_ind_pc,
#          log_real_gdp_priv_ind,
#          log_real_Elem_Educ_Total_Exp_pp,
#          log_Enrollment, share_state,
#          log_weighted_annual_avg_wkly_wage,
#         #gr_weighted_annual_avg_wkly_wage,
#          #diff_log_real_gdp_priv_ind, diff_log_real_gdp_priv_ind_pc,
#         log_real_Property_Tax_pp) %>%
#   group_by(cz_id, state) %>%
#   summarise(across(everything(), ~mean(., na.rm = TRUE))) %>%
#   ungroup %>%
#   pivot_longer(!c(cz_id, state), names_to = 'covariate')
# 
# covs$state_name <- sapply(covs$state, get_state)
# 
# facet_labels <- c(
#   'log_real_gdp_priv_ind_pc' = "(log) Private Industry GDP per capita",
#   # 'diff_log_real_gdp_priv_ind_pc' = '(GR) Private Industry GDP per capita',
#   # 'diff_log_real_gdp_priv_ind' = '(GR) Private Industry GDP',
#   'log_real_gdp_priv_ind' = "(log) Private Industry GDP",
#   'log_weighted_annual_avg_wkly_wage' = '(log) Annual Avg Weekly Wage',
#   #'gr_weighted_annual_avg_wkly_wage' = '(GR) Annual Avg Weekly Wage',
#   'log_Enrollment' = '(log) Enrollment',
#   'share_state' = 'Share of Exp from State IG Transfers',
#   'log_real_Property_Tax_pp' = "(log) Property Taxes Collected per pupil"
# )
# 
# 
# covs %>%
#   # use ordering from coefficient estimate above
#   mutate(state_name = factor(state_name, levels = levels(results_df_cleaned$state_name))) %>%
#   ggplot(aes(x = state_name, y = value)) +
#   geom_violin(trim = FALSE, fill = "magenta", alpha = 0.2, color = NA) +
#   stat_summary(fun = median, geom = "point", position = position_dodge(width = 0.8),
#                shape = 21, size = 1.5, color = "black", fill = "magenta") +
#   facet_wrap(~covariate, ncol = 1, scales = "free", labeller = labeller(covariate = facet_labels)) +
#     theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
#   labs(title = "Value of Covariates in Order of State-level Coefficient Estimate",
#        subtitle = "Displays the distribution of various covariates by state.",
#        y = "Value",
#        x = "State (in order of coefficient estimate on wage level as in previous plot)")


```

```{r desc_v_iv, include = FALSE, echo = FALSE, results = 'asis', fig.height = 12, fig.width = 12, fig.cap = "Descriptive vs IV Regression Esimate"}

results_df_cleaned_desc %>% 
  select(r2_within, state_name, total_estimate, any_significant) %>% 
  distinct %>% 
  left_join(., results_df, by = "state_name") %>% 
  mutate(state_name = fct_reorder(state_name, estimate, .desc = TRUE)) %>%
  select(state, state_name, estimate, total_estimate, any_significant, significance) %>% 
  ggplot(aes(x = state_name)) + 
  geom_point(aes(y = total_estimate, color = "Descriptive"), size = 2, shape = 21) +
  geom_point(aes(y = estimate, color = "IV"), shape = 21,  size = 2) +
  geom_segment(aes(yend = estimate, y = total_estimate, color = "Descriptive"), color = "lightgrey") +
  geom_point(data = . %>% filter(state %in% results_df_cleaned_iv$state), aes(y = estimate,  color = "IV"), size = 3) +
    geom_point(data = . %>% filter(any_significant), aes(y = total_estimate,  color = "Descriptive"), size = 3) +
  geom_hline(aes(yintercept = 0), alpha = 0.2) +
  labs(title = "Difference between Descriptive and IV Estimates by State",
       subtitle = "Filled blue circles represent the statistically significant estimate in IV regressions for DE, MO, OH, AZ, WA, NH.\n We exclude MS as the statistically significant regression result is unreliable.",
       y = "Effect of Wage Levels on Education Expenditure",
       x = "State (ordered by Descriptive Effect size)",
       color = "Estimate") +
    scale_color_manual(
    values = c("Descriptive" = "royalblue4", "IV" = "purple3")
  ) +
  common_theme + 
  theme(legend.position = "bottom")

```

```{r wage_ss_state_by_state, include = FALSE, echo = FALSE, results = 'asis', fig.height = 12, fig.width = 12, fig.cap = "State-by-State Wage Effect Using SS Wage Shock"}

append_to_appendix("### Wage-based SS State by State Estimation", "")

state_mods_ss <- list()
for(k in reg_states){
  mod <- df_ivs %>%
    filter(state == k) %>%
    feols(as.formula(paste0(iv_lev_form, ss_lev_lev_va)),
    data = ., panel.id = c("unit", "year"), cluster = "unit")
  state_mods_ss[[as.character(k)]] <- mod
}

# Define variable names of interest
vars_of_interest <- c("fit_log_weighted_annual_avg_wkly_wage")

# Apply to list of models
# Assuming: model_list is named by state names
results_df <- imap_dfr(state_mods_ss, extract_coef_info)
results_df$state_name <- sapply(results_df$state, get_state)

results_df_cleaned <- results_df %>%
  # Add lag labels
  mutate(label = case_when(
    variable == 'fit_log_weighted_annual_avg_wkly_wage' ~ 'HPI Effect'
  )) %>%
  #filter(significance != "") %>%
  # Compute total estimate and max R²
filter(r2_within > 0) %>%
  # Order `state` by R²
  mutate(state_name = fct_reorder(state_name, estimate, .desc = TRUE)) %>%
  # Reorder state_label using combined (state, lag_order)
  arrange(state_name) %>%
  mutate(state_label = factor(state_name, levels = unique(state_name)))

# Create axis labels: state names at 'l1' only, blanks otherwise
axis_labels <- levels(results_df_cleaned$state_label)

results_df_cleaned %>%
  # Plot
  ggplot(aes(x = state_label)) +
# Fill layer (with alpha by significance)
geom_point(
  aes(y = estimate, fill = r2_within, shape = significance),
   size = 4) +
geom_point(aes(y = estimate), shape = 21, size = 4, fill = NA, color = "black", stroke = 0.25, alpha = 1) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  common_theme +
  theme(
    legend.position = "bottom",
    axis.text.x = element_text(angle = 90, hjust = 1)
  ) +
  labs(
    title = "Effect of 1% Increase in Wage (using SS Wage Instrument) on Education Expenditure per Pupil",
    x = "States",
    y = "Coefficient Estimate",
    caption = "Effect of 1% increase in Wage using l1 of Wage SS Instrument on PP Education\n Expenditure controlling for enrollment, GDP, and intergovernmental transfers.\n Within R^2 of state-level estimation reflected in color of point).",
    color = "Within R2 of State-level Estimation",
    alpha = "Statistical Significance"
  ) +
    scale_x_discrete(labels = axis_labels)  +
  scale_fill_distiller(direction = 1, palette = "Oranges") +
  scale_shape_manual(
  values = c(
    "***" = 21,
    "**"  = 22,
    "*"   = 23,
    "."   = 24#,
    #""    = 25  # non-significant
  )
)
# 
# 
# covs <- mines_cz %>%
#   select(cz_id, state, log_real_gdp_priv_ind_pc,
#          log_real_gdp_priv_ind,
#          log_real_Elem_Educ_Total_Exp_pp,
#          log_Enrollment, share_state,
#          log_weighted_annual_avg_wkly_wage,
#         #gr_weighted_annual_avg_wkly_wage,
#          #diff_log_real_gdp_priv_ind, diff_log_real_gdp_priv_ind_pc,
#         log_real_Property_Tax_pp) %>%
#   group_by(cz_id, state) %>%
#   summarise(across(everything(), ~mean(., na.rm = TRUE))) %>%
#   ungroup %>%
#   pivot_longer(!c(cz_id, state), names_to = 'covariate')
# 
# covs$state_name <- sapply(covs$state, get_state)
# 
# facet_labels <- c(
#   'log_real_gdp_priv_ind_pc' = "(log) Private Industry GDP per capita",
#   # 'diff_log_real_gdp_priv_ind_pc' = '(GR) Private Industry GDP per capita',
#   # 'diff_log_real_gdp_priv_ind' = '(GR) Private Industry GDP',
#   'log_real_gdp_priv_ind' = "(log) Private Industry GDP",
#   'log_weighted_annual_avg_wkly_wage' = '(log) Annual Avg Weekly Wage',
#   #'gr_weighted_annual_avg_wkly_wage' = '(GR) Annual Avg Weekly Wage',
#   'log_Enrollment' = '(log) Enrollment',
#   'share_state' = 'Share of Exp from State IG Transfers',
#   'log_real_Property_Tax_pp' = "(log) Property Taxes Collected per pupil"
# )
# 
# 
# covs %>%
#   # use ordering from coefficient estimate above
#   mutate(state_name = factor(state_name, levels = levels(results_df_cleaned$state_name))) %>%
#   ggplot(aes(x = state_name, y = value)) +
#   geom_violin(trim = FALSE, fill = "magenta", alpha = 0.2, color = NA) +
#   stat_summary(fun = median, geom = "point", position = position_dodge(width = 0.8),
#                shape = 21, size = 1.5, color = "black", fill = "magenta") +
#   facet_wrap(~covariate, ncol = 1, scales = "free", labeller = labeller(covariate = facet_labels)) +
#     theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
#   labs(title = "Value of Covariates in Order of State-level Coefficient Estimate",
#        subtitle = "Displays the distribution of various covariates by state.",
#        y = "Value",
#        x = "State (in order of coefficient estimate on wage level as in previous plot)")


```

### Industry by Industry

Finally, given our shift-share instruments are the composite effect of shifts in industry-level real value added (VA), we can decompose this instrument into industry-specific real value added shocks. This decomposition allows us to examine the effect of industry-specific changes across states in a more explicit manner. In other words, we re-design our instrument as...

$$
    \tilde{Z}_{ijt} = G_{njt} *  \frac{N_{ij\tau}}{N_{i\tau}}
$$ {#eq-bartik-decomposed}

...rather than the sum of all industry-level shocks.

We estimate separate panel regressions using the full commuting zone sample and then grouping commuting zones by state instrumenting local level wages by these decomposed shift-share shocks by industry.

Using our value added-based shift share instrument, Figure 10 demonstrates the overall treatment effect of local wage changes instrumented via an industry-specific GDP shock. We find that regardless of the instrument design, the coefficient estimate is consistent with the baseline results, where the estimated effect of a 10% change to local wages on public education expenditure is a 2.2% increase, with the effect's magnitude varying meaningfully for several states. We plot the relevant state-level effects for those states whose estimations pass the same restriction criteria as above (F statistics \<= 12 and p-value \< 0.05 and the p-value of the second stage coefficient of interest is \< 0.1).

\textcolor{red}{Again, I want to improve this.}

<!-- \textcolor{red}{Note: I think that the below implementation/interpretation is wrong as we cannot formally interpret anything from the instrument itself. Two options: (1) This table should be filtered by F-test or instrumental variable relevance to find what is most useful. What we would ideally see is a consistent wage response regardless of instrument choice. (2) Instrument *industry-specific* wages (not overall local wage levels() using these industry-specific shocks. In the second case, this could link well to the intro in which only those regressions in which there is a strong first stage (ie. GDP changes do predict local wages well) would qualify for analysis. If this reveals any significant effect, we would have a potential answer to the broader question as currently outlined in the intro...?} -->

```{r indind, echo = FALSE, warning = FALSE, message = FALSE, fig.height = 8, fig.width = 8, fig.cap = "Wage Effect via Industry VA SS Shock"}

# # Function to extract relevant info from each model
# extract_coef_info <- function(model, state_name) {
#   # Get summary
#   coef_summary <- summary(model)$coeftable
#   model_r2 <- r2(model, type = "wr2")
# 
#   # Filter for relevant variables
#   coef_df <- as.data.frame(coef_summary) %>%
#     rownames_to_column("variable") %>%
#     filter(variable %in% vars_of_interest) %>%
#     mutate(
#       state = state_name,
#       significance = case_when(
#         `Pr(>|t|)` < 0.001 ~ "***",
#         `Pr(>|t|)` < 0.01  ~ "**",
#         `Pr(>|t|)` < 0.05  ~ "*",
#         `Pr(>|t|)` < 0.1   ~ ".",
#         TRUE               ~ ""
#       ),
#       r2_within = model_r2) %>%
#     select(state, variable, estimate = Estimate, significance, r2_within)
# 
#   return(coef_df)
# }

# extract_coef_info <- function(model, state_name, iv = FALSE) {
#       # Get summary
#       coef_summary <- summary(model)$coeftable
#   if(iv){
#       ftest_summary <- model$iv_fstat_marginal
#       ftest_p_summary <- model$iv_fstat_marginal_p
#   }
# 
#   model_r2 <- r2(model, type = "wr2")
#   # Filter for relevant variables
#   coef_df <- as.data.frame(coef_summary) %>%
#     rownames_to_column("variable") %>%
#     filter(variable %in% vars_of_interest) %>%
#     mutate(
#       state = state_name,
#       # Calculate 95% confidence intervals
#       ci_lower = Estimate - 1.96 * `Std. Error`,
#       ci_upper = Estimate + 1.96 * `Std. Error`,
#       p_val = `Pr(>|t|)`,
#       significance = case_when(
#         p_val < 0.001 ~ "***",
#         p_val < 0.01  ~ "**",
#         p_val < 0.05  ~ "*",
#         p_val < 0.1   ~ ".",
#         TRUE               ~ ""
#       ),
#       r2_within = model_r2)
#   
#   if(iv){
#     coef_df %>% 
#       mutate(ftest = ftest_summary,
#       ftest_p = ftest_p_summary) %>%
#     select(state, variable, estimate = Estimate, ci_lower, ci_upper, p_val, significance, r2_within, ftest, ftest_p) %>% return(.)
#   }else{
#     coef_df %>% 
#     select(state, variable, estimate = Estimate, ci_lower, ci_upper, p_val, significance, r2_within) %>% return(.)
#   }
# }

# --- 0) Inputs / variable list ------------------------------------------------
temp_vars <- ss_temp %>%
  select(starts_with("lev_gdp_ss"), -contains("2d") , -contains("_61")) %>%  # <- fix select syntax
  names()

vars_of_interest <- c("fit_log_weighted_annual_avg_wkly_wage", "fitted_endog")

df_ivs_ind <- df_ivs %>% 
  select(unit, year, state, log_real_Elem_Educ_Total_Exp_pp, l1_log_real_Elem_Educ_Total_Exp_pp, log_real_Total_IG_Revenue_pp, log_real_gdp_priv_ind_pc, log_Enrollment, pct_black, pct_hispanic, log_weighted_annual_avg_wkly_wage, l1_log_weighted_annual_avg_wkly_wage, all_of(temp_vars)) %>% 
  group_by(unit) %>% 
    arrange(year) %>% 
    mutate(across(temp_vars, list(l1 = ~lag(., 1), 
                                     l2 = ~lag(., 2)), .names = "{.fn}_{.col}")) %>% 
  ungroup
  

# --- 1) Run models and collect estimates --------------------------------------
ind_mods <- tibble()
for (k in temp_vars) {
  ss_form_temp <- paste0(" log_weighted_annual_avg_wkly_wage ~ ", k ," + l1_", k, " + l2_", k, " + l1_log_weighted_annual_avg_wkly_wage")

  # "All" model IV
  iv_model <- feols(as.formula(paste0(iv_lev_form, ss_form_temp)), 
    data = df_ivs_ind, panel.id = c("unit", "year"), cluster = "unit") %>% extract_coef_info(state_name = "All", iv = TRUE)

  # State-by-state models
  state_mods_ind <- list()
  for (s in reg_states) {
    tmp <- df_ivs_ind %>% filter(state == s)

    if (tmp %>%
        select(state, unit, year, !!k) %>%
        group_by(unit) %>%
        filter(!all(is.na(get(k)))) %>% n_groups(.) == 1) {
      # skip if no variation
    } else {
      mod <- tmp %>% feols(as.formula(paste0(iv_lev_form, ss_form_temp)),
          data = ., panel.id = c("unit", "year"), cluster = "unit"
        )
      state_mods_ind[[s]] <- mod
    }
  }

  ind_mods <- imap_dfr(state_mods_ind, ~extract_coef_info(.x, .y, iv = TRUE)) %>%
    rbind(iv_model) %>%
    mutate(industry = gsub("lev_gdp_ss_", "", k)) %>%
    rbind(., ind_mods)
  
  gc()
}

# --- 2) Map industry codes to names (using your rel_inds) ---------------------
# assumes: rel_inds is a named vector where names(rel_inds) are industry names
# and values (or names) match the 'industry' codes we created above
results_df <- ind_mods %>%
  mutate(industry_name = names(rel_inds)[match(industry, rel_inds)])

# --- 3) Clean labels (no ordering yet) ----------------------------------------
base_df <- results_df %>%
  mutate(
    label = dplyr::case_when(variable == "fit_log_weighted_annual_avg_wkly_wage" ~ "Wage Effect",
                             variable == "fitted_endog" ~ "Wage Effect")
  )

# --- 4) Derive the x-axis order ONLY from the All-model estimates -------------
order_levels <- base_df %>%
  filter(state == "All") %>%
  arrange(desc(estimate)) %>%
  pull(industry_name) %>%
  unique()

base_df$state_name <- sapply(base_df$state, get_state)

# --- 5) Apply order and final cleaning ----------------------------------------
results_df_cleaned <- base_df %>%
  mutate(
    state_name = as.character(state_name),
    industry_label   = factor(industry_name, levels = order_levels),
    overall_estimate = dplyr::if_else(state == "All", estimate, NA_real_)
  ) #%>%
  #filter(r2_within > 0)


# First, create the base plot and store it
plot <- results_df_cleaned %>%
  ggplot(aes(x = industry_label)) +
  geom_point(
    data = ~ dplyr::filter(.x, state == "All"),
    aes(y = estimate, fill = r2_within),
    size = 3, shape = 21
  ) +
  geom_text(
    data = ~ dplyr::filter(.x, state != "All" & significance != "" & ftest >= 12),
    aes(y = estimate, label = state_name, color = state_name),
    size = 3,
    show.legend = FALSE
  ) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  common_theme +
  theme(
    legend.position = "bottom",
    axis.text.x = element_text(angle = 90, hjust = 1)
  ) +
  labs(
    title = "Effect of 1% Increase in Wage on Ed. Exp. per Pupil Using Industry-Specific GDP SS Shock",
    x = "Industry",
    y = "Coefficient Estimate",
    caption = "Effect of 1% increase in Wage Using Industry-Specific GDP (shift-share) Shocks. Controls: enrollment, GDP, intergov transfers, year & CZ FE.\nWithin R² of 'All' estimation in point color.\n X reflects statistically significant state-specific treatment effects with CZ FE.",
    fill = "Within R² (All model)",
    color = "State"  # Add this for state colors
  )
library(grDevices)
library(paletteer)
# Now add the rest
plot +
  scale_x_discrete(
    limits = order_levels,
    labels = function(x) stringr::str_wrap(x, width = 14)
  ) +
  guides(x = guide_axis(n.dodge = 2)) +
  #coord_cartesian(ylim = c(-1, 1), clip = "off") +  # Combined coord calls
  scale_fill_distiller(direction = 1, palette = "Greens") +
  scale_color_paletteer_d("ggthemes::Classic_20") +
  #scale_color_brewer(palette = "Spectral") +  # Use brewer for discrete colors
  guides(
    fill = guide_colorbar(
      title = "Within R² (All model)",
      title.position = "top",
      title.hjust = 0.5,
      barwidth = unit(6, "cm"),
      barheight = unit(0.5, "cm"),
      label.position = "bottom"
    ),
    color = guide_legend(  # Add guide for state colors
      title = "State",
      title.position = "top",
      title.hjust = 0.5
    )
  ) +
  theme(
    axis.text.x = element_text(size = 8, vjust = 1, hjust = 1, angle = 35),
    plot.margin = margin(t = 10, r = 10, b = 70, l = 10),
    legend.position = "bottom",
    legend.direction = "horizontal",
    legend.key.width = unit(0.5, "cm"),
    legend.key.height = unit(2.5, "cm"),
    legend.title = element_text(size = 10, face = "bold"),
    legend.text = element_text(size = 9),
    legend.spacing.x = unit(0.2, "cm"),
    legend.box.margin = margin(t = 0, r = 0, b = 0, l = 0),
    legend.box.spacing = unit(3, "mm")
  )

```

```{r wage_ss_ind_by_ind, include = FALSE, echo = FALSE, results = 'asis', fig.height = 12, fig.width = 12, fig.cap = "Wage Effect via Industry Wage SS Shock"}

append_to_appendix("#### Wage-based SS in Industry-by-Industry Estimation", 
                   "Using our wage-based shift share instrument, the below demonstrates the
overall treatment effect of local wage changes instrumented via our
wage-based shift-share shock.")

# --- 0) Inputs kept as-is -----------------------------------------------------
temp_vars <- ss_temp %>%
  select(starts_with("ss"), -contains("2d"), -contains("3d")) %>%
  names()

vars_of_interest <- c("fit_log_weighted_annual_avg_wkly_wage")

# --- 1) Run models and collect estimates --------------------------------------
ind_mods <- tibble()
for (k in temp_vars) {

  # All-states IV (the "All" point)
  iv_model <- feols(
    as.formula(paste0(
      iv_lev_form,
      " log_weighted_annual_avg_wkly_wage ~ l(", k, ") + l1_log_weighted_annual_avg_wkly_wage"
    )),
    data = df_ivs, panel.id = c("unit", "year"), cluster = "unit"
  ) %>% extract_coef_info(state_name = "All")

  # State-by-state models
  state_mods_ind <- list()
  for (s in reg_states) {
    tmp <- df_ivs %>% filter(state == s)

    if (tmp %>%
        select(state, unit, year, !!k) %>%
        group_by(unit) %>%
        filter(!all(is.na(get(k)))) %>% n_groups(.) == 1) {
      # skip if no variation
    } else {
      mod <- tmp %>%
        feols(
          as.formula(paste0(
            iv_lev_form,
            " log_weighted_annual_avg_wkly_wage ~ l(", k, ") + l1_log_weighted_annual_avg_wkly_wage"
          )),
          data = ., panel.id = c("unit", "year"), cluster = "unit"
        )
      state_mods_ind[[s]] <- mod
    }
  }

  ind_mods <- imap_dfr(state_mods_ind, extract_coef_info) %>%
    rbind(iv_model) %>%
    mutate(industry = gsub("ss_", "", k)) %>%
    rbind(., ind_mods)
}

# --- 2) Robust labeling (NAICS key) -------------------------------------------
naics_key <- tibble::tribble(
  ~naics_code, ~industry_name,
  "11","Agriculture, Forestry, Fishing, and Hunting",
  "21","Mining",
  "22","Utilities",
  "23","Construction",
  "31-33","Manufacturing",
  "42","Wholesale Trade",
  "44-45","Retail Trade",
  "48-49","Transportation and Warehousing",
  "51","Information",
  "52","Finance and Insurance",
  "53","Real Estate and Rental and Leasing",
  "54","Professional, Scientific, and Technical Services",
  "55","Management of Companies and Enterprises",
  "56","Administrative and waste management services",
  #"61","Educational Services",
  "62","Health Care and Social Assistance",
  "71","Arts, Entertainment, and Recreation",
  "72","Accommodation and Food Services",
  "81","Other Services, except government",
  "92","Public Administration"
)

# --- 3) Clean, join labels (no ordering yet) ----------------------------------
base_df <- ind_mods %>%
  mutate(
    variable   = ifelse(variable == "fit_log_weighted_annual_avg_wkly_wage", "fit_log_weighted_annual_avg_wkly_wage", variable),
    label      = dplyr::case_when(variable == "fit_log_weighted_annual_avg_wkly_wage" ~ "HPI Effect"),
    naics_code = gsub("^ss_", "", industry) |> gsub("_", "-", x = _)
  ) %>%
  left_join(naics_key, by = "naics_code")

# --- 4) Derive the x-axis order ONLY from the All-model estimates -------------
order_levels <- base_df %>%
  filter(state == "All") %>%
  arrange(desc(estimate)) %>%
  pull(industry_name) %>%
  unique()

# --- 5) Apply order and final cleaning ----------------------------------------
# CHANGE: RECODE EMPTY-STRING SIGNIFICANCE TO A READABLE LABEL ("n.s.") AND DEFINE LEVELS
sig_levels <- c("***","**","*",".","n.s.") # CHANGE: REPLACED "" WITH "n.s."

results_df_cleaned <- base_df %>%
  mutate(
    industry_label   = factor(industry_name, levels = order_levels),
    overall_estimate = dplyr::if_else(state == "All", estimate, NA_real_),
    # CHANGE: RECODE EMPTY STRING "" TO "n.s." THEN COERCE TO FACTOR USING sig_levels
    significance = dplyr::if_else(significance == "" | is.na(significance), "n.s.", significance),
    significance = factor(significance, levels = sig_levels)
  )

# --- 6) Plot -------------------------------------------------------------------
plot <- results_df_cleaned %>%
  ggplot(aes(x = industry_label)) +
  # state-specific estimates (light jittered Xs)
  geom_point(
    data = ~ dplyr::filter(.x, state != "All" & significance != "n.s."),  # CHANGE: REMOVE FILTER THAT EXCLUDED BLANK SIGNIFICANCE (NOW RECODED TO "n.s.")
    aes(y = estimate),
    shape = 4, size = 2, alpha = 0.5,
    position = position_jitter(width = 0, height = 0.01)
  ) +
  # All (overall) estimate, colored by within R^2 and SHAPED BY THE FACTORED 'significance' 
  geom_point(
    data = ~ dplyr::filter(.x, state == "All"),
    aes(y = estimate, color = r2_within, shape = significance),
    size = 4, stroke = 1,
  ) +
  geom_hline(yintercept = 0, linetype = "dashed", linewidth = 0.5) +
  coord_cartesian(ylim = c(-1, 1)) +
  scale_shape_manual(
    name = "Significance",
    # CHANGE: NAMED MAPPING INCLUDES "n.s." SO LEGEND SHOWS A LABEL FOR NON-SIGNIFICANT
    values = c("***" = 16, "**" = 17, "*" = 15, "." = 18, "n.s." = 1),
    labels = c("***" = "***", "**" = "**", "*" = "*", "." = ".", "n.s." = "n.s."), # CHANGE: EXPLICIT LABEL FOR LEGEND
    drop = FALSE,
    na.translate = TRUE
  ) +
  scale_color_viridis_c(name = "Within R² (All model)", option = "C", direction = 1) +
  labs(
    title = "Effect of 1% Increase in Industry-Specific Wage on Education Expenditure per Pupil",
    subtitle = "Dots: State-specific estimates (light) and overall estimate (colored by within R²)",
    x = "Industry (NAICS 2–3 digit groups)", y = "Coefficient estimate",
    caption = "IV: shift-share instrument; controls: enrollment, GDP, intergov transfers; FE: year & state.\nOverall points are from the 'All' model; X represent state-level treatment effects with CZ FE."
  ) +
  theme_minimal(base_size = 12) +
  theme(
    legend.position = "bottom",
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
    panel.grid.minor.y = element_blank()
  )

# lock x-order and wrap labels
plot +
  scale_x_discrete(
    limits = order_levels,
    labels = function(x) stringr::str_wrap(x, width = 14)
  ) +
  guides(x = guide_axis(n.dodge = 2)) +
  coord_cartesian(clip = "off") +
  theme(
    axis.text.x  = element_text(size = 8, vjust = 1, hjust = 1, angle = 35),
    plot.margin  = margin(t = 10, r = 10, b = 70, l = 10),
    legend.position = "top"
  )

```

\FloatBarrier

```{r, echo = FALSE, include = FALSE, eval = FALSE, results = 'asis'}

# compute_ss takes the source data "QCEW" or "QWI", a base year for the Bartik, whether to compute at CZ or fips level. This si then passed to plot_ss() which returns the instrumetn for a specific industry code and a plot.
if(new_ss_calculation){
  ss_temp_old <- compute_ss_old(source = "QCEW", base_year = 2004, unit_id = "cz_id")
  saveRDS(ss_temp_old, here("code/ss_cache_manual/ss_temp_old.RDS"))
}else{
  ss_temp_old <- readRDS(here("code/ss_cache_manual/ss_temp_old.RDS"))
}


# ind_codes %>% filter(nchar(industry_code) == 2 & industry_code != 99)  %>% select(-keep, -industry_code) %>% xtable() %>% print(include.rownames = FALSE)

ind_mods <- list()
inds <- ind_codes %>% filter(nchar(industry_code) == 2 & !(industry_code %in% c(10, 99))) %>% pull(industry_code) %>% unique
i <- 0
for(k in inds){
    print(k)
    ss_inst <- ss_temp_old %>%
      plot_ss_old(., k, "gr_natl_annual_avg_wkly_wage_", "cz_id", ind_codes)
    name <- ind_codes %>% filter(industry_code == k) %>% pull(industry_title)

    mods <- list()
    for(df in names(dfs)){
      print(df)
      # IV regression using shift-share instrument
      temp_dat <- left_join(dfs[[df]], rename(ss_inst, unit = cz_id), by = c("year", "unit"))
      stopifnot(temp_dat %>% group_by(cz_id, year) %>% n_groups == nrow(temp_dat))
      iv_model <- feols(
        as.formula(paste0("log_real_Elem_Educ_Total_Exp_pp ~ log_real_Total_IG_Revenue_pp + log_real_gdp_priv_ind_pc + log_Enrollment + l1_log_real_Elem_Educ_Total_Exp_pp  + pct_black + pct_hispanic | unit + year | log_weighted_annual_avg_wkly_wage ~ l(ss_", k, ",1)")),
        data = temp_dat, panel.id = c("unit", "year"), cluster = "unit"
      )
      mods[[df]] <- iv_model
    }
    ind_mods[[as.character(k)]] <- mods
}

for(k in names(ind_mods)){
  etable(ind_mods[[k]], title = k, tex = latex_tables, headers = names(ind_mods[[k]]),  adjustbox = TRUE) %>% print()
}

# Filter the list of models for significant log_real_gdp_priv_ind_pc coefficients
significant_mods <- mods[sapply(mods, function(m) {
  coefs <- summary(m)$coeftable
  if ("fit_log_weighted_annual_avg_wkly_wage" %in% rownames(coefs)) {
    return(coefs["fit_log_weighted_annual_avg_wkly_wage", "Pr(>|t|)"] < 0.05)}
  } else {
    return(FALSE)
  }
})]

```

## Additional Analysis Inventory

<!-- \textcolor{violet}{Provide brief inventory of additional analyses and robustness checks in supplementary materials here.} -->

In the Appendices we include:

\begin{itemize}
  \item Panel VAR Estimation
  \item Quantile regression estimation
  \item Exclusion of high-income CZ outliers
  \item Implementation of a wage-based (rather than VA-based) shift-share instrument
  \item National average treatment effects for all econometric estimation strategies outlined in the main text
  \item Information about the construction of the shift-share instrument
\end{itemize}

```{r quantile_reg, include = FALSE, echo = FALSE, results = 'asis', fig.cap = "Quantile Regression"}

append_to_appendix("### Quantile Regression", "")

# Step 1: Remove fixed effects (Canay 2-step)
fe_model <- feols(log_real_Elem_Educ_Total_Exp_pp ~
                    l1_log_real_Elem_Educ_Total_Exp_pp +
                    log_weighted_annual_avg_wkly_wage +
                                      l1_log_weighted_annual_avg_wkly_wage +
                                      l2_log_weighted_annual_avg_wkly_wage +
                                      log_real_Total_IG_Revenue_pp +
                                      log_real_gdp_priv_ind_pc +
                                      log_Enrollment + pct_black + pct_hispanic | unit + year, data = df_ivs, cluster = "unit") %>%
  tidy(.) %>%
  mutate(model = "OLS",
         tau = "1")

# Step 3: Run quantile regression on residuals at multiple quantiles
taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
qr_models <- map(taus, ~ rq(log_real_Elem_Educ_Total_Exp_pp ~
                    l1_log_real_Elem_Educ_Total_Exp_pp +
                    log_weighted_annual_avg_wkly_wage +
                                      l1_log_weighted_annual_avg_wkly_wage +
                                      l2_log_weighted_annual_avg_wkly_wage +
                                      log_real_Total_IG_Revenue_pp +
                                      log_real_gdp_priv_ind_pc +
                                      log_Enrollment + pct_black + pct_hispanic,
                            data = df_ivs, tau = .x))

# Step 4: Tidy results and add quantile info
qr_tidy <- map2_dfr(qr_models, taus, ~ tidy(.x) %>% mutate(tau = as.character(.y), model = "quantile"))

term_levels <- c("(Intercept)", "AR(1)", "L0 Wage", "L1 Wage", "L2 Wage",
                 "Enrollment", "IG Rev pp", "Ind. GDP pc")

# Step 5: Add significance stars and reshape
qr_tidy <- qr_tidy %>%
  rbind(fe_model) %>%
  mutate(
    p.value = 2 * (1 - pnorm(abs(statistic))),
    sig = case_when(
      p.value < 0.001 ~ "***",
      p.value < 0.01  ~ "**",
      p.value < 0.05  ~ "*",
      p.value < 0.1   ~ ".",
      TRUE ~ ""
    ),
    # Relabel variables for readability
    term = recode(term,
      "l1_log_real_Elem_Educ_Total_Exp_pp" = "AR(1)",
      "log_real_Total_IG_Revenue_pp" = "IG Rev pp",
      "log_real_gdp_priv_ind_pc" = "Ind. GDP pc",
      "log_Enrollment" = "Enrollment",
      "log_weighted_annual_avg_wkly_wage" = "L0 Wage",
      "l1_log_weighted_annual_avg_wkly_wage" = "L1 Wage",
      "l2_log_weighted_annual_avg_wkly_wage" = "L2 Wage"
    ),
    term = factor(term, levels = term_levels),
    xpos = as.numeric(term),

    # Combine shape and color label
    model_label = case_when(
      model == "OLS" ~ "OLS",
      TRUE ~ paste0("Quantile τ = ", tau)
    )
  )

# Plot with unified legend and updated shape mapping
qr_tidy %>%
  ggplot(aes(x = xpos, y = estimate, color = model_label, alpha = sig)) +
  geom_point(position = position_dodge(width = 0.6), size = 3) +
  geom_errorbar(
    aes(ymin = estimate - 1.96 * std.error,
        ymax = estimate + 1.96 * std.error),
    height = 0.2,
    position = position_dodge(width = 0.6)
  ) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  theme_minimal() +
  labs(
    title = "Coefficient Estimates from OLS and Quantile Regressions",
    x = "Estimate",
    y = NULL,
    color = "Model Type",
    shape = "Model Type"
  ) +
  theme(
    legend.position = "right",
    panel.grid.minor.y = element_blank(),
    panel.grid.major.y = element_line(linetype = "dashed"),
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_line(color = "slategrey")
  ) +
  scale_shape_manual(values = c(
    "OLS" = 17,  # triangle
    "Quantile τ = 0.1" = 16,
    "Quantile τ = 0.25" = 16,
    "Quantile τ = 0.5" = 16,
    "Quantile τ = 0.75" = 16,
    "Quantile τ = 0.9" = 16
  )) +
  scale_x_continuous(
    breaks = 1:length(term_levels),
    labels = term_levels
  )


```

```{r high_income_outliers_input, include = FALSE, echo = FALSE, results = 'asis'}

mines_no_outliers <- df_ivs %>%
  group_by(unit) %>%
  filter(!any(log_real_Elem_Educ_Total_Exp_pp > 10)) %>%
  ungroup

forms <- list(paste0(baseline_sw_short, " | unit + year"), paste0(iv_lev_form, "log_weighted_annual_avg_wkly_wage ~ lev_ss_2d + l1_lev_ss_2d + l2_lev_ss_2d"),
paste0(iv_lev_form, ss_lev_lev_va))


baseline <- feols(as.formula(forms[[1]]), data = mines_no_outliers, panel.id = c("unit", "year"), cluster = "unit")
wage_ss <- feols(as.formula(forms[[2]]), data = mines_no_outliers, panel.id = c("unit", "year"), cluster = "unit")
gdp_ss <- feols(as.formula(forms[[3]]), data = mines_no_outliers, panel.id = c("unit", "year"), cluster = "unit")


```

```{r high_income_outliers, include = FALSE, echo = FALSE, results = 'asis', fig.cap = "Scatterplot of Education Expenditure and Property Taxes by Funding Regime"}

append_to_appendix("### High-Income Outliers",
c("There is a somewhat non-linear relationship between property taxes and
elementary expenditure as property taxes collected rise as represented
in Figure 22 below. This happens largely as a result of very high-income
commuting zones. Therefore, we exclude any commuting zone that spends
more than 22k per pupil to avoid any distorting effects. This removes 12
CZs (\\~2% of the sample).",

"To assess whether the main results are driven by a small number of very
high-income jurisdictions, I re-estimate the baseline and IV
specifications excluding such outliers. The findings are fully
consistent with the baseline analysis: house prices remain a strong
predictor of local education spending, and the IV estimates continue to
imply that a 10% increase in house prices raises per-pupil expenditure
by roughly 4–6%. The wage-based shift-share instrument yields somewhat
larger point estimates, though with wider standard errors, while the
VA-based instrument produces effects in line with earlier results.
Overall, this robustness exercise confirms that the causal relationship
between housing wealth and education spending is not confined to
affluent areas but reflects a broader, generalizable pattern. These
findings confirm that the main result is not driven solely by affluent
jurisdictions, but reflects a more general relationship between local
housing wealth and education spending."))

mines_cz_short %>%
  ggplot(aes(x = log_real_Elem_Educ_Total_Exp_pp, y = log_real_Property_Tax_pp, colour = share_own_discrete)) +
  geom_jitter() +
    #geom_smooth(method=lm, colour = "black", linetype = "dashed") +
  labs(title = "Elem Education Expenditure pp vs Property Tax pp") +
  geom_vline(xintercept = 10, linetype = 'dashed') +
  theme_bw() +
  theme(title = element_text(size = 9)) +
  labs(colour = "Reliance on Local Sources")

etable(list(baseline, wage_ss, gdp_ss), fitstat = iv_fitstats, headers = c("Baseline 1", "Baseline 2", "Baseline 3", "Wage-based SS", "VA-based SS"), adjustbox = TRUE, tex = latex_tables, title = "Outlier Trimming Results")


```

\FloatBarrier

```{r appendix_pvar, include = FALSE, echo = FALSE, results = 'asis'}

panel_lines <- c(
  "$$",
  "Y_{it} = \\alpha_i +  \\sum_{k = 1}^{4} \\gamma_{k}A_{i,t-k} + \\beta X_{it} + \\varepsilon_{it}",
  "$$",
  "",
  "Where we approach a level and per capita value expression of the",
  "relationship between total education expenditure, intergovernmental",
  "revenue, house prices conditioned on GDP and wage levels.",
  "",
  "$$",
  "Y_{it} =",
  "\\begin{bmatrix}",
  "\\log(\\text{real Total Educ. Exp.})_{it} \\\\",
  "\\log(\\text{real Total IG Revenue})_{it} \\\\",
  "\\log(\\text{HPI})_{it}",
  "\\end{bmatrix},",
  "\\quad",
  "X_{it} =",
  "\\begin{bmatrix}",
  "\\log(\\text{real GDP})_{it} \\\\",
  "\\log(\\text{wage})_{it}",
  "\\end{bmatrix}",
  "$$",
  "",
  "- $A_1, A_2, A_3, A_4$ are $3 \\times 3$ coefficient matrices",
  "- $\\beta$ is a $3 \\times 2$ matrix of coefficients on the exogenous variables",
  "- $\\alpha_i$ is a vector of unit fixed effects",
  "- $\\varepsilon_{it}$ is the error term",
  "",
  "Where",
  "",
  "$$",
  "Y_{it} =",
  "\\begin{bmatrix}",
  "\\log(\\text{real Own Source Rev. per person})_{it} \\\\",
  "\\log(\\text{real IG Revenue per person})_{it} \\\\",
  "\\log(\\text{wage})_{it} \\\\",
  "\\log(\\text{HPI})_{it}",
  "\\end{bmatrix},",
  "\\quad",
  "X_{it} =",
  "\\begin{bmatrix}",
  "\\log(\\text{real GDP per capita})_{it}",
  "\\end{bmatrix}",
  "$$",
  "",
  "- $A_1, A_2, A_3, A_4$ are $4 \\times 4$ coefficient matrices",
  "- $B$ is a $4 \\times 1$ coefficient matrix",
  "- $\\alpha_i$ unit fixed effects",
  "- $\\varepsilon_{it}$ error term"
)

append_to_appendix("## Panel VAR Specification", panel_lines)


pvar_data <- mines_cz_short %>%
  #select(unit, year, contains("real_Total_Educ_Total_Exp"), contains("real_gdp_total")) %>%
  drop_na() %>%
  data.frame()

# Estimate PVAR with 1 lag
pvar_model_levels <- pvarfeols(
  dependent_vars = c("log_real_Total_Educ_Total_Exp",
                     #"log_real_Total_Rev_Own_Sources",
                     #"log_real_gdp_priv_ind",
                     #"log_real_Property_Tax",
                     "log_real_Total_IG_Revenue", #"log_real_Total_Fed_IG_Revenue_pp",
                     #"log_weighted_annual_avg_wkly_wage",
                     "log_hpi"),
  exog_vars = c("log_real_gdp_priv_ind", "log_weighted_annual_avg_wkly_wage"), #"share_own",
  lags = 4,
  #transformation = "demean",   # alternative: "firstdiff"
  data = pvar_data,
  panel_identifier = c("unit", "year")
)

pvar_model_levels_pc <- pvarfeols(
  dependent_vars = c(#"log_real_Total_Educ_Total_Exp_pp", #"log_real_gdp_priv_ind_pc",
                     "log_real_Total_Rev_Own_Sources_pp",
                     #"log_real_Property_Tax_pp",
                     "log_real_Total_IG_Revenue_pp",
                     "log_weighted_annual_avg_wkly_wage", #"log_real_Total_State_IG_Revenue_pp", "log_real_Total_Fed_IG_Revenue_pp",
                     "log_hpi"),
  exog_vars = c("log_real_gdp_priv_ind_pc"), #"share_own",
  lags = 4,
  #transformation = "demean",   # alternative: "firstdiff"
  data = pvar_data,
  panel_identifier = c("unit", "year")
)

for(mod in list(pvar_model_levels, pvar_model_levels_pc)){
  #summary(mod) %>% print

  # Impulse response function
  irf_result <- mod %>% girf(n.ahead = 10, ma_approx_steps= 10)

  # irf_result_bootstrapped <- bootstrap_irf(mod, typeof_irf = c("GIRF"),
  #           n.ahead = 10,
  #           nof_Nstar_draws = 3,
  #           confidence.band = 0.95,
  #           mc.cores = 5)
  # Plot IRFs
  plot(irf_result, scales = "free") %>% print()
  cat("    \n")
  cat("    \n")
  cat("    \n")
  cat("    \n")
}


# # Get shock variables (names of shock sources)
# shock_vars <- names(irf_result)
# irf_df <- map_dfr(shock_vars, function(shock) {
#   lower_matrix <- irf_result_bootstrapped$Lower[[shock]]
#   upper_matrix <- irf_result_bootstrapped$Upper[[shock]]
#
#   # Calculate mean pointwise IRF from bootstrap draws
#   mean_matrix <- (lower_matrix + upper_matrix) / 2
#
#   expand.grid(
#     horizon = seq_len(nrow(mean_matrix)),
#     response = colnames(mean_matrix)
#   ) %>%
#     mutate(
#       shock = shock,
#       irf = as.vector(mean_matrix),
#       lower = as.vector(lower_matrix),
#       upper = as.vector(upper_matrix)
#     )
# })
# ggplot(irf_df, aes(x = horizon, y = irf)) +
#   geom_line(color = "steelblue") +
#   geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2, fill = "steelblue") +
#   facet_grid(response ~ shock, scales = "free_y") +
#   labs(
#     title = "Impulse Response Functions with 95% Confidence Intervals",
#     x = "Horizon",
#     y = "Response"
#   ) +
#   theme_minimal()


```

<!-- # Property Prices -->

<!-- ```{r, echo = FALSE, results = 'asis', cache = TRUE} -->

<!-- # is <- isatpanel( -->

<!-- #       data = data.frame(mines_cz_short), -->

<!-- #       formula = as.formula("log_hpi ~ log_weighted_annual_avg_wkly_wage + l1_log_weighted_annual_avg_wkly_wage + l2_log_weighted_annual_avg_wkly_wage"), -->

<!-- #       index = c("unit", "year"), -->

<!-- #       effect = "twoways", -->

<!-- #       #iis = TRUE, -->

<!-- #       fesis = TRUE, -->

<!-- #       #ar = 1, -->

<!-- #       t.pval = 0.01, -->

<!-- #       max.block.size = 5 -->

<!-- #     ) -->

<!-- fun_list <- c(log_hpi ~ log_weighted_annual_avg_wkly_wage + l1_log_weighted_annual_avg_wkly_wage + l2_log_weighted_annual_avg_wkly_wage + log_real_gdp_priv_ind | unit + year, -->

<!-- gr_hpi ~ gr_weighted_annual_avg_wkly_wage + l1_gr_weighted_annual_avg_wkly_wage + l2_gr_weighted_annual_avg_wkly_wage | unit + year, -->

<!-- log_real_Elem_Educ_Total_Exp ~ log_weighted_annual_avg_wkly_wage + l1_log_weighted_annual_avg_wkly_wage + l2_log_weighted_annual_avg_wkly_wage + log_real_gdp_priv_ind + l1_log_real_gdp_priv_ind + l2_log_real_gdp_priv_ind | unit + year, -->

<!-- diff_log_real_Elem_Educ_Total_Exp ~ gr_weighted_annual_avg_wkly_wage + l1_gr_weighted_annual_avg_wkly_wage + l2_gr_weighted_annual_avg_wkly_wage + diff_log_real_gdp_priv_ind + l1_diff_log_real_gdp_priv_ind + l2_diff_log_real_gdp_priv_ind | unit + year, -->

<!-- log_real_Elem_Educ_Total_Exp_pp ~ log_weighted_annual_avg_wkly_wage + l1_log_weighted_annual_avg_wkly_wage + l2_log_weighted_annual_avg_wkly_wage + log_real_gdp_priv_ind_pc + l1_log_real_gdp_priv_ind_pc + l2_log_real_gdp_priv_ind_pc | unit + year, -->

<!-- diff_log_real_Elem_Educ_Total_Exp_pp ~ gr_weighted_annual_avg_wkly_wage + l1_gr_weighted_annual_avg_wkly_wage + l2_gr_weighted_annual_avg_wkly_wage + diff_log_real_gdp_priv_ind_pc + l1_diff_log_real_gdp_priv_ind_pc + l2_diff_log_real_gdp_priv_ind_pc | unit + year) -->

<!-- run_model(fun_list, mines_no_outliers) %>% etable(tex = latex_tables, adjustbox = TRUE) -->

<!-- ``` -->

<!-- ```{r, echo = FALSE, results = 'asis', cache = TRUE} -->

<!-- # General-to-Specific model selection using fixest -->

<!-- gets_fixest <- function(dep_var, indep_vars, data, fe = NULL, pval_cutoff = 0.1) { -->

<!--   remaining_vars <- indep_vars -->

<!--   repeat { -->

<!--     # Build formula -->

<!--     rhs <- paste(remaining_vars, collapse = " + ") -->

<!--     formula_str <- as.formula(paste(dep_var, "~", rhs, if (!is.null(fe)) paste("|", fe) else "")) -->

<!--     # Estimate model -->

<!--     model <- feols(formula_str, data = data) -->

<!--     coefs <- summary(model)$coeftable -->

<!--     # Filter out only the coefficients from the explanatory variables -->

<!--     pvals <- coefs[, "Pr(>|t|)"] -->

<!--     pvals <- pvals[names(pvals) %in% remaining_vars] -->

<!--     # Stop if all variables are below the cutoff or no variables remain -->

<!--     if (length(pvals) == 0 || all(pvals < pval_cutoff)) break -->

<!--     # Remove the variable with the highest p-value -->

<!--     worst_var <- names(which.max(pvals)) -->

<!--     remaining_vars <- setdiff(remaining_vars, worst_var) -->

<!--   } -->

<!--   # Return the final reduced model -->

<!--   final_formula <- paste(dep_var, "~", paste(remaining_vars, collapse = " + "), if (!is.null(fe)) paste("|", fe) else "") -->

<!--   return(final_formula) -->

<!-- } -->

<!-- # Example usage -->

<!-- # Replace 'your_data' with your actual data frame name -->

<!-- final_model <- gets_fixest( -->

<!--   dep_var = "log_real_Elem_Educ_Total_Exp_pp", -->

<!--   indep_vars = c("log_weighted_annual_avg_wkly_wage", -->

<!--                  "l1_log_weighted_annual_avg_wkly_wage", -->

<!--                  "l2_log_weighted_annual_avg_wkly_wage", -->

<!--                  "log_real_gdp_priv_ind_pc", -->

<!--                  "l1_log_real_gdp_priv_ind_pc", -->

<!--                  "l2_log_real_gdp_priv_ind_pc", -->

<!--                  "log_real_Property_Tax_pp", -->

<!--                  #"log_real_Total_State_IG_Revenue_pp", -->

<!--                  #"log_real_Total_Fed_IG_Revenue_pp", -->

<!--                  "log_hpi"),  # replace with your actual variable names -->

<!--   data = mines_cz_short, -->

<!--   fe = "unit + year",        # optional fixed effects -->

<!--   pval_cutoff = 0.1         # significance threshold -->

<!-- ) -->

<!-- # View results -->

<!-- # At a 10% significance level, we retain a 2-timeperiod lag of real_gdp_pc, contemporaneous wage (not likely), property_tax_pp, state_revenue_pp, hpi -->

<!-- feols(as.formula(final_model), data = mines_cz_short) %>% etable(adjustbox = TRUE, tex = latex_tables) -->

<!-- # I want to allow the coefficient to vary on the weekly wage treatment variable -->

<!-- feols(as.formula(gsub("log_weighted_annual_avg_wkly_wage", "i(share_own_discrete, log_weighted_annual_avg_wkly_wage)", final_model)), data = mines_cz_short) %>% -->

<!--   etable(adjustbox = TRUE, tex = latex_tables) -->

<!-- ``` -->

<!-- ```{r, cache = TRUE} -->

<!-- test <- readRDS(here("output/prop_price_breaks_csis.RDS")) -->

<!-- ``` -->

<!-- ### Property Prices as Endogenous Regressor -->

<!-- \textcolor{violet}{Until a few weeks ago, I was using the following identification strategy which produced perhaps more interesting results (in terms of instrument relevance and statistically significant results. However, it did not answer our fundamental research question of the relationship between local economic performance and education expenditure. They provide evidence of a causal relationship between property values and public education expenditure using the same shift-share instruments as above. I include the results of this work at the end of the document, for reference. In case there is something useful there for the narrative.} -->

<!-- ```{r, child = "regressions_prop_prices.qmd"} -->

<!-- ``` -->

# Conclusion

## Discussion

This work establishes a causal link between local wage growth and public education expenditure. Our baseline estimates reveal a short-run wage elasticity of 0.23, with a long-run cumulative effect of approximately 0.46. The dynamic components of the econometric specification indicate significant persistence in local public education budgets, indicating both institutional inertia but also the likely rare revision of local tax rates allowing local wage growth to boost education spending. This persistence indicates potential for asymmetric adjustment likely correlated with local growth trajectories, wherein communities experiencing wage growth are likely to see gradual spending increases, while declining communities could experience the opposite effect.

This positive elasticity is concentrated in a third of the states in the sample (New Hampshire, Colorado, Florida, South Dakota, Kentucky, Louisiana, Pennsylvania, North Dakota, Oregon, Oklahoma, Arizona, and India), whereas other states exhibit minimal or insignificant responsiveness.

Though outcomes measured in this study are not direct inequality metrics, our findings reveal that the decentralised school financing system in the US has the potential to exacerbate inequalities in local public well-being by failing to equalise across regions experiencing diverging growth trajectories. As a result, in the states in which local spending is responsive to changes in local wages, the quality of early childhood education might be compromised by macroeconomic trends and industry-specific shocks beyond local control. Thus, equalisation formulas at the state and federal level that fail to account for wage trends and fiscal multipliers may contribute to disparities in public goods delivery. Theories of effective equalisation, and indeed preferences for redistribution, differ especially across regions of the the United States. However, equalisation efforts should at least aim to insulate communities from potential downward pressures on public education expenditure.

The determinants of inequality in public education delivery in the US are multiple and complex. Significant evidence exists of the role of historically discriminatory policies related to congressional districting, under-investment in low-income areas of color @trounstine2016 @trounstine2021 @sosina2019 . Though this work does not directly inform this debate, further work could explore the extent to which wage growth interacts with such structural policies.

Addressing structural inequality requires rethinking education finance, taking the decentralised American context as given. Ensuring educational equity for all children requires not just strengthening existing mechanisms for redistribution, but also, in light of our results, insulating communities from macroeconomic trends that impact communities heterogeneously.

## Limitations

-   Excludability assumptions about local industry composition

-   Data limits true consideration of non-stationarity issues. Estimating this model in first differences or growth rates would be preferable to address non-stationarity concerns as well as allow for asymmetric treatmetn estimation to distinguish between negative and positive wage pressures. However, this would require improvements in data collection of the required variables.

-   Commuting zones mask substantial within-commuting zone heterogeneity

# Data and Code Availability

\textcolor{red}{Code and data to reproduce the analysis will be made available on Github or Zenodo.}

# Use of AI

-   Used ChatGPT to help improve readability of plots (formatting, margins, labeling, font size).
-   Used ChatGPT to debug errors in R during data cleaning and plotting.
-   Used ChatGPT to provide suggestions for reducing run time of repetitive tasks (ex. downloading and processing multiple data files).

# Acknowledgements

```{r, echo = FALSE}
BUILDING_APPENDIX <- FALSE
```

```{r, child = "appendix_generated.qmd"}


```
