# Property Prices Analysis {-}

```{r, echo = FALSE, message = FALSE, cache = FALSE}

options(width = 500)
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)

library(tidyverse)
library(conflicted)
library(stargazer)
library(quantreg)
library(purrr)
library(zoo)
library(tidycensus)
library(here)
library(viridis)
library(viridisLite)
library(datasets)
library(broom)
library(xtable)
library(fipio)
library(panelvar)
library(fixest)
library(paletteer)
library(readxl)
library(ggrepel)
library(plm)
library(getspanel)
library(usmap)
library(patchwork)
library(kableExtra)
library(lattice)
library(lubridate)
library(stringr)
library(xts)
library(urca)
library(dynlm)
library(tseries)
library(quantmod)
library(lmtest)
library(sandwich)
library(patchwork)
library(vars)
library(assertthat)
library(ggridges)
library(grid)
library(RColorBrewer)
library(ggplotify)
source(here('code/source_code/useful_functions.R'))
source(here('code/source_code/dicts.R'))
source(here('code/reg_forms.R'))
source(here('code/source_code/cz_cleaning.R'))
conflict_prefer_all("dplyr", quiet = TRUE)

setFixest_etable(fitstat = ~ . + ivf1 + ivf1.p + ivf2 + ivf2.p + wh + wh.p + ivwaldall + ivwaldall.p + kpr, se.below = TRUE)

# Custom R2 representation for IV regressions - only want to display R2 for second-stage
fitstat_register(
  type = "r2_firststage",
  fun = function(m) {
    is_second_stage <- any(grepl("^fit_", names(coef(m))))
    if (is_second_stage) return(NA_real_)
    unname(r2(m, "r2"))  # standard R²
  },
  alias = "R2 (1st stage)"
)
# Custom Adjusted R² for 1st stage only
fitstat_register(
  type = "ar2_firststage",
  fun = function(m) {
    is_second_stage <- any(grepl("^fit_", names(coef(m))))
    if (is_second_stage) return(NA_real_)
    unname(r2(m, "ar2")) # adjusted R²
  },
  alias = "Adj. R2 (1st stage)"
)

iv_fitstats = ~ n + r2_firststage + ar2_firststage + ivfall + ivfall.p + wh + wh.p + ivwaldall + ivwaldall.p

default_iv_note = c("", "Note that the R2 and Adjusted R2 values for second-stage regressions are irrelevant information here. I have not yet figured out how to suppress them from the regression tables but will do so for the final version.")

unit_id = "cz_id"
new_ss_calculation = FALSE
latex_tables = TRUE

source(here("code/source_code/pull_data.R"))

```

## Approaching Causal Identification

Though the descriptive relationship between various economic variables
and public education expenditure provides convincing evidence of the
reliance of local education expenditure on economic conditions in both levels and growth rates, this
relationship has no causal interpretation.

Indeed, there is a significant endogeneity concern in using wages or
property prices as a treatment variable given the likely attracting
factor of high levels of education expenditure for higher-income
families. However, the structure of public financing (described in
further detail in Section \ref{si_section:Challenges} of the
Supplementary Materials) provides an avenue for
a causal identification strategy. In brief, revenue for public education
comes from a combination of intergovernmental and local sources. Revenue
generated from local sources comes almost entirely from property taxes.
Given this, we can isolate the channel through which our treatment
(industry-specific wage growth) will affect our outcome variable using
an instrumental variable approach. We outline the underlying path
diagram of this econometric specification in Figure \ref{fig:iv-approach}.

\begin{figure}[H]
\centering
\caption{Instrumental Variable Path Diagram}
\begin{tikzpicture}
% nodes %
\node[rectangle] (z) at (0,0) {Instrument};
\node (t) at (4,0) {Property Values};
\node (y) at (8,0) {Education Expenditure};
\node (u) at (6,-2) {Omitted variable};

% edges %
\draw[->, line width=1] (z) -- (t);
\draw[->, line width=1] (t) -- (y);
\draw[->, line width=1, violet, dashed] (u) -- (t);
\draw[->, line width=1, violet, dashed] (u) -- (y);
\draw[->, line width=1, red, bend right=40, dashed] (y) to (t);
\end{tikzpicture}
\label{fig:iv-approach}
\end{figure}

As seen in Figure \ref{fig:iv-approach}, we hypothesize that property values
have an effect on education expenditure. However, there is significant
concern of a reverse causal effect as higher income families likely
gravitate towards school districts with higher levels of expenditure per
pupil, driving up property values \textcolor{red}{(Could likely add sources here)}.

Therefore, we adopt an identification strategy via a shift-share or
Bartik instrument. A shift-share instrument interacts local industry
shares with national industry-level growth rates to attain a plausibly
exogenous local shock. In the context of this work, we construct the
instrument by interacting a constant industrial employment share
variable with a national industry-level wage.

We choose to employ the first of these options, assuming that industry
shares are only exogenous at a given base period and that national
level growth rates are exogenous and therefore allowed to vary with
time.

Using data from the US Bureau of Labor Statistics' Quarterly Census of
Employment and Wages (QCEW) and Bureau of Economic Analysis, we
construct two types of shift-share Bartik instruments at the commuting
zone level using local employment shares by industry and national
changes in industry-specific wages and real value added. Equation
@eq-bartik demonstrates the Bartik instrument as outlined in @ferri2022
and @goldsmith-pinkham2020 and defined in @bartik1991 . $G_{njt}$
represents national-level changes in wages or value added in industry
$j$ in time $t$ and $\frac{N_{ij\tau}}{N_{i\tau}}$ represents the
'sensitivity' of a CZ to these national shocks proxied by an initial
share of local employment in industry $j$ in a baseline time period
$\tau$. The product of these two values defines the shift-share
indicator $\tilde{Z}_{i,t,s}$. In order to construct the share portion,
we compute the total local share of employment in a particular industry
$j$. Due to challenges with missing data, we compute an average share
across 2001-2005 as our 'base year'.

\footnote{We explore the sensitivity of results to the choice of base period
    $\tau$ by constructing the instrument for various base periods as
    well as a rolling window.
    \textcolor{red}{I have done this unsystematically so far (testing 2001, 2004, and 2005) but arrived at the decision to compute an average to deal with missing data. Will include a more systematic testing of this in the appendix.}}

$$
    \tilde{Z}_{ijt} = G_{njt} *  \frac{N_{ij\tau}}{N_{i\tau}}
$${#eq-bartik}

<!-- ![Coal Shift-share -->

<!-- Instruments](../output/bartik_graphs.jpg){#fig-bartik_graph} -->

```{r appendix_industry_shares_cleaning, include = FALSE, echo = FALSE, results = 'asis'}

# Draw the functions needed to calculate the SS instruments from the following script.
source(here("data/raw/QCEW/industry_shares_cleaning.R"))

```

```{r compute_ss, echo = FALSE, cache = TRUE}

if(new_ss_calculation){
  ss_shares <- compute_shares(source = "QCEW", base_year = 2004, unit_id = "cz_id", flat = FALSE)

  coverage <- ss_shares %>% select(coverage_2digit_naics, coverage_3digit_naics) %>% distinct

  ss_temp <- compute_ss(ss_shares)

  saveRDS(ss_temp, here("code/ss_cache_manual/ss_temp.RDS"))
  saveRDS(coverage, here("code/ss_cache_manual/coverage_ss.RDS"))
}else{
  ss_temp <- readRDS(here("code/ss_cache_manual/ss_temp.RDS"))
  coverage <- readRDS(here("code/ss_cache_manual/coverage_ss.RDS"))
}

```

We compute the two relevant shift-share instruments across 19 two-digit NAICS industrial categories listed in Table \textcolor{red}{X} below. Given industry-level disaggregation of local employment and wage data requires data suppression for anonymity reasons, the plot immediately following
displays the data coverage of our commuting zone level shift-share instruments. Given the high degree of
missingness in the 3-digit categorisation we proceed with the 2-digit
NAICS codes in the rest of the work. \textcolor{red}{I need to double check how I handle public adminsitration wage and employment data. I believe I exclude this category from the analysis.}

```{r, echo = FALSE, cache = FALSE, results = 'asis', message = FALSE}

rel_inds <- c("Agriculture, Forestry, Fishing, and Hunting" = "11",
"Mining" = "21",
"Construction" = "23",
"Manufacturing" = "31_33",
"Wholesale Trade" = "42",
"Retail Trade" = "44_45",
"Transportation and Warehousing" = "48_49",
"Utilities" = "22",
"Information" = "51",
"Finance and Insurance" = "52",
"Real Estate and Rental and Leasing" = "53",
"Professional, Scientific, and Technical Services" = "54",
"Management of Companies and Enterprises" = "55",
"Administrative and waste management services" = "56",
"Educational Services" = "61",
"Health Care and Social Assistance" = "62",
"Arts, Entertainment, and Recreation" = "71",
"Accommodation and Food Services" = "72",
"Other Services, except government" = "81",
"Public Administration" = "92")

data.frame("NAICS.Code" = unname(rel_inds), "Industry" = names(rel_inds))  %>% 
  mutate(NAICS.Code = gsub("_", "-", NAICS.Code)) %>% 
  xtable() %>% print(include.rownames = FALSE)

```

```{r, echo = FALSE, cache = TRUE}

if(new_ss_calculation){
  temp_new <- shares_flat_filled %>%
    select(!contains("share")) %>%
    filter(year <= 2005) %>%
    group_by(unit) %>%
    # Creates a mean employment level across 2001-2005 - 5 year mean to deal with missing data
    summarise(across(!year, ~mean(., na.rm = TRUE))) %>%
    ungroup  %>%
    rename(fips = unit)

    if(unit_id == "cz_id"){
      czs_new <- czs %>%
        #select(-old_fips) %>%
        rename(old_fips = fips) %>%
        mutate(fips = case_when(!is.na(getfips[old_fips]) ~ getfips[old_fips],
                                TRUE ~ old_fips),
               cz_id = as.character(cz_id))

      missing_fips <- czs_new %>%
        pull(fips) %>%
        unique %>%
        setdiff(unique(temp_new$fips), .)

      if (length(missing_fips) > 0) {
        message("Warning: Some FIPS codes are missing from czs.")
      }

      temp <- temp_new %>%
        select(fips, matches("^annual_avg_emplvl_\\d{2}$"), annual_avg_emplvl_10_filled) %>%
        left_join(., czs_new, by = "fips", multiple = "first") %>%
        rename("unit" = cz_id) %>%
        select(-c(fips, old_fips, cz_population, cz_id_1990)) %>%
        relocate(unit)

    }else if(unit_id == "fips"){
      temp <- temp %>%
        rename(unit = fips)
    }


  shift_share_filled <- temp %>%
      group_by(unit) %>%
      summarise(across(everything(), ~sum(., na.rm = TRUE))) %>%  # , total_annual_wages)
                #annual_avg_wkly_wage = mean(annual_avg_wkly_wage, na.rm = TRUE)) %>%
      ungroup %>%
    mutate(across(contains("avg_emplvl"), ~./annual_avg_emplvl_10_filled, .names = "share_{.col}")) %>%
    select(unit, contains('share')) %>%
    mutate(year = 2001) %>%
    complete(unit, year = 2001:2022) %>%
    group_by(unit) %>%
    fill(everything(), .direction = "updown") %>%
    ungroup

  assert_that(nrow(shift_share_filled) == n_distinct(shift_share_filled$unit) * n_distinct(shift_share_filled$year))

  ss_temp_fill <- shift_share_filled %>%
        select(unit, year, contains("share")) %>%
        left_join(., natl_rates, by = "year", relationship = "many-to-one") %>%
        rename(!!unit_id := unit) %>%
        select(-ends_with("10"))

  ss_temp_filled <- compute_ss(ss_temp_fill)
  saveRDS(ss_temp_filled, here("code/ss_cache_manual/ss_temp_filled.RDS"))

}else{
  ss_temp_filled <- readRDS(here("code/ss_cache_manual/ss_temp_filled.RDS"))
}

ss_temp_old <- ss_temp
ss_temp <- ss_temp_filled


```

Before displaying the regression results using our shift-share
instrument we discuss the plausibility of our identification strategy by
exploring the relationships between wage and GDP on housing prices. We
provide evidence of this relationship below.

### Industry-level Wages

The two regression models show that wage levels and wage growth both
play important roles in influencing house prices, but in different ways.
The log-level model indicates that increases in average wages have a
strong and persistent effect on the level of house prices, with
significant positive effects extending up to four years. In contrast,
the growth rate model suggests that house price growth responds
primarily to contemporaneous wage growth, with little evidence of lagged
effects. Together, these findings imply that while higher wages steadily
raise housing values over time, short-term changes in wage growth
do not affect the growth rate of house prices over time.
Together, they suggest that housing markets are more responsive to
trends than to transitory shocks in wages. \textcolor{red}{I am unsure about this interpretation - given GR regressed on GR is simply meant to handle non-stationarity issues...I worry that the GR results might just indicate that the level regression is meaningless?}

```{r, echo = FALSE, cache = TRUE, results = 'asis'}

t1 <- feols(log_hpi ~ l(log_weighted_annual_avg_wkly_wage, 0:7) + log_real_gdp_priv_ind_pc + log_pop_total | unit + year, panel.id = c('year', 'unit'), mines_cz)
t1_state_fe <- feols(log_hpi ~ l(log_weighted_annual_avg_wkly_wage, 0:7) + log_real_gdp_priv_ind_pc + log_pop_total | state + year, panel.id = c('year', 'unit'), mines_cz)

t2 <- feols(gr_hpi ~ l(gr_weighted_annual_avg_wkly_wage, 0:7) + diff_log_real_gdp_priv_ind_pc + diff_log_pop_total| unit + year, panel.id = c('year', 'unit'), mines_cz)
t2_state_fe <- feols(gr_hpi ~ l(gr_weighted_annual_avg_wkly_wage, 0:7) + diff_log_real_gdp_priv_ind_pc + diff_log_pop_total| state + year, panel.id = c('year', 'unit'), mines_cz)

etable(list(t1, t1_state_fe, t2, t2_state_fe), tex = latex_tables)

```

<!-- ```{r appendix_ss_plots, include = FALSE, echo = FALSE, results = 'asis'} -->

<!-- append_to_appendix("## Shift-Share Instrument Graphs", -->

<!-- "The below displays graphically the various shift-share instruments.") -->

<!-- ss_temp %>% -->

<!--   ggplot(aes(x = year, y = ss_2d, group = cz_id)) + -->

<!--   geom_line() + -->

<!--   labs(title = "Wage-based Shift-Share Instrument: 2-digit NAICS", -->

<!--        x = "SS Instrument: Local Employment Share x National Industry-Specific Wage Growth", -->

<!--        y = "Year") -->

<!-- # ss_temp %>% -->

<!-- #   ggplot(aes(x = year, y = ss_3d, group = cz_id)) + -->

<!-- #   geom_line() + -->

<!-- #   labs(title = "Wage-based Shift-Share Instrument: 3-digit NAICS", -->

<!-- #        x = "SS Instrument: Local Employment Share * National Industry-Specific Wage Growth", -->

<!-- #        y = "Year") -->

<!-- ss_temp %>% -->

<!--   ggplot(aes(x = year, y = lev_ss_2d, group = cz_id)) + -->

<!--   geom_line() + -->

<!--   labs(title = "Wage-based Shift-Share Instrument: 2-digit NAICS", -->

<!--        x = "SS Instrument: Local Employment Share x National Industry-Specific Wage Level", -->

<!--        y = "Year") -->

<!-- # ss_temp %>% -->

<!-- #   ggplot(aes(x = year, y = lev_ss_3d, group = cz_id)) + -->

<!-- #   geom_line() + -->

<!-- #   labs(title = "Wage-based Shift-Share Instrument: 3-digit NAICS", -->

<!-- #        x = "SS Instrument: Local Employment Share * National Industry-Specific Wage Level", -->

<!-- #        y = "Year") -->

<!-- ss_temp %>% -->

<!--   ggplot(aes(x = year, y = gdp_ss_2d, group = cz_id)) + -->

<!--   geom_line() + -->

<!--   labs(title = "Value Added Shift-Share Instrument: 2-digit NAICS", -->

<!--        x = "SS Instrument: Local Employment Share x National Industry-Specific VA Growth", -->

<!--        y = "Year") -->

<!-- ss_temp %>% -->

<!--   ggplot(aes(x = year, y = lev_ss_3d, group = cz_id)) + -->

<!--   geom_line() + -->

<!--   labs(title = "Value Added Shift-Share Instrument: 2-digit NAICS", -->

<!--        x = "SS Instrument: Local Employment Share x National Industry-Specific VA Level", -->

<!--        y = "Year") -->

<!-- ``` -->

Finally, we display the results for a 2SLS estimation using our
wage-based shift-share instrument.

The instrumental variable estimates provide evidence of a robust causal
relationship between national wage and GDP fluctuations and public education expenditure. Utilising our wage-based shift-share instrument we see highly significant and relevant first-stage relationships when the shift-share instrument is imposed both in levels and growth rates. Though the growth rate specification is only relevant with at least a 1-year lag and using state- instead of commuting zone-level fixed effects. 

In each case in the first table, the first-stage regression yields a
statistically significant and economically large coefficient. Varying the time-lag and inclusion of state or commuting zone fixed effects, we see that a 1%
increase in the shift-share measure (which can be interpreted as a natural logarithm) is associated with a 0.05-0.5% increase
in the local House Price Index (p \< 0.01), with an F-statistic between 47-140 (all well above conventional weak instrument thresholds) confirming
instrument relevance. The second-stage results are significant in all cases except the growth rate shocks with commuting zone level fixed effects.

In the level shift-share regressions, the instrumental variables estimates suggest that increases in house prices have a strong and statistically significant effect on education expenditure per pupil. Across specifications (columns 2, 4, 6, and 8), the estimated elasticity is close to one, implying that a 1% increase in house prices translates into nearly a 1% increase in elementary education spending. The instruments (intergovernmental revenue per capita and state wages) are highly relevant, as indicated by the very large first-stage F-statistics (well above the conventional threshold of 10), alleviating concerns about weak instruments. The Wu-Hausman tests reject the null of exogeneity, confirming that OLS estimates are biased and IV estimation is appropriate. Wald tests of joint significance further support the strength of the instruments. Taken together, these results provide robust evidence that higher property values causally increase local education spending, consistent with a mechanism in which rising property wealth expands the fiscal capacity of local governments. Furthermore, given the dependent variable measures per pupil expenditure, this result implies direct effects in experience per student. 

Using wage shocks in levels yields strong instruments, high first-stage F-statistics, and stable second-stage estimates: higher house prices robustly increase education spending. In contrast, when shocks are measured in growth rates, the instruments lose predictive power (first-stage F-statistics ~1–2), resulting in weak identification. The second-stage coefficients become unstable and often insignificant, while Hausman tests fail to reject exogeneity. This suggests that the growth-rate specification is poorly identified and cannot provide reliable causal inference, whereas the level specification produces credible and consistent results.


The specification that uses wage shocks in levels provides the most credible identification strategy. The instruments are strong, as indicated by very large first-stage F-statistics well above conventional thresholds, and the second-stage results are both large and robust across specifications. The Wu–Hausman tests reject exogeneity, reinforcing the necessity of IV estimation over OLS. By contrast, when wage shocks are expressed in growth rates, the identifying variation is substantially reduced, resulting in weak first stages and unstable second-stage estimates. Since levels capture the cross-sectional fiscal variation that drives differences in property values and school spending, the level specification is more consistent with the economic mechanisms of interest and delivers more reliable causal estimates.


At the same time, the weakness of the growth-rate specification does raise concerns about the robustness of the results. If the relationship between wages, house prices, and education expenditure is driven by common non-stationary trends, then regressions in levels risk spurious correlation. In this sense, the fact that the IV design loses power when variables are differenced into growth rates may suggest that part of the strong level results reflect long-run trends rather than short-run causal shocks. While the large first-stage F-statistics and Hausman tests in the level specification support its validity, the weak performance of the growth-rate version cautions that the results could be sensitive to issues of persistence and trending in the data.

Taken together, these results suggest that while the level specification provides strong identification and compelling evidence of a positive causal effect of house prices on education spending, the weak performance of the growth-rate specification highlights the need for caution, as the strength of the findings may partly reflect long-run trending relationships rather than purely exogenous shocks.

However, examining the structure of the growth rate shock, the instability of the variable in growth rate is likely causing the poor identification in the growth rate regressions.


```{r, echo = FALSE, results = 'asis', cache = TRUE}

iv_model_2d_lev_gr <- feols(as.formula("log_real_Elem_Educ_Total_Exp_pp ~ log_real_Total_IG_Revenue_pp + log_real_gdp_priv_ind_pc + log_Enrollment | unit + year | log_hpi ~ ss_2d"),
    data = left_join(mines_cz, rename(ss_temp, unit = cz_id), by = c("year","unit")), panel.id = c("unit", "year"))

iv_model_2d_lev_lev <- feols(
    as.formula("log_real_Elem_Educ_Total_Exp_pp ~ log_real_Total_IG_Revenue_pp + log_real_gdp_priv_ind_pc + log_Enrollment | unit + year | log_hpi ~ lev_ss_2d"),
    data = left_join(mines_cz, rename(ss_temp, unit = cz_id), by = c("year","unit")), panel.id = c("unit", "year"))

iv_model_2d_lev_gr_l1 <- feols(as.formula("log_real_Elem_Educ_Total_Exp_pp ~ log_real_Total_IG_Revenue_pp + log_real_gdp_priv_ind_pc + log_Enrollment | unit + year | log_hpi ~ l(ss_2d,1)"),
    data = left_join(mines_cz, rename(ss_temp, unit = cz_id), by = c("year","unit")), panel.id = c("unit", "year"))

iv_model_2d_lev_lev_l1 <- feols(
    as.formula("log_real_Elem_Educ_Total_Exp_pp ~ log_real_Total_IG_Revenue_pp + log_real_gdp_priv_ind_pc + log_Enrollment | unit + year | log_hpi ~ l(lev_ss_2d,1)"),
    data = left_join(mines_cz, rename(ss_temp, unit = cz_id), by = c("year","unit")), panel.id = c("unit", "year"))

iv_model_2d_lev_gr_state_fe <- feols(as.formula("log_real_Elem_Educ_Total_Exp_pp ~ log_real_Total_IG_Revenue_pp + log_real_gdp_priv_ind_pc + log_Enrollment | state + year | log_hpi ~ ss_2d"),
    data = left_join(mines_cz, rename(ss_temp, unit = cz_id), by = c("year","unit")), panel.id = c("unit", "year"))

iv_model_2d_lev_lev_state_fe <- feols(
    as.formula("log_real_Elem_Educ_Total_Exp_pp ~ log_real_Total_IG_Revenue_pp + log_real_gdp_priv_ind_pc + log_Enrollment | state + year | log_hpi ~ lev_ss_2d"),
    data = left_join(mines_cz, rename(ss_temp, unit = cz_id), by = c("year","unit")), panel.id = c("unit", "year"))

iv_model_2d_lev_gr_l1_state_fe <- feols(as.formula("log_real_Elem_Educ_Total_Exp_pp ~ log_real_Total_IG_Revenue_pp + log_real_gdp_priv_ind_pc + log_Enrollment | state + year | log_hpi ~ l(ss_2d,1)"),
    data = left_join(mines_cz, rename(ss_temp, unit = cz_id), by = c("year","unit")), panel.id = c("unit", "year"))

iv_model_2d_lev_lev_l1_state_fe <- feols(
    as.formula("log_real_Elem_Educ_Total_Exp_pp ~ log_real_Total_IG_Revenue_pp + log_real_gdp_priv_ind_pc + log_Enrollment | state + year | log_hpi ~ l(lev_ss_2d,1)"),
    data = left_join(mines_cz, rename(ss_temp, unit = cz_id), by = c("year","unit")), panel.id = c("unit", "year"))

# iv_model_2d_lev_gr_tfe <- feols(as.formula("log_real_Elem_Educ_Total_Exp_pp ~ log_real_Total_IG_Revenue_pp + log_real_gdp_priv_ind_pc + log_Enrollment | year + state | log_hpi ~ l(ss_2d,1)"),
#     data = left_join(mines_cz, rename(ss_temp, unit = cz_id), by = c("year","unit")), panel.id = c("unit", "year"))
# 
# iv_model_2d_lev_lev_tfe <- feols(
#     as.formula("log_real_Elem_Educ_Total_Exp_pp ~ log_real_Total_IG_Revenue_pp + log_real_gdp_priv_ind_pc + log_Enrollment | year + state | log_hpi ~ l(lev_ss_2d,1)"),
#     data = left_join(mines_cz, rename(ss_temp, unit = cz_id), by = c("year","unit")), panel.id = c("unit", "year"))

# iv_model_2d_share <- feols(
#     as.formula("log_real_Elem_Educ_Total_Exp_pp ~ log_real_gdp_priv_ind_pc | unit + year + log_Enrollment | log_hpi ~  state_share*l(ss_2d,1)"),
#     data = left_join(mines_cz, rename(ss_temp, unit = cz_id), by = c("year", "unit")), panel.id = c("unit", "year"))
# 
# iv_model_2d_levshare <- feols(
#     as.formula("log_real_Elem_Educ_Total_Exp_pp ~ log_real_gdp_priv_ind_pc + log_Enrollment | unit + year | log_hpi ~  state_share*l(lev_ss_2d,1)"),
#     data = left_join(mines_cz, rename(ss_temp, unit = cz_id), by = c("year", "unit")), panel.id = c("unit", "year"))


etable(iv_model_2d_lev_lev, iv_model_2d_lev_lev_state_fe, iv_model_2d_lev_lev_l1, iv_model_2d_lev_lev_l1_state_fe, adjustbox = TRUE,   headers = list("Stage" = c("1st", "2nd")), stage = 1:2, fitstat = iv_fitstats, tex = latex_tables)

etable(iv_model_2d_lev_gr, iv_model_2d_lev_gr_state_fe, iv_model_2d_lev_gr_l1, iv_model_2d_lev_gr_l1_state_fe, adjustbox = TRUE, stage = 1:2, fitstat = iv_fitstats, tex = latex_tables)

```

### Industry-level GDP

We perform a similar combined baseline and causal IV estimation using the GDP-based shift-share instrument. 

The estimates indicate that house prices are strongly correlated with local economic conditions. In the levels specification, both GDP per capita and population are positively associated with higher house prices, although the inclusion of state fixed effects alters the sign of lagged GDP coefficients, suggesting long-run mean reversion or heterogeneity across states. In the growth specification, contemporaneous GDP growth and short-run lags exert a positive effect on house price growth, while population growth also contributes significantly. Overall, these results imply that both the size and short-run dynamics of the local economy play a central role in shaping housing markets.

Overall, compared to wages, the relatively more sensitive stability of the relationship between GDP per capita and house prices indicates a weaker, and potentially more spurious link between real GDP and house prices. This conclusion logically aligns with the fact that the channel through which local economic activity links to house prices is through wages. Wages offer a more direct way of measuring the effect of local economic health on house prices than does real GDP. Nonetheless, the relationship still indicates a positive association between local economic health an dhousing prices, enough to warrant an investigation of our real value added shift-share instrument.


```{r, echo = FALSE, cache = TRUE, results = 'asis'}

t1 <- feols(log_hpi ~ l(log_real_gdp_priv_ind_pc, 0:7) + log_pop_total | unit + year, panel.id = c('year', 'unit'), mines_cz)
t1_state_fe <- feols(log_hpi ~ l(log_real_gdp_priv_ind_pc, 0:7) + log_pop_total | state + year, panel.id = c('year', 'unit'), mines_cz)

t2 <- feols(gr_hpi ~ l(diff_log_real_gdp_priv_ind_pc, 0:7) +  diff_log_pop_total| unit + year, panel.id = c('year', 'unit'), mines_cz)
t2_state_fe <- feols(gr_hpi ~ l(diff_log_real_gdp_priv_ind_pc, 0:7) +  diff_log_pop_total| state + year, panel.id = c('year', 'unit'), mines_cz)


etable(list(t1, t1_state_fe, t2, t2_state_fe), tex = latex_tables)

```

Moving on to investigate the GDP-based shift-share instrument, we find a similar effect as with wages when estimating level shift-share shocks. The first-stage relationship between GDP shocks and house prices ranges from 0.1-0.7% increase in response to a 1% increase in the shift-share instrument (interpreted as wage levels) with an F-statistic between 100-400. These results hold after controlling for local revenues, GDP per capita, and enrollment, and the Wu-Hausman tests reject OLS in favor of IV, suggesting that naive estimates are biased. Overall, the evidence supports a causal channel from rising local housing wealth to increased investment in public education. However, we see an even weaker relationship when imposing the shift-share instrument as a growth rate shock where the first-stage relationship are spurious and statistically insignificant. 

Together, these findings suggest that levels (rather than short-run
changes) in GDP are more systematically and substantially associated
with house price dynamics. The stronger fit and significant lag effects
in the level regression underscore the longer-term influence of
economic fundamentals on housing markets. It also indicates that wage
growth is more important for house prices than the more general presence
of industry-level GDP growth. This makes intuitive sense in that the
link from industrial success (labour) to personal and community wealth creation is mediated via wage and
not necessarily the total industrial output which might not be reflected
in wages (especially given recent evidence of decoupling of wages from
productivity) \textcolor{red}{Source here - OECD and FRED Data}.

![Wages and Productivity](../output/FRED%20wage%20decoupling.png)
```{r, echo = FALSE, results = 'asis', cache = TRUE}

iv_model_2d_lev_gr <- feols(as.formula("log_real_Elem_Educ_Total_Exp_pp ~ log_real_Total_IG_Revenue_pp + log_real_gdp_priv_ind_pc + log_Enrollment | unit + year | log_hpi ~ gdp_ss_2d"),
    data = left_join(mines_cz, rename(ss_temp, unit = cz_id), by = c("year","unit")), panel.id = c("unit", "year"))

iv_model_2d_lev_lev <- feols(
    as.formula("log_real_Elem_Educ_Total_Exp_pp ~ log_real_Total_IG_Revenue_pp + log_real_gdp_priv_ind_pc + log_Enrollment | unit + year | log_hpi ~ lev_gdp_ss_2d"),
    data = left_join(mines_cz, rename(ss_temp, unit = cz_id), by = c("year","unit")), panel.id = c("unit", "year"))

iv_model_2d_lev_gr_l1 <- feols(as.formula("log_real_Elem_Educ_Total_Exp_pp ~ log_real_Total_IG_Revenue_pp + log_real_gdp_priv_ind_pc + log_Enrollment | unit + year | log_hpi ~ l(gdp_ss_2d,1)"),
    data = left_join(mines_cz, rename(ss_temp, unit = cz_id), by = c("year","unit")), panel.id = c("unit", "year"))

iv_model_2d_lev_lev_l1 <- feols(
    as.formula("log_real_Elem_Educ_Total_Exp_pp ~ log_real_Total_IG_Revenue_pp + log_real_gdp_priv_ind_pc + log_Enrollment | unit + year | log_hpi ~ l(lev_gdp_ss_2d,1)"),
    data = left_join(mines_cz, rename(ss_temp, unit = cz_id), by = c("year","unit")), panel.id = c("unit", "year"))

iv_model_2d_lev_gr_state_fe <- feols(as.formula("log_real_Elem_Educ_Total_Exp_pp ~ log_real_Total_IG_Revenue_pp + log_real_gdp_priv_ind_pc + log_Enrollment | state + year | log_hpi ~ gdp_ss_2d"),
    data = left_join(mines_cz, rename(ss_temp, unit = cz_id), by = c("year","unit")), panel.id = c("unit", "year"))

iv_model_2d_lev_lev_state_fe <- feols(
    as.formula("log_real_Elem_Educ_Total_Exp_pp ~ log_real_Total_IG_Revenue_pp + log_real_gdp_priv_ind_pc + log_Enrollment | state + year | log_hpi ~ lev_gdp_ss_2d"),
    data = left_join(mines_cz, rename(ss_temp, unit = cz_id), by = c("year","unit")), panel.id = c("unit", "year"))

iv_model_2d_lev_gr_l1_state_fe <- feols(as.formula("log_real_Elem_Educ_Total_Exp_pp ~ log_real_Total_IG_Revenue_pp + log_real_gdp_priv_ind_pc + log_Enrollment | state + year | log_hpi ~ l(gdp_ss_2d,1)"),
    data = left_join(mines_cz, rename(ss_temp, unit = cz_id), by = c("year","unit")), panel.id = c("unit", "year"))

iv_model_2d_lev_lev_l1_state_fe <- feols(
    as.formula("log_real_Elem_Educ_Total_Exp_pp ~ log_real_Total_IG_Revenue_pp + log_real_gdp_priv_ind_pc + log_Enrollment | state + year | log_hpi ~ l(lev_gdp_ss_2d,1)"),
    data = left_join(mines_cz, rename(ss_temp, unit = cz_id), by = c("year","unit")), panel.id = c("unit", "year"))


etable(iv_model_2d_lev_lev, iv_model_2d_lev_lev_state_fe, iv_model_2d_lev_lev_l1, iv_model_2d_lev_lev_l1_state_fe, adjustbox = TRUE, stage = 1:2,fitstat = iv_fitstats, tex = latex_tables, title ="GDP-based Shift-share instrument (Level-Level, varying state and CZ fixed effects and lags.")
etable(iv_model_2d_lev_gr, iv_model_2d_lev_gr_state_fe, iv_model_2d_lev_gr_l1, iv_model_2d_lev_gr_l1_state_fe, adjustbox = TRUE, stage = 1:2,fitstat = iv_fitstats, tex = latex_tables,  title ="GDP-based Shift-share instrument (Level-GR, varying state and CZ fixed effects and lags.")


```

## Accounting for Heterogeneity

In order to make meaningful policy-related insights, we need to unmask the substantial heterogeneity obscured by the national-level average treatment effects described above. Barring design and data issues with our
shift-share instrument, these national-level estimates are unlikley to apply uniformly across states and commuting zones.
Therefore, this next section is dedicated to unpacking this
heterogeneity. Below, we explore various metrics of local economic
growth and decline to (1) partition our sample according to metrics of economic health, employ (2) industry-by-industry 
and (2) state-by-state uestimations sing our baseline descriptive
models, wage- and GDP-based shift-share instruments.

### Declining vs. Growing Regions

First, we identify declining and growing regions by estimating commuting-zone
growth rates conditional on state and national level growth rates and partition our sample across this distribution.

```{r, include = FALSE, cache = TRUE}

cz_labels <- read_xls(here('data/out/cz00_eqv_v1.xls')) %>%
  clean_names %>% 
  select(commuting_zone_id_2000, metropolitan_area_2003) %>%
  rename(unit = commuting_zone_id_2000) %>% 
  distinct %>% 
  arrange(unit) %>% 
  filter(!is.na(metropolitan_area_2003)) %>% 
  mutate(unit = as.character(unit)) %>% 
  group_by(unit) %>%
  summarise(
    msa = paste(sort(unique(metropolitan_area_2003)), collapse = ";\n"),
    n_msa = n_distinct(metropolitan_area_2003),                     # optional: how many collapsed
    .groups = "drop"
  )

```

```{r, include = FALSE, cache = TRUE}
state_lev <- mines_cz %>%
  group_by(state, year) %>%
  summarise(across(c(real_gdp_priv_ind, real_gdp_total, pop_total), ~sum(., na.rm = TRUE))) %>%
  ungroup %>%
  mutate(real_gdp_priv_ind_pc = real_gdp_priv_ind/pop_total,
         real_gdp_total_pc = real_gdp_total/pop_total,
         across(!c(state, year), ~log(. + 1), .names = "log_{.col}")) %>%
  group_by(state) %>%
  mutate(across(contains("log"), ~.- dplyr::lag(., 1), .names = "diff_{.col}")) %>%
  ungroup

natl_lev <- mines_cz %>%
  group_by(year) %>%
  summarise(across(c(real_gdp_priv_ind, real_gdp_total, pop_total), ~sum(., na.rm = TRUE))) %>%
  ungroup %>%
  mutate(real_gdp_priv_ind_pc = real_gdp_priv_ind/pop_total,
         real_gdp_total_pc = real_gdp_total/pop_total,
         across(!c(year), ~log(. + 1), .names = "log_{.col}"),
         across(contains("log"), ~.- dplyr::lag(., 1), .names = "diff_{.col}"))

growth_rates <- mines_cz %>%
  select(unit, names(state_lev), ) %>%
  left_join(., state_lev, by = c("state", "year"), suffix = c("", "_state")) %>%
  left_join(., natl_lev, by = c("year"), suffix = c("", "_natl"))
```



In order to identify declining and growing commuting zones, we separate time series models by commuting zone: 

$$
\Delta \log GDPpc^{CZ}_{t} 
= \alpha_{cz} 
+ \beta_{n} \, \Delta \log GDPpc^{nat}_{t} 
+ \beta_{s} \, \widehat{\Delta \log GDPpc}^{state}_{t} 
+ \varepsilon_{t}
$$


$$
\widehat{\Delta \log GDPpc}^{state}_{t} 
= \Delta \log GDPpc^{state}_{t} 
- \hat{\gamma}\, \Delta \log GDPpc^{nat}_{t}
$$
 

Where each GDP term represents the private industry GDP at the CZ, state, or national level, denoted by superscript. Effectively, we estimate the commuting zone level growth rate controlling for state and national trends. We then classify commuting zones by the value of $\alpha$ which represents their deviation from state- and national-level GDP growth rates. We estimate this trend deviation in both gross and per capita values of private industry GDP. Figure X demonstrates the considerable variability in GDP-level growth rates across commuting zones in the US between 2001-2021. Visualising the per capita growth rate deviations by state and region demonstrates heterogeneity in this variability across states and regions. For example, Texas, Montana, Illinois, and Colorado have outstanding positive outliers in the distribution \textcolor{red}{(check which CZ these are: likely Dallas, Chicago, Denver. Montana's outlier is potentially an oil-rich area (indeed the map confirms this))}. Whereas, South Dakota, Nebraska, Montana, Louisiana, and Kentucky contain some of the outstanding declining areas \textcolor{red}{(SD, Louisiana, and Kentucky make intuitive sense which is great! Just confirm which these commuting zones are. Might be useful to highlight some examples in the graph itself.)}


```{r, echo = FALSE, fig.height = 10, fig.width = 10, warning = FALSE, cache = TRUE}


## ---------------------------------------------------------
## 1. Orthogonalise state growth relative to national growth
## ---------------------------------------------------------
growth_rates_orthog <- growth_rates %>%
  group_by(state) %>%
  group_modify(~{
    # state-total residual
    m1 <- lm(diff_log_real_gdp_priv_ind_state ~ diff_log_real_gdp_priv_ind_natl,
             data = .x, na.action = na.exclude)
    .x$state_resid <- residuals(m1)

    # state-per-capita residual
    m2 <- lm(diff_log_real_gdp_priv_ind_pc_state ~ diff_log_real_gdp_priv_ind_pc_natl,
             data = .x, na.action = na.exclude)
    .x$state_resid_pc <- residuals(m2)

    .x
  }) %>%
  ungroup()

## ---------------------------------------------------------
## 2. Regression forms
## ---------------------------------------------------------
trend_forms <- list(
  trend    = diff_log_real_gdp_priv_ind    ~ state_resid    + diff_log_real_gdp_priv_ind_natl,
  trend_pc = diff_log_real_gdp_priv_ind_pc ~ state_resid_pc + diff_log_real_gdp_priv_ind_pc_natl
)

## ---------------------------------------------------------
## 3. Helper to extract coefficients safely
## ---------------------------------------------------------
extract_coefs <- function(formula_obj, data){
  fit <- lm(formula_obj, data = data)
  cf  <- coef(fit)

  tibble(
    intercept = unname(cf["(Intercept)"]),
    beta_nat  = unname(cf[grepl("natl", names(cf))]),
    beta_state= unname(cf[grepl("state_resid", names(cf))])
  )
}

## ---------------------------------------------------------
## 4. Run regressions by commuting zone
## ---------------------------------------------------------
cz_trends <- growth_rates_orthog %>%
  group_by(unit) %>%
  group_modify(~ extract_coefs(trend_forms$trend, .x)) %>%
  ungroup() %>%
  rename(trend = intercept)

cz_trends_pc <- growth_rates_orthog %>%
  group_by(unit) %>%
  group_modify(~ extract_coefs(trend_forms$trend_pc, .x)) %>%
  ungroup() %>%
  rename(trend_pc = intercept,
         beta_nat_pc = beta_nat,
         beta_state_pc = beta_state)

# join them
cz_trends <- cz_trends %>% left_join(cz_trends_pc, by = "unit")

## ---------------------------------------------------------
## 4. Percentiles for classification
## ---------------------------------------------------------
percentiles <- cz_trends %>%
  summarize(
    p25trend     = quantile(trend, 0.25, na.rm = TRUE),
    p75trend     = quantile(trend, 0.75, na.rm = TRUE),
    p25trend_pc  = quantile(trend_pc, 0.25, na.rm = TRUE),
    p75trend_pc  = quantile(trend_pc, 0.75, na.rm = TRUE)
  )

cz_trends <- cz_trends %>%
  mutate(declining = trend < 0,
         declining_extreme = trend < percentiles$p25trend,
         growing_extreme   = trend > percentiles$p75trend,
         declining_pc = trend_pc < 0,
         declining_pc_extreme = trend_pc < percentiles$p25trend_pc,
         growing_pc_extreme   = trend_pc > percentiles$p75trend_pc)

## ---------------------------------------------------------
## 5. Histograms of intercepts
## ---------------------------------------------------------
my_color <- viridis_pal(option = "rocket")(6)

trend_hist <- cz_trends %>%
  ggplot() +
  geom_histogram(aes(x = trend), bins = 75, fill = my_color[2], alpha = 0.7) +
  geom_vline(aes(xintercept = percentiles$p25trend), linetype = "dashed") +
  geom_vline(aes(xintercept = percentiles$p75trend), linetype = "dashed") +
  labs(x = "CZ Intercept (trend)", title = "Distribution of CZ GDP Trend Coefficients", y = "Frequency") +
  theme_minimal()

trend_pc_hist <- cz_trends %>%
  ggplot() +
  geom_histogram(aes(x = trend_pc), bins = 75, fill = my_color[4], alpha = 0.7) +
  geom_vline(aes(xintercept = percentiles$p25trend_pc), linetype = "dashed") +
  geom_vline(aes(xintercept = percentiles$p75trend_pc), linetype = "dashed") +
  labs(x = "CZ Intercept (trend_pc)", title = "Distribution of CZ GDPpc Trend Coefficients", y = "Frequency") +
  theme_minimal()

trend_hist / trend_pc_hist

## ---------------------------------------------------------
## 6. Plot coefficients by state/region (like your version)
## ---------------------------------------------------------
cz_trends_plot <- cz_trends %>%
  left_join(distinct(select(mines_cz, unit, state)), by = "unit")

cz_trends_plot$state = sapply(cz_trends_plot$state, get_state)
cz_trends_plot$region = sapply(cz_trends_plot$state, get_region)

n_states <- dplyr::n_distinct(cz_trends_plot$state)
tmp <- colorRampPalette(brewer.pal(9, "Oranges"))(n_states + 10)
myOranges <- tmp[-c(1:10)]
myOranges <- myOranges[1:n_states]

cz_states <- cz_trends_plot %>%
  group_by(state) %>%
  arrange(state, trend_pc) %>%
  mutate(midpt = ifelse(row_number() == round((max(row_number()) - min(row_number()))/2),1, NA)) %>%
  ungroup() %>%
  mutate(midpt = row_number() * midpt) %>%
  mutate(unit = factor(unit, levels = unit)) %>%
  ggplot(aes(unit, trend_pc)) +
  geom_segment(aes(x=unit ,xend=unit, y=0, yend=trend_pc, color = state)) +
  geom_point(color="darkblue", size=0.5) +
  coord_flip() +
    geom_label(aes(midpt, 0.09,
                   label = state),
               fill = NA,
               #family = "Special Elite",
               fontface = "bold",
               label.padding = unit(.2, "lines"),
               label.r = unit(.25, "lines"),
               label.size = .05,
             size = 3) +
  labs(x = "Commuting Zones by State", y = "GDPpc Trend") +
  theme(axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        legend.position = "none") +
  scale_color_manual(values = myOranges)



cz_trend <- cz_trends_plot %>%
  arrange(trend_pc) %>%
  mutate(unit = factor(unit, levels = unit)) %>%
  ggplot(aes(unit, trend_pc)) +
  geom_segment(aes(x=unit ,xend=unit, y=0, yend=trend_pc, color = unit)) +
  geom_point(color="darkblue", size=0.5) +
  coord_flip() +
  labs(x = "Commuting Zones", y = "GDPpc Trend") +
  theme(axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        legend.position = "none") +
  scale_color_viridis(discrete = TRUE, option = "rocket", direction = -1)

add_labels(cz_trend, cz_trends_plot, "trend_pc", 5) -> cz_trend

cz_regions <- cz_trends_plot %>%
  group_by(region) %>%
  arrange(region, trend_pc) %>%
  mutate(midpt = ifelse(row_number() == round((max(row_number()) - min(row_number()))/2),1, NA)) %>%
  ungroup %>%
  mutate(midpt = row_number() * midpt) %>%
  mutate(unit = factor(unit, levels = unit)) %>%
  ggplot(aes(unit, trend_pc)) +
  geom_segment(aes(x=unit ,xend=unit, y=0, yend=trend_pc, color = region)) +
  geom_point(color="darkblue", size=0.5) +
  coord_flip() +
  labs(x = "Commuting Zones by Region", y = "GDPpc Trend") +
    geom_label(aes(midpt, 0.09,
                   label = region),
               fill = NA,
               #family = "Special Elite",
               fontface = "bold",
               label.padding = unit(.2, "lines"),
               label.r = unit(.25, "lines"),
               label.size = .05,
             size = 3) +
  theme(axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        legend.position = "none") +
  scale_color_brewer(palette = "Reds")

cz_regions + cz_states +  cz_trend + 
  plot_annotation(
    title = "Commuting Zone GDP pc Growth Rates",
    subtitle = "Intercepts from regressions controlling for national growth and state-specific residual growth"
  )

```

```{r, echo = FALSE, fig.height = 10, fig.width = 10, warning = FALSE, cache = TRUE}


## ---------------------------------------------------------
## Scatter plot of betas
## ---------------------------------------------------------
scatter_betas <- cz_trends_plot %>%
  ggplot(aes(x = beta_nat, y = beta_state, color = region)) +
  geom_hline(yintercept = 0, linetype = "dashed", alpha = 0.5) +
  geom_vline(xintercept = 0, linetype = "dashed", alpha = 0.5) +
  geom_point(alpha = 0.7) +
  labs(
    x = expression(beta["nat"]~"(loading on national growth)"),
    y = expression(beta["state"]~"(loading on state-specific growth)"),
    title = "Commuting Zone GDPpc Growth Loadings",
    subtitle = "Coefficients from regressions on national growth and state-specific residuals",
    color = "Region"
  ) +
  theme_minimal() +
  scale_color_brewer(palette = "Set2")

## ---------------------------------------------------------
## 9. Histograms of betas
## ---------------------------------------------------------
hist_nat <- cz_trends_plot %>%
  ggplot(aes(x = beta_nat)) +
  geom_histogram(fill = "steelblue", alpha = 0.7, bins = 50) +
  labs(x = expression(beta["nat"]), y = "Count",
       title = "Distribution of β_nat") +
  theme_minimal()

hist_state <- cz_trends_plot %>%
  ggplot(aes(x = beta_state)) +
  geom_histogram(fill = "tomato", alpha = 0.7, bins = 50) +
  labs(x = expression(beta["state"]), y = "Count",
       title = "Distribution of β_state") +
  theme_minimal()

scatter_betas / (hist_nat + hist_state)

```

 
We perform the same trend deviation calculation for wages where each wage variable represents the commuting zone, state, and national level growth rate in the weekly average wage as reported in QCEW. \textcolor{red}{We only have national level wage growth data..I have not yet implemented state-level wage growth data. So for now we only use the CZ trend, netting out the national trend.}

<!-- $$\Delta (log) Wage^{CZ}_{t} = \alpha + \Delta (log) Wage^{state}_{t} + \Delta (log) Wage^{national}_{t} + \epsilon_t$$ -->

<!-- New implementation:  -->
<!-- % --- Original specification --- -->
<!-- $$ -->
<!-- \Delta \log Wage^{CZ}_{t}  -->
<!-- = \alpha  -->
<!-- + \beta_{s} \, \Delta \log Wage^{state}_{t}  -->
<!-- + \beta_{n} \, \Delta \log Wage^{nat}_{t}  -->
<!-- + \varepsilon_{t} -->
<!-- $$ -->

$$
\Delta \log Wage^{CZ}_{t} 
= \alpha_{cz} 
 + \beta_{n} \, \Delta \log Wage^{nat}_{t}
+ \varepsilon_{t}
$$

```{r, echo = FALSE}
# + \beta_{s} \, \widehat{\Delta \log Wage}^{state}_{t} 

# $$
# \widehat{\Delta \log Wage}^{state}_{t} 
# = \Delta \log Wage^{state}_{t} 
# - \hat{\gamma}\, \Delta \log Wage^{nat}_{t}
# $$
```



In Figure X, we see that there is similar variability though the patterns do not consistently indicate the same high- and low-performing outliers across states indicating that GDP and wage growth are not consistently correlated across regions. We demonstrate this fact in Figure X (scatterplot with pink regression linear fit) where, although there is a positive correlation between commuting zone GDP and wage trend deviations, the wage trend deviation represents a nearly inelastic relationship to GDP growth. \textcolor{red}{Consider a more informative plot of this relationship...correlogram?}


```{r, echo = FALSE, fig.height = 10, fig.width = 10, warning = FALSE, cache = TRUE}

# 0. Prepare CZ-level wage growth + national series (you already did this earlier)
wage_growth_rates <- mines_cz %>%
  select(year, unit, state, gr_weighted_annual_avg_wkly_wage) %>%
  left_join(select(natl_rates, year, gr_natl_annual_avg_wkly_wage_10),
            by = "year")


# INCLUDE ONCE STATE-LEVEL DATA IS AVAILABLE
# # 1. Compute a state-level wage growth series (simple mean across CZs by state-year).
# #    If you have a better weighting (e.g., employment or population), replace mean() with weighted.mean(..., w = <weights>).
# state_rates <- wage_growth_rates %>%
#   group_by(state, year) %>%
#   summarise(gr_state = mean(gr_weighted_annual_avg_wkly_wage, na.rm = TRUE), .groups = "drop")
# 
# # 2. Join state-level series back to CZ-level observations so each CZ-year has gr_state & gr_natl
# wage_growth_rates <- wage_growth_rates %>%
#   left_join(state_rates, by = c("state", "year"))

# 3. Orthogonalise the state series relative to national series:
#    For each state, regress gr_state ~ gr_natl and keep residual = state_resid

growth_rates_wage_orthog <- wage_growth_rates %>%
  group_by(state) %>%
  group_modify(~{
    # fit state-level series on national series (na.action = na.exclude to preserve NAs)
    fm <- try(lm(gr_state ~ gr_natl_annual_avg_wkly_wage_10, data = .x, na.action = na.exclude),
              silent = TRUE)
    if(inherits(fm, "try-error")){
      .x$state_resid <- NA_real_
    } else {
      .x$state_resid <- residuals(fm)
    }
    .x
  }) %>%
  ungroup()


wage_trend_formula <- gr_weighted_annual_avg_wkly_wage ~ gr_natl_annual_avg_wkly_wage_10

# INCLUDE ONCE STATE-LEVEL DATA IS AVAILABLE
# 4. Regression formula (orthogonalised): CZ growth ~ state_resid + national growth
#wage_trend_formula <- gr_weighted_annual_avg_wkly_wage ~ state_resid + gr_natl_annual_avg_wkly_wage_10

# 5. Helper to extract coefficients safely (same style as your GDP template)
extract_coefs_wage <- function(formula_obj, data){
  fit <- lm(formula_obj, data = data)
  cf  <- coef(fit)
  tibble(
    intercept = unname(cf["(Intercept)"]),
    beta_nat  = unname(cf[grepl("gr_natl", names(cf))])#, 
    # INCLUDE ONCE STATE-LEVEL DATA IS AVAILABLE

    #beta_state= unname(cf[grepl("state_resid", names(cf))])
  )
}

# 6. Run the per-CZ regressions and extract intercept (wage_trend)
cz_wage_trends <- growth_rates_wage_orthog %>%
  group_by(unit) %>%
  group_modify(~ extract_coefs_wage(wage_trend_formula, .x)) %>%
  ungroup() %>%   # .id returns the unit label from group_map
  rename(wage_trend = intercept)

# 7. Percentiles and classification flags (same as your original)
percentiles <- cz_wage_trends %>%
  summarize(
    p25trend = quantile(wage_trend, 0.25, na.rm = TRUE),
    p75trend = quantile(wage_trend, 0.75, na.rm = TRUE)
  )

cz_wage_trends <- cz_wage_trends %>%
  mutate(declining = wage_trend < 0,
         declining_extreme = wage_trend < percentiles$p25trend,
         growing_extreme = wage_trend > percentiles$p75trend)

# 8. Join back CZ metadata (state) and region mapping like you do downstream
cz_wage_trends_plot <- cz_wage_trends %>%
  left_join(distinct(select(mines_cz, unit, state)), by = "unit")

# convert/clean state and region columns as in your working code
cz_wage_trends_plot$state  <- sapply(cz_wage_trends_plot$state, get_state)
cz_wage_trends_plot$region <- sapply(cz_wage_trends_plot$state, get_region)

my_color <- viridis_pal(option = "mako")(5)
trend_hist <- cz_wage_trends %>%
  ggplot() +
  geom_histogram(aes(x = wage_trend), bins = 75, fill = my_color[3], alpha = 0.7) +
  geom_vline(aes(xintercept = percentiles$p25trend), linetype = "dashed") +
  geom_vline(aes(xintercept = percentiles$p75trend), linetype = "dashed") +
  labs(x = "CZ Wage Trend Coefficient", title = "Distribution of CZ Wage Trend Coefficients", y = "Frequency") +
  annotate("text", x = percentiles$p25trend, y = 40, label = "25th Percentile", color = my_color[3], angle = 90, vjust = -0.5) +
  annotate("text", x = percentiles$p75trend, y = 40, label = "75th Percentile", color = my_color[3], angle = 90, vjust = 1.5) +
  theme_minimal()

trend_hist

theme_update(plot.background = element_rect(fill = NA),
             panel.background = element_rect(fill = NA, color = NA),
             panel.border = element_rect(fill = NA, color = NA),
             panel.grid.major.x = element_blank(),
             panel.grid.minor = element_blank(),
             axis.text.x = element_blank(),
             axis.text.y = element_text(size = 10),
             axis.ticks = element_blank(),
             axis.title.y = element_text(size = 13,
                                         margin = margin(r = 10)),
             legend.title = element_text(size = 9),
             plot.margin = margin(10, 25, 10, 25))

n_states <- dplyr::n_distinct(cz_wage_trends_plot$state)

# generate more colors than you need, then drop the first k lightest
tmp <- colorRampPalette(brewer.pal(9, "Blues"))(n_states + 10)  # oversample
myBlues <- tmp[-c(1:10)]   # drop the 2 lightest shades
myBlues <- myBlues[1:n_states] 
cz_wage_states <- cz_wage_trends_plot %>%
  group_by(state) %>%
  arrange(state,wage_trend) %>%
  mutate(midpt = ifelse(row_number() == round((max(row_number()) - min(row_number()))/2),1, NA)) %>%
  ungroup %>%
  mutate(midpt = row_number() * midpt) %>%
  mutate(unit = factor(unit, levels = unit)) %>%
  ggplot(aes(unit, wage_trend)) +
  geom_segment(aes(x=unit ,xend=unit, y=0, yend=wage_trend, color = state)) +
  geom_point( color="darkblue", size=0.5) +
  geom_label(aes(midpt, 0.09,
                   label = state),
               fill = NA,
               #family = "Special Elite",
               fontface = "bold",
               label.padding = unit(.2, "lines"),
               label.r = unit(.25, "lines"),
               label.size = .05,
             size = 3) +
  coord_flip() +
  labs(x = "Commuting Zones by State", y = "Wage Trend Coefficient") +
  theme(axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        axis.text.x = element_text(size = 14),
        legend.position = "none") +
    scale_color_manual(values = myBlues)

cz_wage_trend <-cz_wage_trends_plot %>%
  arrange(wage_trend) %>%
  mutate(unit = factor(unit, levels = unit)) %>%
  ggplot(aes(unit, wage_trend)) +
  geom_segment(aes(x=unit ,xend=unit, y=0, yend=wage_trend, color = unit)) +
  geom_point( color="darkblue", size=0.05) +
  coord_flip() +
  labs(x = "Commuting Zones", y = "Wage Trend Coefficient") +
    theme(axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        axis.text.x = element_text(size = 14),
        legend.position = "none") +
    scale_color_viridis(discrete= TRUE, option = "mako", direction = -1)


add_labels(cz_wage_trend, cz_wage_trends_plot, "wage_trend", 5) -> cz_wage_trend

cz_wage_regions <- cz_wage_trends_plot %>%
  group_by(region) %>%
  arrange(region, wage_trend) %>%
  mutate(midpt = ifelse(row_number() == round((max(row_number()) - min(row_number()))/2),1, NA)) %>%
  ungroup %>%
  mutate(midpt = row_number() * midpt) %>%
  mutate(unit = factor(unit, levels = unit)) %>%
  ggplot(aes(unit, wage_trend)) +
  geom_segment(aes(x=unit ,xend=unit, y=0, yend=wage_trend, color = region)) +
  geom_point( color="darkblue", size=0.5) +
  geom_label(aes(midpt, 0.05,
                   label = region),
               fill = NA,
               #family = "Special Elite",
               fontface = "bold",
               label.padding = unit(.2, "lines"),
               label.size = .09,
             size = 4) +
  coord_flip() +
  labs(x = "Commuting Zones by Region", y = "Wage Trend Coefficient") +
  theme(axis.text.y=element_blank(),
        #axis.ticks.y=element_blank(),
        axis.text.x = element_text(size = 14),
        legend.position = "none") +
 scale_color_brewer(palette = "Greens")


cz_wage_regions + cz_wage_states + cz_wage_trend + plot_annotation(title = "Commuting Zone Wage Growth Rate Controlling for National and State Level Trends", subtitle = "Calculated as mean of annual growth rate per commuting zone controlling for national and state level wage growth.",
                                                                   theme = theme(
      plot.title = element_text(size = 18),
      plot.subtitle = element_text(size = 16)
    ))


cz_trends %>% left_join(cz_wage_trends, by = "unit") %>% ggplot(., aes(x = trend_pc, y = wage_trend)) +
     geom_point(alpha = 0.2) +
     geom_smooth(method = "lm", se = TRUE, color = "maroon", fill = "maroon") +
     labs(
         x = "Real GDP pc Trend",
         y = "Wage Trend",
         title = "Relationship Between GDPpc and Wage Trends (per CZ)"
     ) +
     theme_minimal() +
  theme(axis.text.x = element_text(size = 14),
        axis.text.y = element_text(size = 14),
        title = element_text(size = 18))

map_data <- mines_cz %>%
  select(year, unit, log_weighted_annual_avg_wkly_wage, gr_weighted_annual_avg_wkly_wage) %>%
  group_by(unit) %>%
  mutate(gr_weighted_annual_avg_wkly_wage = mean(gr_weighted_annual_avg_wkly_wage, na.rm = TRUE)) %>%
  filter(year == 2021) %>%
  select(unit, year, log_weighted_annual_avg_wkly_wage, gr_weighted_annual_avg_wkly_wage) %>%
  rename(cz_id = unit)

map_gr_wage <- gen_czs_years(map_data) %>%
  left_join(., map_data, by = "cz_id") %>%
  plot_usmap(data = ., values = "gr_weighted_annual_avg_wkly_wage", regions = "counties", col = "gray90", linewidth = 0.01, exclude = c("AK", "HI")) +
  scale_fill_gradient2(midpoint = 0.03, na.value = "palegoldenrod", low = "mediumvioletred", high = "midnightblue") +
  #scale_fill_distiller(colours=c(bl,"white", re), name = "", direction = 1, na.value = "gray90", limits = c(-1, 1)) +
  theme(panel.background = element_rect(color = "white", fill = "white"),
        plot.title = element_text(face = "bold")) +
  labs(title = "Growth Rate of Weekly Wage in Relation to Median (CZ)",
       fill = "Growth Rate in Weekly Wage (2001-2021)")

map_lev_wage <- gen_czs_years(map_data) %>%
  left_join(., map_data, by = "cz_id") %>%
  plot_usmap(data = ., values = "log_weighted_annual_avg_wkly_wage", regions = "counties", col = "gray90", linewidth = 0.01, exclude = c("AK", "HI")) +
  scale_fill_gradient2(midpoint = 6.8, na.value = "palegoldenrod", low = "mediumvioletred", high = "midnightblue" )+
  #scale_fill_distiller(colours=c(bl,"white", re), name = "", direction = 1, na.value = "gray90", limits = c(-1, 1)) +
  theme(panel.background = element_rect(color = "white", fill = "white"),
        plot.title = element_text(face = "bold")) +
  labs(title = "Weekly Wage Level (2021) in Relation to Median (CZ)",
       fill = "(log) Annual Average Weekly Wage")


map_gr_wage
map_lev_wage

```


```{r, echo = FALSE, fig.height = 10, fig.width = 10, warning = FALSE, cache = TRUE}

# # Find high and low outliers
# outliers <- cz_wage_trends_plot %>%
#   left_join(., cz_labels, by = "unit") %>%
#   arrange(wage_trend) %>%
#   slice(c(1:5, (n()-4):n()))
# 
# plot_df <- cz_wage_trends_plot %>%
#   left_join(cz_labels, by = "unit") %>%
#   arrange(wage_trend) %>%
#   mutate(unit = fct_inorder(unit))   # lock order to the arrange() result
# 
# # Outliers from the same ordered df
# outliers <- bind_rows(slice_head(plot_df, n = 5), slice_tail(plot_df, n= 5))
# 


temp <-  cz_wage_trends_plot %>% 
  arrange(wage_trend) %>%
  mutate(unit = factor(unit, levels = unit)) %>%
  ggplot(aes(x = unit, y = wage_trend)) +
  geom_segment(aes(xend = unit, y = 0, yend = wage_trend, color = unit)) +
  geom_point(color = "darkblue", size = 0.6) +
  # geom_text_repel(data = add_labels(cz_wage_trends_plot, "wage_trend", 5), aes(label = msa), direction = "y",
  #                 nudge_y = 0.02, size = 3, segment.color = "grey60",
  #                 max.overlaps = Inf) +
  coord_flip() +
  scale_x_discrete(limits = levels(cz_wage_trends_plot$unit)) +  # <- enforces the order
  scale_color_viridis(discrete = TRUE, option = "mako", direction = -1) +
  labs(x = "Commuting Zones", y = "Wage Trend Coefficient") +
  theme(axis.text.y = element_blank(), axis.ticks.y = element_blank(),
        axis.text.x = element_text(size = 14), legend.position = "none")


add_labels(temp, cz_wage_trends_plot, "wage_trend", 5)


```


```{r, echo = FALSE, fig.height = 10, fig.width = 10, warning = FALSE, cache = TRUE}

# -Creating a safe plotting function until state wage growth rates are incorporated
safe_plot <- function(expr, fail_label = "Plot failed", text_size = 4) {
  tryCatch(
    {
      p <- eval(substitute(expr), envir = parent.frame())
      if (!inherits(p, "ggplot")) stop("Expression did not return a ggplot object")
      # Force build so errors in scales/geoms are triggered here (and caught)
      ggplot_build(p)
      p
    },
    error = function(e) {
      ggplot() +
        geom_rect(aes(xmin = 0, xmax = 1, ymin = 0, ymax = 1),
                  fill = "white", color = "grey80") +
        annotate("text", x = 0.5, y = 0.55,
                 label = fail_label,
                 size = text_size, fontface = "bold", hjust = 0.5) +
      
        theme_void()
    }
  )
}

# Example: safe scatter (will be caught if cz_wage_trends_plot or scale mismatches fail)
scatter_betas <- safe_plot({
  cz_wage_trends_plot %>%
    ggplot(aes(x = beta_nat, y = beta_state, color = region)) +
    geom_hline(yintercept = 0, linetype = "dashed", alpha = 0.5) +
    geom_vline(xintercept = 0, linetype = "dashed", alpha = 0.5) +
    geom_point(alpha = 0.7) +
    labs(
      x = expression(beta["nat"]~"(loading on national growth)"),
      y = expression(beta["state"]~"(loading on state-specific growth)"),
      title = "Commuting Zone GDPpc Growth Loadings",
      subtitle = "Coefficients from regressions on national growth and state-specific residuals",
      color = "Region"
    ) +
    theme_minimal() +
    scale_color_brewer(palette = "Set2")
}, fail_label = "Expected error: \nMissing state wage growth rates so histogram fails.")
## ---------------------------------------------------------
## 9. Histograms of betas
## ---------------------------------------------------------
hist_nat <- safe_plot({cz_wage_trends_plot %>%
  ggplot(aes(x = beta_nat)) +
  geom_histogram(fill = "steelblue", alpha = 0.7, bins = 50) +
  labs(x = expression(beta["nat"]), y = "Count",
       title = "Distribution of β_nat") +
  theme_minimal()}, fail_label = "hist_nat failed")

hist_state <- safe_plot({cz_wage_trends_plot %>%
  ggplot(aes(x = beta_state)) +
  geom_histogram(fill = "tomato", alpha = 0.7, bins = 50) +
  labs(x = expression(beta["state"]), y = "Count",
       title = "Distribution of β_state") +
  theme_minimal()}, fail_label = "Expected error: \nMissing state wage growth rates so histogram fails.")


scatter_betas / (hist_nat + hist_state)

```

```{r, echo = FALSE}

# 1) compute unit-level correlations (if you already have this, skip this block)
unit_corr <- mines_cz %>%
  group_by(unit) %>%
  summarise(
    corr_gdp_wage = cor(log_real_gdp_priv_ind_pc,
                        gr_weighted_annual_avg_wkly_wage,
                        use = "pairwise.complete.obs"),
    .groups = "drop"
  )

# join state/region and keep one row per unit
unit_corr_plot <- unit_corr %>%
  left_join(
    mines_cz %>% select(unit, state) %>% distinct(),
    by = "unit"
  )

# 2) order units by state then by correlation (lowest -> highest within state)
unit_corr_plot <- unit_corr_plot %>%
  arrange(state, corr_gdp_wage) %>%
  mutate(unit_ord = factor(unit, levels = unique(unit)))    # preserve order

# 3) compute midpoint (y position) for each state block so we can label it
state_positions <- unit_corr_plot %>%
  group_by(state) %>%
  summarise(
    start = min(as.integer(unit_ord)),
    end   = max(as.integer(unit_ord)),
    mid   = (start + end) / 2,
    .groups = "drop"
  )

# 4) plot: single column of tiles, states grouped (x is constant=1)
p_single_column <- ggplot(unit_corr_plot, aes(x = 1, y = unit_ord, fill = corr_gdp_wage)) +
  geom_tile(color = "white", height = 0.95) +                 # tile per unit
  scale_fill_viridis_c(option = "mako", limits = c(-1, 1), na.value = "grey90") +
  # state separators: horizontal lines between blocks (at integer + 0.5 positions)
  geom_hline(
    data = state_positions %>% mutate(bound = end + 0.5),
    aes(yintercept = bound),
    color = "grey70", size = 0.3
  ) +
  # state labels positioned to the left of the tiles
  # geom_text(
  #   data = state_positions,
  #   aes(x = 0.7, y = mid, label = state),
  #   hjust = 1, fontface = "bold", size = 3
  # ) +
  coord_fixed(ratio = 0.045, clip = "off") +                 # shrink tile height; allow labels outside
  scale_x_continuous(limits = c(0.4, 1.1), expand = c(0,0)) +
  labs(
    title = "Per-unit correlation: GDP per capita vs wages",
    subtitle = "Tiles grouped by state; darker = stronger positive correlation",
    x = NULL, y = NULL,
    fill = "Correlation"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    panel.grid = element_blank(),
    legend.position = "right",
    plot.margin = margin(5, 40, 5, 80)   # give space on left for state labels
  )

# show plot
p_single_column


unit_corr_plot$state = sapply(unit_corr_plot$state, get_state)
unit_corr_plot$region = sapply(unit_corr_plot$state, get_region)


ggplot(unit_corr %>% arrange(corr_gdp_wage) %>%
         mutate(unit = factor(unit, levels = unit)),
       aes(x = unit, y = corr_gdp_wage, fill = corr_gdp_wage)) +
  geom_col(show.legend = FALSE) +
  scale_fill_viridis_c(option = "cividis", limits = c(-1, 1)) +
  coord_flip() +
  labs(
    title = "Commuting Zone Correlation between GDPpc and Wage Growth",
    x = "Commuting Zone (Unit)",
    y = "Correlation Coefficient"
  ) +
  theme_minimal(base_size = 13)

```




```{r, echo = FALSE, cache = TRUE}

mines_cz_decl <- cz_trends %>%
  select(unit, contains("trend"), contains("growing"), contains("declining")) %>%
  left_join(mines_cz, ., by = "unit")

mines_cz_wage_decl <- cz_wage_trends %>%
  select(unit, contains('trend'), contains('growing'), contains('declining')) %>%
  left_join(mines_cz, ., by = "unit")

# print("Declining")
# run_model(selected_iv_models, filter(mines_cz_decl, declining_pc)) %>% etable(headers = c("INSTR: Total Active Prod", "INSTR: (l1) Total Active Prod","INSTR: Total Active Prod", "INSTR: (l1) Total Active Prod"))
# print("Growing")
# run_model(selected_iv_models, filter(mines_cz_decl, !declining_pc)) %>% etable(headers = c("INSTR: Total Active Prod", "INSTR: (l1) Total Active Prod","INSTR: Total Active Prod", "INSTR: (l1) Total Active Prod"))
#
# print("Extreme Decline (25th percentile of growth rates)")
# run_model(selected_iv_models, filter(mines_cz_decl, declining_pc_extreme)) %>% etable(headers = c("INSTR: Total Active Prod", "INSTR: (l1) Total Active Prod","INSTR: Total Active Prod", "INSTR: (l1) Total Active Prod"))
#
# print("Extreme Growth (75th percentile of growth rates)")
# run_model(selected_iv_models, filter(mines_cz_decl, growing_pc_extreme)) %>% etable(headers = c("INSTR: Total Active Prod", "INSTR: (l1) Total Active Prod","INSTR: Total Active Prod", "INSTR: (l1) Total Active Prod"), title = "Hello")

```

### Baseline Models

```{r, echo = FALSE, results = 'asis', cache = TRUE}

form <- "log_real_Elem_Educ_Total_Exp_pp ~ sw(log_real_gdp_priv_ind_pc + l1_log_real_gdp_priv_ind_pc + l2_log_real_gdp_priv_ind_pc, log_weighted_annual_avg_wkly_wage + l1_log_weighted_annual_avg_wkly_wage + l2_log_weighted_annual_avg_wkly_wage, log_hpi + l1_log_hpi + l2_log_hpi + l3_log_hpi + l4_log_hpi) + log_real_Total_IG_Revenue_pp | unit + year"

# gr_form <- "diff_log_real_Elem_Educ_Total_Exp_pp ~ sw(diff_log_real_gdp_priv_ind_pc + l1_diff_log_real_gdp_priv_ind_pc + l2_diff_log_real_gdp_priv_ind_pc, gr_weighted_annual_avg_wkly_wage + l1_gr_weighted_annual_avg_wkly_wage + l2_gr_weighted_annual_avg_wkly_wage, gr_hpi + l1_gr_hpi + l2_gr_hpi + l3_gr_hpi + l4_gr_hpi) + diff_log_real_Total_IG_Revenue_pp | unit + year"

prop_vals_form <- "log_hpi ~ l(log_weighted_annual_avg_wkly_wage, 0:7) | unit + year"
#gr_prop_vals_form <- "gr_hpi ~ l(gr_weighted_annual_avg_wkly_wage, 0:7) | unit + year"

for(k in list(form)){ # gr_form)){ #prop_vals_form, gr_prop_vals_form)){
  mods_list <- list()
  mods_list["Declining"] <- run_model(k, filter(mines_cz_decl, declining_pc))
  n_forms <- mods_list[['Declining']] %>% length
  mods_list["Hyper-Declining"] <- run_model(k, filter(mines_cz_decl, declining_pc_extreme))
  mods_list["Growing"] <- run_model(k, filter(mines_cz_decl, !declining_pc))
  mods_list["Hyper-Growing"] <- run_model(k, filter(mines_cz_decl, growing_pc_extreme))
  etable(mods_list, tex = latex_tables, adjustbox = TRUE, headers = rep(names(mods_list), each = n_forms), title = "Baseline Regression Applied to Declining GDP vs. Growing GDP Regions",  label = "tab:baseline_gdp_subsamples") %>% print(.)
}


for(k in list(form)){ # gr_form)){ #prop_vals_form, gr_prop_vals_form)){
  mods_list <- list()
  mods_list["Declining"] <- run_model(k, filter(mines_cz_wage_decl, declining))
  n_forms <- mods_list[['Declining']] %>% length
  mods_list["Hyper-Declining"] <- run_model(k, filter(mines_cz_wage_decl, declining_extreme))
  mods_list["Growing"] <- run_model(k, filter(mines_cz_wage_decl, !declining))
  mods_list["Hyper-Growing"] <- run_model(k, filter(mines_cz_wage_decl, growing_extreme))
  etable(mods_list, tex = latex_tables, adjustbox = TRUE, headers = rep(names(mods_list), each = n_forms), title = "Baseline Regression Applied to Declining Wage vs. Growing Wage Regions",  label = "tab:baseline_wage_subsamples") %>% print(.)
}

```

```{r, echo = FALSE}

decl <- filter(mines_cz_decl, declining_pc)
grow <- filter(mines_cz_decl, !declining_pc)

decl_extr <- filter(mines_cz_decl, declining_pc_extreme)
grow_extr <- filter(mines_cz_decl, growing_pc_extreme)

dfs <- list("All" = mines_cz_decl, "Declining (GDP)" = decl, "Hyper-Declining (GDP)" = decl_extr, "Growing (GDP)" = grow, "Hyper-Growing (GDP)" = grow_extr)


decl_wage <- filter(mines_cz_wage_decl, declining)
grow_wage <- filter(mines_cz_wage_decl, !declining)

decl_extr_wage <- filter(mines_cz_wage_decl, declining_extreme)
grow_extr_wage <- filter(mines_cz_wage_decl, growing_extreme)

dfs_wage <- list("All" = mines_cz_decl, "Declining (Wage)" = decl_wage, "Hyper-Declining (Wage)" = decl_extr_wage, "Growing (Wage)" = grow_wage, "Hyper-Growing (Wage)" = grow_extr_wage)


```

```{r, echo = FALSE}

mods <- list()
for(df in names(dfs)){
    # IV regression using shift-share instrument
    iv_model <- feols(
   as.formula(paste0("log_real_Elem_Educ_Total_Exp_pp ~ log_real_Total_IG_Revenue_pp + log_real_gdp_priv_ind_pc + log_Enrollment | year + state | log_hpi ~ l(lev_ss_2d)")),
   data = left_join(dfs[[df]], rename(ss_temp, unit = cz_id), by = c("year", "unit")), panel.id = c("unit", "year"), cluster = "unit")
    mods[[df]] <- iv_model

}

mods_wage <- list()
for(df_wage in names(dfs_wage)){
    # IV regression using shift-share instrument
    iv_model <- feols(
   as.formula(paste0("log_real_Elem_Educ_Total_Exp_pp ~ log_real_Total_IG_Revenue_pp + log_real_gdp_priv_ind_pc + log_Enrollment | year + state | log_hpi ~ l(lev_ss_2d)")),
   data = left_join(dfs_wage[[df_wage]], rename(ss_temp, unit = cz_id), by = c("year", "unit")), panel.id = c("unit", "year"), cluster = "unit")
    mods_wage[[df_wage]] <- iv_model
}

```

### IV Models

The following implements an employment based Bartik instrument for
various industries available from the Quarterly Census of Employment and
Wages.

#### Wage SS Instrument

Result: The baseline estimate of an l-1 effect on public education expenditure is entirely dominated by declining regions. Interestingly, sample division by GDP growth rates isolates the wage-based SS instrument effect almost entirely indicating that wage changes in declining regions matter most. Potentially an indicator of property price spirals.

Result: Whereas, in the case of the wage-based instrument when applied to growing and declining wage regions, the effect is more widespread across regions. 

```{r, echo = FALSE, results = 'asis'}

etable(mods, tex = latex_tables, adjustbox = TRUE, headers = names(mods), fitstat = iv_fitstats, title = "Wage-based Shift-Share Instrument (l1) Applied to Declining GDP vs. Growing GDP Regions", label = "tab:wage_ss_gdp_subsamples") 
etable(mods_wage, tex = latex_tables, adjustbox = TRUE, headers = names(mods_wage), fitstat = iv_fitstats, title = "Wage-based Shift-Share Instrument (l1) Applied to Declining Wage vs. Growing Wage Regions", label = "tab:wage_ss_wage_subsamples")

```

#### GDP SS Instrument

```{r, echo = FALSE}

mods <- list()
for(df in names(dfs)){
    # IV regression using shift-share instrument
    iv_model <- feols(
   as.formula(paste0("log_real_Elem_Educ_Total_Exp_pp ~ log_real_Total_IG_Revenue_pp + log_real_gdp_priv_ind_pc + log_Enrollment | year + state | log_hpi ~ l(lev_gdp_ss_2d)")),
   data = left_join(dfs[[df]], rename(ss_temp, unit = cz_id), by = c("year", "unit")), panel.id = c("unit", "year"), cluster = "unit")
    mods[[df]] <- iv_model

}

mods_wage <- list()
for(df_wage in names(dfs_wage)){
    # IV regression using shift-share instrument
    iv_model <- feols(
   as.formula(paste0("log_real_Elem_Educ_Total_Exp_pp ~ log_real_Total_IG_Revenue_pp + log_real_gdp_priv_ind_pc + log_Enrollment | year + state | log_hpi ~ l(lev_gdp_ss_2d)")),
   data = left_join(dfs_wage[[df_wage]], rename(ss_temp, unit = cz_id), by = c("year", "unit")), panel.id = c("unit", "year"), cluster = "unit")
    mods_wage[[df_wage]] <- iv_model
}

```

Result: In the case of the GDP-based instrument, the sub-sampling procedure indicates that GDP growth has an effect on public education expenditure in all but hyper-growing areas (as defined in both GDP and wage subsampling) indicating that GDP growth translates to changes in public expenditure more directly in all but non-superstar regions. \textcolor{red}{This could indicate a spillover into private education...possible to investigate?}

```{r, echo = FALSE, results='asis'}

etable(mods_wage, tex = latex_tables, headers = names(mods_wage), adjustbox = TRUE, fitstat = iv_fitstats, title = "GDP-based Shift-Share Instrument (l1) Applied to Declining Wage vs. Growing Wage Regions", label = "tab:gdp_ss_wage_subsamples")
etable(mods,   tex = latex_tables, adjustbox = TRUE, headers = names(mods), fitstat = iv_fitstats, title = "GDP-based Shift-Share Instrument (l1) Applied to Declining GDP vs. Growing GDP Regions", label = "tab:gdp_ss_gdp_subsamples")

```
\FloatBarrier


### High-income Outliers

There is a somewhat non-linear
relationship between property taxes and elementary expenditure as
property taxes collected rise as represented in Figure X below. This happens largely as a result of very
high-income commuting zones. Therefore, we exclude any commuting zone
that spends more than 22k per pupil to avoid any distorting effects.
This removes 12 CZs (\~2% of the sample).
\textcolor{red}{This could benefit from
more robust outlier detection.}


To assess whether the main results are driven by a small number of very high-income jurisdictions, I re-estimate the baseline and IV specifications excluding such outliers. The findings are fully consistent with the baseline analysis: house prices remain a strong predictor of local education spending, and the IV estimates continue to imply that a 10% increase in house prices raises per-pupil expenditure by roughly 4–6%. The wage-based shift-share instrument yields somewhat larger point estimates, though with wider standard errors, while the GDP-based instrument produces effects in line with earlier results. Overall, this robustness exercise confirms that the causal relationship between housing wealth and education spending is not confined to affluent areas but reflects a broader, generalizable pattern. These findings confirm that the main result is not driven solely by affluent jurisdictions, but reflects a more general relationship between local housing wealth and education spending.

```{r outliers, echo = FALSE, cache = TRUE, results = 'asis'}

mines_no_outliers <- mines_cz %>%
  group_by(unit) %>%
  filter(!any(log_real_Elem_Educ_Total_Exp_pp > 10)) %>%
  ungroup

mines_cz %>%
  ggplot(aes(x = log_real_Elem_Educ_Total_Exp_pp, y = log_real_Property_Tax_pp, colour = share_own_discrete)) +
  geom_jitter() +
    #geom_smooth(method=lm, colour = "black", linetype = "dashed") +
  labs(title = "Elem Education Expenditure pp vs Property Tax pp") +
  geom_vline(xintercept = 10, linetype = 'dashed') +
  theme_bw() +
  theme(title = element_text(size = 9)) +
  labs(colour = "Reliance on Local Sources")

forms <- list("log_real_Elem_Educ_Total_Exp_pp ~ sw(log_real_gdp_priv_ind_pc + l1_log_real_gdp_priv_ind_pc + l2_log_real_gdp_priv_ind_pc, log_weighted_annual_avg_wkly_wage + l1_log_weighted_annual_avg_wkly_wage + l2_log_weighted_annual_avg_wkly_wage, log_hpi + l1_log_hpi + l2_log_hpi + l3_log_hpi + l4_log_hpi) + log_real_Total_IG_Revenue_pp + log_Enrollment| unit + year", "log_real_Elem_Educ_Total_Exp_pp ~ log_real_Total_IG_Revenue_pp + log_real_gdp_priv_ind_pc + log_Enrollment | year + state | log_hpi ~ l(lev_ss_2d)",
"log_real_Elem_Educ_Total_Exp_pp ~ log_real_Total_IG_Revenue_pp + log_real_gdp_priv_ind_pc + log_Enrollment | year + state | log_hpi ~ l(lev_gdp_ss_2d)")


baseline <- feols(as.formula(forms[[1]]), data = left_join(mines_cz, rename(ss_temp, unit = cz_id), by = c("year","unit")), panel.id = c("unit", "year"), cluster = "unit")
wage_ss <- feols(as.formula(forms[[2]]), data = left_join(mines_cz, rename(ss_temp, unit = cz_id), by = c("year","unit")), panel.id = c("unit", "year"), cluster = "unit")
gdp_ss <- feols(as.formula(forms[[3]]), data = left_join(mines_cz, rename(ss_temp, unit = cz_id), by = c("year","unit")), panel.id = c("unit", "year"), cluster = "unit")

etable(list(baseline, wage_ss, gdp_ss), fitstat = iv_fitstats, headers = c("Baseline 1", "Baseline 2", "Baseline 3", "Wage-based SS", "GDP-based SS"), adjustbox = TRUE, tex = latex_tables, title = "Outlier Trimming Results")


```

\FloatBarrier

### State-by-state estimation

#### Baseline

\textcolor{red}{Make sure that the baseline estimation is consistent - enrollment not present as regressor! Define at top of document.}

```{r, echo = FALSE, results = 'asis'}
reg_states <- mines_cz %>%
  pull(state) %>%
  unique

mines_cz %>%
  group_by(state) %>%
  summarise(n_czs = n_distinct(cz_id)) %>%
  ggplot() +
  geom_histogram(aes(x = n_czs), bins = 20, fill = "dodgerblue4") +
  common_theme +
  labs(x = "Number of commuting zones in state", y = "Number of States",
       title = "Distribution of Number of Commuting Zones per State")
```

\FloatBarrier

### Industry by Industry 

#### GDP

```{r, echo = FALSE, warning = FALSE, message = FALSE, fig.height = 8, fig.width = 8}

dat_temp <- left_join(mines_cz, rename(ss_temp, unit = cz_id), by = c("year","unit"))


# Function to extract relevant info from each model
extract_coef_info <- function(model, state_name) {
  # Get summary
  coef_summary <- summary(model)$coeftable
  model_r2 <- r2(model, type = "wr2")

  # Filter for relevant variables
  coef_df <- as.data.frame(coef_summary) %>%
    rownames_to_column("variable") %>%
    filter(variable %in% vars_of_interest) %>%
    mutate(
      state = state_name,
      significance = case_when(
        `Pr(>|t|)` < 0.001 ~ "***",
        `Pr(>|t|)` < 0.01  ~ "**",
        `Pr(>|t|)` < 0.05  ~ "*",
        `Pr(>|t|)` < 0.1   ~ ".",
        TRUE               ~ ""
      ),
      r2_within = model_r2) %>%
    select(state, variable, estimate = Estimate, significance, r2_within)

  return(coef_df)
}

# --- 0) Inputs / variable list ------------------------------------------------
temp_vars <- ss_temp %>%
  select(starts_with("gdp_ss"), -contains("2d")) %>%  # <- fix select syntax
  names()

vars_of_interest <- c("fit_log_hpi")

# --- 1) Run models and collect estimates --------------------------------------
ind_mods <- tibble()
for (k in temp_vars) {

  # "All" model IV (your spec kept as-is)
  iv_model <- feols(
    as.formula(paste0(
      "log_real_Elem_Educ_Total_Exp_pp ~ ",
      "log_real_Total_IG_Revenue_pp + log_real_gdp_priv_ind_pc + log_Enrollment ",
      "| unit + year | log_hpi ~ l(", k, ")"
    )),
    data = dat_temp, panel.id = c("unit", "year")
  ) %>% extract_coef_info(state_name = "All")

  # State-by-state models
  state_mods_ind <- list()
  for (s in reg_states) {
    tmp <- dat_temp %>% filter(state == s)

    if (tmp %>%
        select(state, unit, year, !!k) %>%
        group_by(unit) %>%
        filter(!all(is.na(get(k)))) %>% n_groups(.) == 1) {
      # skip if no variation
    } else {
      mod <- tmp %>%
        feols(
          as.formula(paste0(
            "log_real_Elem_Educ_Total_Exp_pp ~ ",
            "log_real_Total_IG_Revenue_pp + log_real_gdp_priv_ind_pc + log_Enrollment ",
            "| unit + year | log_hpi ~ l(", k, ")"
          )),
          data = ., panel.id = c("unit", "year")
        )
      state_mods_ind[[s]] <- mod
    }
  }

  ind_mods <- imap_dfr(state_mods_ind, extract_coef_info) %>%
    rbind(iv_model) %>%
    mutate(industry = gsub("gdp_ss_", "", k)) %>%
    rbind(., ind_mods)
}

# --- 2) Map industry codes to names (using your rel_inds) ---------------------
# assumes: rel_inds is a named vector where names(rel_inds) are industry names
# and values (or names) match the 'industry' codes we created above
results_df <- ind_mods %>%
  mutate(industry_name = names(rel_inds)[match(industry, rel_inds)])

# --- 3) Clean labels (no ordering yet) ----------------------------------------
base_df <- results_df %>%
  mutate(
    label = dplyr::case_when(variable == "fit_log_hpi" ~ "HPI Effect")
  )

# --- 4) Derive the x-axis order ONLY from the All-model estimates -------------
order_levels <- base_df %>%
  filter(state == "All") %>%
  arrange(desc(estimate)) %>%
  pull(industry_name) %>%
  unique()

# --- 5) Apply order and final cleaning ----------------------------------------
results_df_cleaned <- base_df %>%
  mutate(
    industry_label   = factor(industry_name, levels = order_levels),
    overall_estimate = dplyr::if_else(state == "All", estimate, NA_real_)
  ) %>%
  filter(r2_within > 0)

# --- 6) Plot -------------------------------------------------------------------
plot <- results_df_cleaned %>%
  ggplot(aes(x = industry_label)) +
  # state-specific estimates (light x's)
  geom_point(
    data = ~ dplyr::filter(.x, state != "All" & significance != ""),
    aes(y = estimate),
    shape = 4, size = 3
  ) +
  # "All" estimate (colored by within R2)
  geom_point(
    data = ~ dplyr::filter(.x, state == "All"),
    aes(y = estimate, fill = r2_within, alpha = significance),
    size = 6, shape = 21
  ) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  common_theme +
  theme(
    legend.position = "bottom",
    axis.text.x = element_text(angle = 90, hjust = 1)
  ) +
  labs(
    title = "Effect of 1% Increase in Industry-Specific GDP on Education Expenditure per Pupil",
    x = "Industry",
    y = "Coefficient Estimate",
    caption = "Effect of 1% increase in Industry-Specific GDP (shift-share). Controls: enrollment, GDP, intergov transfers, AR(1), year & state FE.\nWithin R² of 'All' estimation in point color.",
    color = "Within R² (All model)",
    alpha = "Statistical Significance"
  ) +
  scale_fill_distiller(direction = 1, palette = "Greens")

# Lock order and finish
plot +
  scale_x_discrete(limits = order_levels,
                   labels = function(x) stringr::str_wrap(x, width = 14)) +
  coord_cartesian(ylim = c(-1, 1)) +

  scale_x_discrete(
    limits = order_levels,
    labels = function(x) stringr::str_wrap(x, width = 14)
  ) +
  guides(x = guide_axis(n.dodge = 2)) +
  coord_cartesian(clip = "off") +
  theme(
    axis.text.x  = element_text(size = 8, vjust = 1, hjust = 1, angle = 35),
    plot.margin  = margin(t = 10, r = 10, b = 70, l = 10),
    legend.position = "top"
  )

```

#### Wage
```{r, echo = FALSE, warning = FALSE, message = FALSE, fig.height = 8, fig.width = 8}

# --- 0) Inputs kept as-is -----------------------------------------------------
temp_vars <- ss_temp %>%
  select(starts_with("ss"), -contains("2d"), -contains("3d")) %>%
  names()

vars_of_interest <- c("fit_log_hpi")

# --- 1) Run models and collect estimates --------------------------------------
ind_mods <- tibble()
for (k in temp_vars) {

  # All-states IV (the "All" point)
  iv_model <- feols(
    as.formula(paste0(
      "log_real_Elem_Educ_Total_Exp_pp ~ ",
      "log_real_Total_IG_Revenue_pp + log_real_gdp_priv_ind_pc + log_Enrollment ",
      "| state + year | log_hpi ~ l(", k, ")"
    )),
    data = dat_temp, panel.id = c("unit", "year")
  ) %>% extract_coef_info(state_name = "All")

  # State-by-state models
  state_mods_ind <- list()
  for (s in reg_states) {
    tmp <- dat_temp %>% filter(state == s)

    if (tmp %>%
        select(state, unit, year, !!k) %>%
        group_by(unit) %>%
        filter(!all(is.na(get(k)))) %>% n_groups(.) == 1) {
      # skip if no variation
    } else {
      mod <- tmp %>%
        feols(
          as.formula(paste0(
            "log_real_Elem_Educ_Total_Exp_pp ~ ",
            "log_real_Total_IG_Revenue_pp + log_real_gdp_priv_ind_pc + log_Enrollment ",
            "| unit + year | log_hpi ~ l(", k, ")"
          )),
          data = ., panel.id = c("unit", "year")
        )
      state_mods_ind[[s]] <- mod
    }
  }

  ind_mods <- imap_dfr(state_mods_ind, extract_coef_info) %>%
    rbind(iv_model) %>%
    mutate(industry = gsub("ss_", "", k)) %>%
    rbind(., ind_mods)
}

# --- 2) Robust labeling (NAICS key) -------------------------------------------
naics_key <- tibble::tribble(
  ~naics_code, ~industry_name,
  "11","Agriculture, Forestry, Fishing, and Hunting",
  "21","Mining",
  "22","Utilities",
  "23","Construction",
  "31-33","Manufacturing",
  "42","Wholesale Trade",
  "44-45","Retail Trade",
  "48-49","Transportation and Warehousing",
  "51","Information",
  "52","Finance and Insurance",
  "53","Real Estate and Rental and Leasing",
  "54","Professional, Scientific, and Technical Services",
  "55","Management of Companies and Enterprises",
  "56","Administrative and waste management services",
  "61","Educational Services",
  "62","Health Care and Social Assistance",
  "71","Arts, Entertainment, and Recreation",
  "72","Accommodation and Food Services",
  "81","Other Services, except government",
  "92","Public Administration"
)

# --- 3) Clean, join labels (no ordering yet) ----------------------------------
base_df <- ind_mods %>%
  mutate(
    variable   = ifelse(variable == "fit_log_hpi", "fit_log_hpi", variable),
    label      = dplyr::case_when(variable == "fit_log_hpi" ~ "HPI Effect"),
    naics_code = gsub("^ss_", "", industry) |> gsub("_", "-", x = _)
  ) %>%
  left_join(naics_key, by = "naics_code")

# --- 4) Derive the x-axis order ONLY from the All-model estimates -------------
order_levels <- base_df %>%
  filter(state == "All") %>%
  arrange(desc(estimate)) %>%
  pull(industry_name) %>%
  unique()

# --- 5) Apply order and final cleaning ----------------------------------------
results_df_cleaned <- base_df %>%
  mutate(
    industry_label   = factor(industry_name, levels = order_levels),
    overall_estimate = dplyr::if_else(state == "All", estimate, NA_real_)
  ) %>%
  filter(!is.na(r2_within), r2_within > 0)

# --- 6) Plot -------------------------------------------------------------------
sig_levels <- c("***","**","*",".")

plot <- results_df_cleaned %>%
  ggplot(aes(x = industry_label)) +
  # state-specific estimates
  geom_point(
    data = ~ dplyr::filter(.x, state != "All" & significance != ""),
    aes(y = estimate),
    shape = 4, size = 2, alpha = 0.5,
    position = position_jitter(width = 0, height = 0.01)
  ) +
  # All (overall) estimate, colored by within R^2
  geom_point(
    data = ~ dplyr::filter(.x, state == "All"),
    aes(y = estimate, color = r2_within, shape = factor(significance, levels = sig_levels)),
    size = 4, stroke = 1
  ) +
  geom_hline(yintercept = 0, linetype = "dashed", linewidth = 0.5) +
  coord_cartesian(ylim = c(-1, 1)) +
  scale_shape_manual(
    name = "Significance",
    values = c("***" = 16, "**" = 17, "*" = 15, "." = 18),
    drop = FALSE
  ) +
  scale_color_viridis_c(name = "Within R² (All model)", option = "C", direction = 1) +
  labs(
    title = "Effect of 1% Increase in Industry-Specific Wage on Education Expenditure per Pupil",
    subtitle = "Dots: State-specific estimates (light) and overall estimate (colored by within R²)",
    x = "Industry (NAICS 2–3 digit groups)", y = "Coefficient estimate",
    caption = "IV: shift-share instrument; controls: enrollment, GDP, intergov transfers; FE: year & CZ.\nOverall points are from the 'All' model; state dots from state-level models."
  ) +
  theme_minimal(base_size = 12) +
  theme(
    legend.position = "bottom",
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
    panel.grid.minor.y = element_blank()
  )

# lock x-order and wrap labels
plot +
  scale_x_discrete(
    limits = order_levels,
    labels = function(x) stringr::str_wrap(x, width = 14)
  ) +
  guides(x = guide_axis(n.dodge = 2)) +
  coord_cartesian(clip = "off") +
  theme(
    axis.text.x  = element_text(size = 8, vjust = 1, hjust = 1, angle = 35),
    plot.margin  = margin(t = 10, r = 10, b = 70, l = 10),
    legend.position = "top"
  )
```



```{r, echo = FALSE, results = 'asis', fig.height = 8, fig.width = 10}


state_mods <- list()
for(k in reg_states){
  mod <- dat_temp %>%
    filter(state == k) %>%
    feols(as.formula("log_real_Elem_Educ_Total_Exp_pp ~ l1_log_real_Elem_Educ_Total_Exp_pp + log_weighted_annual_avg_wkly_wage + l1_log_weighted_annual_avg_wkly_wage + l2_log_weighted_annual_avg_wkly_wage + log_real_Total_IG_Revenue_pp + log_real_gdp_priv_ind_pc + log_Enrollment | unit + year"),
    data = ., panel.id = c("unit", "year"))
  state_mods[[as.character(k)]] <- mod
}

# Define variable names of interest
vars_of_interest <- c("log_weighted_annual_avg_wkly_wage",
                      "l1_log_weighted_annual_avg_wkly_wage",
                      "l2_log_weighted_annual_avg_wkly_wage")

# Function to extract relevant info from each model
extract_coef_info <- function(model, state_name) {
  # Get summary
  coef_summary <- summary(model)$coeftable
  model_r2 <- r2(model, type = "wr2")

  # Filter for relevant variables
  coef_df <- as.data.frame(coef_summary) %>%
    rownames_to_column("variable") %>%
    filter(variable %in% vars_of_interest) %>%
    mutate(
      state = state_name,
      significance = case_when(
        `Pr(>|t|)` < 0.001 ~ "***",
        `Pr(>|t|)` < 0.01  ~ "**",
        `Pr(>|t|)` < 0.05  ~ "*",
        `Pr(>|t|)` < 0.1   ~ ".",
        TRUE               ~ ""
      ),
      r2_within = model_r2) %>%
    select(state, variable, estimate = Estimate, significance, r2_within)

  return(coef_df)
}

# Apply to list of models
# Assuming: model_list is named by state names
results_df <- imap_dfr(state_mods, extract_coef_info)
results_df$state_name <- sapply(results_df$state, get_state)

results_df_cleaned <- results_df %>%
  # Add lag labels
  mutate(label = case_when(
    variable == 'log_weighted_annual_avg_wkly_wage' ~ 'l0',
    variable == 'l1_log_weighted_annual_avg_wkly_wage' ~ 'l1',
    variable == 'l2_log_weighted_annual_avg_wkly_wage' ~ 'l2'
  )) %>%
  # filter(significance != "") %>%
  # Compute total estimate and max R²
  group_by(state_name) %>%
  mutate(
    total_estimate = sum(estimate, na.rm = TRUE),
    any_significant = any(significance != ""),
    r2_within_max = max(r2_within, na.rm = TRUE)
  ) %>%
  ungroup() %>%
  # Order `state` by R²
  mutate(state_name = fct_reorder(state_name, total_estimate, .desc = TRUE)) %>%
  # Create numeric lag order (to control x-axis sorting within each state)
  mutate(
    lag_order = case_when(label == "l0" ~ 1,
                          label == "l1" ~ 2,
                          label == "l2" ~ 3),
    state_label = paste(state_name, label, sep = "_")
  ) %>%
  # Reorder state_label using combined (state, lag_order)
  arrange(state_name, lag_order) %>%
  mutate(state_label = factor(state_label, levels = unique(state_label)))


# Create axis labels: state names at 'l1' only, blanks otherwise
axis_labels <- ifelse(grepl("_l0$", levels(results_df_cleaned$state_label)),
                      gsub("_l0$", "", levels(results_df_cleaned$state_label)),
                      "")

results_df_cleaned %>%
  # Plot
  ggplot(aes(x = state_label)) +
  geom_point(aes(y = estimate, alpha = significance), shape = "x", size = 3) +
  # geom_point(
  #   data = . %>% filter(label == "l1"),
  #   aes(y = total_estimate, color = r2_within_max), size = 2
  # ) +
  geom_point(
    data = . %>% filter(label == "l1"),
    aes(y = total_estimate, color = as.numeric(any_significant)), size = 2
  ) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  common_theme +
  theme(
    legend.position = "bottom",
    axis.text.x = element_text(angle = 90, hjust = 1)
  ) +
  labs(
    title = "Effect of 1% Increase in Wage on Education Expenditure per Pupil",
    x = "States (Each with lags: l0, l1, l2)",
    y = "Coefficient Estimate",
    caption = "Effect of contemporaneous, l1, l2 lag of avg weekly wage on PP Education\n Expenditure controlling for enrollment, GDP, and intergovernmental transfers. \n Each state has 3 lagged wage coefficients (l0, l1, l2).\nBlue dots show total effect across lags, plotted at the l1 position.\n Within R^2 of state-level estimation reflected in color of point).",
    color = "Within R2 of State-level Estimation",
    alpha = "Statistical Significance"
  ) +
    scale_x_discrete(labels = axis_labels) +
  scale_color_distiller(direction = 1, palette = "Purples")

# 
# covs <- mines_cz %>%
#   select(cz_id, state, log_real_gdp_priv_ind_pc,
#          log_real_gdp_priv_ind,
#          log_real_Elem_Educ_Total_Exp_pp,
#          log_Enrollment, share_state,
#          log_weighted_annual_avg_wkly_wage,
#         #gr_weighted_annual_avg_wkly_wage,
#          #diff_log_real_gdp_priv_ind, diff_log_real_gdp_priv_ind_pc,
#         log_real_Property_Tax_pp) %>%
#   group_by(cz_id, state) %>%
#   summarise(across(everything(), ~mean(., na.rm = TRUE))) %>%
#   ungroup %>%
#   pivot_longer(!c(cz_id, state), names_to = 'covariate')
# 
# covs$state_name <- sapply(covs$state, get_state)
# 
# facet_labels <- c(
#   'log_real_gdp_priv_ind_pc' = "(log) Private Industry GDP per capita",
#   # 'diff_log_real_gdp_priv_ind_pc' = '(GR) Private Industry GDP per capita',
#   # 'diff_log_real_gdp_priv_ind' = '(GR) Private Industry GDP',
#   'log_real_gdp_priv_ind' = "(log) Private Industry GDP",
#   'log_weighted_annual_avg_wkly_wage' = '(log) Annual Avg Weekly Wage',
#   #'gr_weighted_annual_avg_wkly_wage' = '(GR) Annual Avg Weekly Wage',
#   'log_Enrollment' = '(log) Enrollment',
#   'share_state' = 'Share of Exp from State IG Transfers',
#   'log_real_Property_Tax_pp' = "(log) Property Taxes Collected per pupil"
# )


# covs %>%
#   # use ordering from coefficient estimate above
#   mutate(state_name = factor(state_name, levels = levels(results_df_cleaned$state_name))) %>%
#   ggplot(aes(x = state_name, y = value)) +
#   geom_violin(trim = FALSE, fill = "magenta", alpha = 0.2, color = NA) +
#   stat_summary(fun = median, geom = "point", position = position_dodge(width = 0.8),
#                shape = 21, size = 1.5, color = "black", fill = "magenta") +
#   facet_wrap(~covariate, ncol = 1, scales = "free", labeller = labeller(covariate = facet_labels)) +
#     theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
#   labs(title = "Value of Covariates in Order of State-level Coefficient Estimate",
#        subtitle = "Displays the distribution of various covariates by state.",
#        y = "Value",
#        x = "State (in order of coefficient estimate on wage level as in previous plot)")
# 
# # --- Collapse covariates to state level (mean across CZs) ---
# covs_state <- covs %>%
#   group_by(state_name, covariate) %>%
#   summarise(mean_value = mean(value, na.rm = TRUE), .groups = "drop") %>%
#   pivot_wider(names_from = covariate, values_from = mean_value)
# 
# # --- Extract state-level total_estimate from regression results ---
# estimates_state <- results_df_cleaned %>%
#   group_by(state_name) %>%
#   summarise(total_estimate = unique(total_estimate), .groups = "drop")
# 
# # --- Join estimates and covariates ---
# state_data <- left_join(estimates_state, covs_state, by = "state_name")
# 
# # --- Compute correlations (with total_estimate vs each covariate) ---
# corrs <- state_data %>%
#   select(-state_name) %>%
#   cor(use = "pairwise.complete.obs") %>%
#   as.data.frame() %>%
#   rownames_to_column("var")
# 
# # Filter correlations with total_estimate only
# corrs_total <- corrs %>%
#   filter(var != "total_estimate") %>%
#   select(var, total_estimate) %>%
#   arrange(desc(abs(total_estimate)))
# 
# # --- Plot correlation coefficients ---
# p_corr <- ggplot(corrs_total, aes(x = reorder(var, total_estimate), y = total_estimate)) +
#   geom_col(fill = "steelblue") +
#   geom_hline(yintercept = 0, linetype = "dashed") +
#   coord_flip() +
#   labs(
#     title = "Correlation of State-level Regression Estimates with Covariates",
#     x = "Covariate",
#     y = "Correlation with total_estimate"
#   ) +
#   theme_minimal()
# 
# print(p_corr)
# 
# # state_scatter <- state_data %>%
# #   pivot_longer(-c(state_name, total_estimate), names_to = "covariate", values_to = "value")
# # 
# # ggplot(state_scatter, aes(x = value, y = total_estimate, label = state_name)) +
# #   geom_point(color = "steelblue") +
# #   geom_smooth(method = "lm", se = FALSE, color = "black") +
# #   ggrepel::geom_text_repel(size = 3) +
# #   facet_wrap(~covariate, scales = "free_x") +
# #   labs(title = "State-level Scatterplots: Regression Estimates vs Covariates",
# #        x = "Covariate Value", y = "Total Estimate") +
# #   theme_minimal()
# 
# corr_state_cov <- covs %>%
#   left_join(results_df_cleaned %>% select(state_name, total_estimate), by = c("state_name")) %>%
#   group_by(state_name, covariate) %>%
#   summarise(r = cor(value, total_estimate, use = "pairwise.complete.obs"), .groups = "drop")
# 
# ggplot(corr_state_cov, aes(x = covariate, y = state_name, fill = r)) +
#   geom_tile() +
#   scale_fill_gradient2(limits = c(-1, 1)) +
#   labs(title = "Correlation Heatmap by State and Covariate",
#        x = "Covariate", y = "State", fill = "Correlation") +
#   theme_minimal() +
#   theme(axis.text.x = element_text(angle = 45, hjust = 1))


```

\FloatBarrier

#### Shift-share

```{r, echo = FALSE, fig.height = 8, fig.width = 10}

state_mods_ss <- list()
for(k in reg_states){
  mod <- dat_temp %>%
    filter(state == k) %>%
    feols(as.formula("log_real_Elem_Educ_Total_Exp_pp ~ log_real_Total_IG_Revenue_pp + log_real_gdp_priv_ind_pc + log_Enrollment + l1_log_real_Elem_Educ_Total_Exp_pp | unit + year | log_hpi ~ l(gdp_ss_2d,1)"),
    data = ., panel.id = c("unit", "year"))
  state_mods_ss[[as.character(k)]] <- mod
}

# Define variable names of interest
vars_of_interest <- c("fit_log_hpi")

# Apply to list of models
# Assuming: model_list is named by state names
results_df <- imap_dfr(state_mods_ss, extract_coef_info)
results_df$state_name <- sapply(results_df$state, get_state)

results_df_cleaned <- results_df %>%
  # Add lag labels
  mutate(label = case_when(
    variable == 'fit_log_hpi' ~ 'HPI Effect'
  )) %>%
  #filter(significance != "") %>%
  # Compute total estimate and max R²
filter(r2_within > 0) %>%
  # Order `state` by R²
  mutate(state_name = fct_reorder(state_name, estimate, .desc = TRUE)) %>%
  # Reorder state_label using combined (state, lag_order)
  arrange(state_name) %>%
  mutate(state_label = factor(state_name, levels = unique(state_name)))

# Create axis labels: state names at 'l1' only, blanks otherwise
axis_labels <- levels(results_df_cleaned$state_label)

results_df_cleaned %>%
  # Plot
  ggplot(aes(x = state_label)) +
# Fill layer (with alpha by significance)
geom_point(
  aes(y = estimate, fill = r2_within, shape = significance),
   size = 4) +
geom_point(aes(y = estimate), shape = 21, size = 4, fill = NA, color = "black", stroke = 0.25, alpha = 1) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  common_theme +
  theme(
    legend.position = "bottom",
    axis.text.x = element_text(angle = 90, hjust = 1)
  ) +
  labs(
    title = "Effect of 1% Increase in SS GDP Instrument on Education Expenditure per Pupil",
    x = "States",
    y = "Coefficient Estimate",
    caption = "Effect of l1 of GDP SS Instrument on PP Education\n Expenditure controlling for enrollment, GDP, and intergovernmental transfers and AR(1) term.\n Within R^2 of state-level estimation reflected in color of point).",
    color = "Within R2 of State-level Estimation",
    alpha = "Statistical Significance"
  ) +
    scale_x_discrete(labels = axis_labels)  +
  scale_fill_distiller(direction = 1) +
  scale_shape_manual(
  values = c(
    "***" = 21,
    "**"  = 22,
    "*"   = 23,
    "."   = 24#,
    #""    = 25  # non-significant
  )
)

# 
# covs <- mines_cz %>%
#   select(cz_id, state, log_real_gdp_priv_ind_pc,
#          log_real_gdp_priv_ind,
#          log_real_Elem_Educ_Total_Exp_pp,
#          log_Enrollment, share_state,
#          log_weighted_annual_avg_wkly_wage,
#         #gr_weighted_annual_avg_wkly_wage,
#          #diff_log_real_gdp_priv_ind, diff_log_real_gdp_priv_ind_pc,
#         log_real_Property_Tax_pp) %>%
#   group_by(cz_id, state) %>%
#   summarise(across(everything(), ~mean(., na.rm = TRUE))) %>%
#   ungroup %>%
#   pivot_longer(!c(cz_id, state), names_to = 'covariate')
# 
# covs$state_name <- sapply(covs$state, get_state)
# 
# facet_labels <- c(
#   'log_real_gdp_priv_ind_pc' = "(log) Private Industry GDP per capita",
#   # 'diff_log_real_gdp_priv_ind_pc' = '(GR) Private Industry GDP per capita',
#   # 'diff_log_real_gdp_priv_ind' = '(GR) Private Industry GDP',
#   'log_real_gdp_priv_ind' = "(log) Private Industry GDP",
#   'log_weighted_annual_avg_wkly_wage' = '(log) Annual Avg Weekly Wage',
#   #'gr_weighted_annual_avg_wkly_wage' = '(GR) Annual Avg Weekly Wage',
#   'log_Enrollment' = '(log) Enrollment',
#   'share_state' = 'Share of Exp from State IG Transfers',
#   'log_real_Property_Tax_pp' = "(log) Property Taxes Collected per pupil"
# )
# 
# 
# covs %>%
#   # use ordering from coefficient estimate above
#   mutate(state_name = factor(state_name, levels = levels(results_df_cleaned$state_name))) %>%
#   ggplot(aes(x = state_name, y = value)) +
#   geom_violin(trim = FALSE, fill = "magenta", alpha = 0.2, color = NA) +
#   stat_summary(fun = median, geom = "point", position = position_dodge(width = 0.8),
#                shape = 21, size = 1.5, color = "black", fill = "magenta") +
#   facet_wrap(~covariate, ncol = 1, scales = "free", labeller = labeller(covariate = facet_labels)) +
#     theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
#   labs(title = "Value of Covariates in Order of State-level Coefficient Estimate",
#        subtitle = "Displays the distribution of various covariates by state.",
#        y = "Value",
#        x = "State (in order of coefficient estimate on wage level as in previous plot)")


```

```{r, echo = FALSE, fig.height = 8, fig.width = 10}

state_mods_ss <- list()
for(k in reg_states){
  mod <- dat_temp %>%
    filter(state == k) %>%
    feols(as.formula("log_real_Elem_Educ_Total_Exp_pp ~ log_real_Total_IG_Revenue_pp + log_real_gdp_priv_ind_pc + log_Enrollment + l1_log_real_Elem_Educ_Total_Exp_pp | unit + year | log_hpi ~ l(ss_2d,1)"),
    data = ., panel.id = c("unit", "year"))
  state_mods_ss[[as.character(k)]] <- mod
}

# Define variable names of interest
vars_of_interest <- c("fit_log_hpi")

# Apply to list of models
# Assuming: model_list is named by state names
results_df <- imap_dfr(state_mods_ss, extract_coef_info)
results_df$state_name <- sapply(results_df$state, get_state)

results_df_cleaned <- results_df %>%
  # Add lag labels
  mutate(label = case_when(
    variable == 'fit_log_hpi' ~ 'HPI Effect'
  )) %>%
  #filter(significance != "") %>%
  # Compute total estimate and max R²
filter(r2_within > 0) %>%
  # Order `state` by R²
  mutate(state_name = fct_reorder(state_name, estimate, .desc = TRUE)) %>%
  # Reorder state_label using combined (state, lag_order)
  arrange(state_name) %>%
  mutate(state_label = factor(state_name, levels = unique(state_name)))

# Create axis labels: state names at 'l1' only, blanks otherwise
axis_labels <- levels(results_df_cleaned$state_label)

results_df_cleaned %>%
  # Plot
  ggplot(aes(x = state_label)) +
# Fill layer (with alpha by significance)
geom_point(
  aes(y = estimate, fill = r2_within, shape = significance),
   size = 4) +
geom_point(aes(y = estimate), shape = 21, size = 4, fill = NA, color = "black", stroke = 0.25, alpha = 1) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  common_theme +
  theme(
    legend.position = "bottom",
    axis.text.x = element_text(angle = 90, hjust = 1)
  ) +
  labs(
    title = "Effect of 1% Increase in SS Wage Instrument on Education Expenditure per Pupil",
    x = "States",
    y = "Coefficient Estimate",
    caption = "Effect of l1 of Wage SS Instrument on PP Education\n Expenditure controlling for enrollment, GDP, and intergovernmental transfers and AR(1) term.\n Within R^2 of state-level estimation reflected in color of point).",
    color = "Within R2 of State-level Estimation",
    alpha = "Statistical Significance"
  ) +
    scale_x_discrete(labels = axis_labels)  +
  scale_fill_distiller(direction = 1, palette = "Oranges") +
  scale_shape_manual(
  values = c(
    "***" = 21,
    "**"  = 22,
    "*"   = 23,
    "."   = 24#,
    #""    = 25  # non-significant
  )
)
# 
# 
# covs <- mines_cz %>%
#   select(cz_id, state, log_real_gdp_priv_ind_pc,
#          log_real_gdp_priv_ind,
#          log_real_Elem_Educ_Total_Exp_pp,
#          log_Enrollment, share_state,
#          log_weighted_annual_avg_wkly_wage,
#         #gr_weighted_annual_avg_wkly_wage,
#          #diff_log_real_gdp_priv_ind, diff_log_real_gdp_priv_ind_pc,
#         log_real_Property_Tax_pp) %>%
#   group_by(cz_id, state) %>%
#   summarise(across(everything(), ~mean(., na.rm = TRUE))) %>%
#   ungroup %>%
#   pivot_longer(!c(cz_id, state), names_to = 'covariate')
# 
# covs$state_name <- sapply(covs$state, get_state)
# 
# facet_labels <- c(
#   'log_real_gdp_priv_ind_pc' = "(log) Private Industry GDP per capita",
#   # 'diff_log_real_gdp_priv_ind_pc' = '(GR) Private Industry GDP per capita',
#   # 'diff_log_real_gdp_priv_ind' = '(GR) Private Industry GDP',
#   'log_real_gdp_priv_ind' = "(log) Private Industry GDP",
#   'log_weighted_annual_avg_wkly_wage' = '(log) Annual Avg Weekly Wage',
#   #'gr_weighted_annual_avg_wkly_wage' = '(GR) Annual Avg Weekly Wage',
#   'log_Enrollment' = '(log) Enrollment',
#   'share_state' = 'Share of Exp from State IG Transfers',
#   'log_real_Property_Tax_pp' = "(log) Property Taxes Collected per pupil"
# )
# 
# 
# covs %>%
#   # use ordering from coefficient estimate above
#   mutate(state_name = factor(state_name, levels = levels(results_df_cleaned$state_name))) %>%
#   ggplot(aes(x = state_name, y = value)) +
#   geom_violin(trim = FALSE, fill = "magenta", alpha = 0.2, color = NA) +
#   stat_summary(fun = median, geom = "point", position = position_dodge(width = 0.8),
#                shape = 21, size = 1.5, color = "black", fill = "magenta") +
#   facet_wrap(~covariate, ncol = 1, scales = "free", labeller = labeller(covariate = facet_labels)) +
#     theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
#   labs(title = "Value of Covariates in Order of State-level Coefficient Estimate",
#        subtitle = "Displays the distribution of various covariates by state.",
#        y = "Value",
#        x = "State (in order of coefficient estimate on wage level as in previous plot)")


```


\FloatBarrier



```{r, echo = FALSE, include = FALSE, eval = FALSE, results = 'asis'}

# compute_ss takes the source data "QCEW" or "QWI", a base year for the Bartik, whether to compute at CZ or fips level. This si then passed to plot_ss() which returns the instrumetn for a specific industry code and a plot.
if(new_ss_calculation){
  ss_temp_old <- compute_ss_old(source = "QCEW", base_year = 2004, unit_id = "cz_id")
  saveRDS(ss_temp_old, here("code/ss_cache_manual/ss_temp_old.RDS"))
}else{
  ss_temp_old <- readRDS(here("code/ss_cache_manual/ss_temp_old.RDS"))
}


# ind_codes %>% filter(nchar(industry_code) == 2 & industry_code != 99)  %>% select(-keep, -industry_code) %>% xtable() %>% print(include.rownames = FALSE)

ind_mods <- list()
inds <- ind_codes %>% filter(nchar(industry_code) == 2 & !(industry_code %in% c(10, 99))) %>% pull(industry_code) %>% unique
i <- 0
for(k in inds){
    print(k)
    ss_inst <- ss_temp_old %>%
      plot_ss_old(., k, "gr_natl_annual_avg_wkly_wage_", "cz_id", ind_codes)
    name <- ind_codes %>% filter(industry_code == k) %>% pull(industry_title)

    mods <- list()
    for(df in names(dfs)){
      print(df)
      # IV regression using shift-share instrument
      temp_dat <- left_join(dfs[[df]], rename(ss_inst, unit = cz_id), by = c("year", "unit"))
      stopifnot(temp_dat %>% group_by(cz_id, year) %>% n_groups == nrow(temp_dat))
      iv_model <- feols(
        as.formula(paste0("log_real_Elem_Educ_Total_Exp_pp ~ log_real_Total_IG_Revenue_pp + log_real_gdp_priv_ind_pc + log_Enrollment + l1_log_real_Elem_Educ_Total_Exp_pp | state + year | log_hpi ~ l(ss_", k, ",1)")),
        data = temp_dat, panel.id = c("unit", "year")
      )
      mods[[df]] <- iv_model
    }
    ind_mods[[as.character(k)]] <- mods
}

for(k in names(ind_mods)){
  etable(ind_mods[[k]], title = k, tex = latex_tables, headers = names(ind_mods[[k]]),  adjustbox = TRUE) %>% print()
}

# Filter the list of models for significant log_real_gdp_priv_ind_pc coefficients
significant_mods <- mods[sapply(mods, function(m) {
  coefs <- summary(m)$coeftable
  if ("fit_log_hpi" %in% rownames(coefs)) {
    return(coefs["fit_log_hpi", "Pr(>|t|)"] < 0.05)}
  } else {
    return(FALSE)
  }
})]

```

### Quantile Regression

```{r, echo = FALSE, cache = TRUE, fig.height = 8, fig.width = 10}

# Step 1: Remove fixed effects (Canay 2-step)
fe_model <- feols(log_real_Elem_Educ_Total_Exp_pp ~ l1_log_real_Elem_Educ_Total_Exp_pp+
                    log_weighted_annual_avg_wkly_wage +
                                      l1_log_weighted_annual_avg_wkly_wage +
                                      l2_log_weighted_annual_avg_wkly_wage +
                                      log_real_Total_IG_Revenue_pp +
                                      log_real_gdp_priv_ind_pc +
                                      log_Enrollment | unit + year, data = dat_temp) %>%
  tidy(.) %>%
  mutate(model = "OLS",
         tau = "1")

# Step 3: Run quantile regression on residuals at multiple quantiles
taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
qr_models <- map(taus, ~ rq(log_real_Elem_Educ_Total_Exp_pp ~ l1_log_real_Elem_Educ_Total_Exp_pp+ log_weighted_annual_avg_wkly_wage +
                                      l1_log_weighted_annual_avg_wkly_wage +
                                      l2_log_weighted_annual_avg_wkly_wage +
                                      log_real_Total_IG_Revenue_pp +
                                      log_real_gdp_priv_ind_pc +
                                      log_Enrollment,
                            data = dat_temp, tau = .x))

# Step 4: Tidy results and add quantile info
qr_tidy <- map2_dfr(qr_models, taus, ~ tidy(.x) %>% mutate(tau = as.character(.y), model = "quantile"))

term_levels <- c("(Intercept)", "AR(1)", "L0 Wage", "L1 Wage", "L2 Wage",
                 "Enrollment", "IG Rev pp", "Ind. GDP pc")

# Step 5: Add significance stars and reshape
qr_tidy <- qr_tidy %>%
  rbind(fe_model) %>%
  mutate(
    p.value = 2 * (1 - pnorm(abs(statistic))),
    sig = case_when(
      p.value < 0.001 ~ "***",
      p.value < 0.01  ~ "**",
      p.value < 0.05  ~ "*",
      p.value < 0.1   ~ ".",
      TRUE ~ ""
    ),
    # Relabel variables for readability
    term = recode(term,
      "l1_log_real_Elem_Educ_Total_Exp_pp" = "AR(1)",
      "log_real_Total_IG_Revenue_pp" = "IG Rev pp",
      "log_real_gdp_priv_ind_pc" = "Ind. GDP pc",
      "log_Enrollment" = "Enrollment",
      "log_weighted_annual_avg_wkly_wage" = "L0 Wage",
      "l1_log_weighted_annual_avg_wkly_wage" = "L1 Wage",
      "l2_log_weighted_annual_avg_wkly_wage" = "L2 Wage"
    ),
    term = factor(term, levels = term_levels),
    xpos = as.numeric(term),

    # Combine shape and color label
    model_label = case_when(
      model == "OLS" ~ "OLS",
      TRUE ~ paste0("Quantile τ = ", tau)
    )
  )

# Plot with unified legend and updated shape mapping
qr_tidy %>%
  ggplot(aes(x = xpos, y = estimate, color = model_label, shape = model_label, alpha = sig)) +
  geom_point(position = position_dodge(width = 0.6), size = 3) +
  geom_errorbar(
    aes(ymin = estimate - 1.96 * std.error,
        ymax = estimate + 1.96 * std.error),
    height = 0.2,
    position = position_dodge(width = 0.6)
  ) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  theme_minimal() +
  labs(
    title = "Coefficient Estimates from OLS and Quantile Regressions",
    x = "Estimate",
    y = NULL,
    color = "Model Type",
    shape = "Model Type"
  ) +
  theme(
    legend.position = "right",
    panel.grid.minor.y = element_blank(),
    panel.grid.major.y = element_line(linetype = "dashed"),
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_line(color = "slategrey")
  ) +
  scale_shape_manual(values = c(
    "OLS" = 17,  # triangle
    "Quantile τ = 0.1" = 16,
    "Quantile τ = 0.25" = 16,
    "Quantile τ = 0.5" = 16,
    "Quantile τ = 0.75" = 16,
    "Quantile τ = 0.9" = 16
  )) +
  scale_x_continuous(
    breaks = 1:length(term_levels),
    labels = term_levels
  )


```

```{r appendix_pvar, include = FALSE, echo = FALSE, results = 'asis'}
panel_lines <- c(
  "$$",
  "Y_{it} = \\alpha_i +  \\sum_{k = 1}^{4} \\gamma_{k}A_{i,t-k} + \\beta X_{it} + \\varepsilon_{it}",
  "$$",
  "",
  "Where we approach a level and per capita value expression of the",
  "relationship between total education expenditure, intergovernmental",
  "revenue, house prices conditioned on GDP and wage levels.",
  "",
  "$$",
  "Y_{it} =",
  "\\begin{bmatrix}",
  "\\log(\\text{real Total Educ. Exp.})_{it} \\\\",
  "\\log(\\text{real Total IG Revenue})_{it} \\\\",
  "\\log(\\text{HPI})_{it}",
  "\\end{bmatrix},",
  "\\quad",
  "X_{it} =",
  "\\begin{bmatrix}",
  "\\log(\\text{real GDP})_{it} \\\\",
  "\\log(\\text{wage})_{it}",
  "\\end{bmatrix}",
  "$$",
  "",
  "- $A_1, A_2, A_3, A_4$ are $3 \\times 3$ coefficient matrices",
  "- $\\beta$ is a $3 \\times 2$ matrix of coefficients on the exogenous variables",
  "- $\\alpha_i$ is a vector of unit fixed effects",
  "- $\\varepsilon_{it}$ is the error term",
  "",
  "Where",
  "",
  "$$",
  "Y_{it} =",
  "\\begin{bmatrix}",
  "\\log(\\text{real Own Source Rev. per person})_{it} \\\\",
  "\\log(\\text{real IG Revenue per person})_{it} \\\\",
  "\\log(\\text{wage})_{it} \\\\",
  "\\log(\\text{HPI})_{it}",
  "\\end{bmatrix},",
  "\\quad",
  "X_{it} =",
  "\\begin{bmatrix}",
  "\\log(\\text{real GDP per capita})_{it}",
  "\\end{bmatrix}",
  "$$",
  "",
  "- $A_1, A_2, A_3, A_4$ are $4 \\times 4$ coefficient matrices",
  "- $B$ is a $4 \\times 1$ coefficient matrix",
  "- $\\alpha_i$ unit fixed effects",
  "- $\\varepsilon_{it}$ error term"
)

append_to_appendix("## Panel VAR Specification", panel_lines)


pvar_data <- mines_cz %>%
  #select(unit, year, contains("real_Total_Educ_Total_Exp"), contains("real_gdp_total")) %>%
  drop_na() %>%
  data.frame()

# Estimate PVAR with 1 lag
pvar_model_levels <- pvarfeols(
  dependent_vars = c("log_real_Total_Educ_Total_Exp",
                     #"log_real_Total_Rev_Own_Sources",
                     #"log_real_gdp_priv_ind",
                     #"log_real_Property_Tax",
                     "log_real_Total_IG_Revenue", #"log_real_Total_Fed_IG_Revenue_pp",
                     #"log_weighted_annual_avg_wkly_wage",
                     "log_hpi"),
  exog_vars = c("log_real_gdp_priv_ind", "log_weighted_annual_avg_wkly_wage"), #"share_own",
  lags = 4,
  #transformation = "demean",   # alternative: "firstdiff"
  data = pvar_data,
  panel_identifier = c("unit", "year")
)

pvar_model_levels_pc <- pvarfeols(
  dependent_vars = c(#"log_real_Total_Educ_Total_Exp_pp", #"log_real_gdp_priv_ind_pc",
                     "log_real_Total_Rev_Own_Sources_pp",
                     #"log_real_Property_Tax_pp",
                     "log_real_Total_IG_Revenue_pp",
                     "log_weighted_annual_avg_wkly_wage", #"log_real_Total_State_IG_Revenue_pp", "log_real_Total_Fed_IG_Revenue_pp",
                     "log_hpi"),
  exog_vars = c("log_real_gdp_priv_ind_pc"), #"share_own",
  lags = 4,
  #transformation = "demean",   # alternative: "firstdiff"
  data = pvar_data,
  panel_identifier = c("unit", "year")
)

for(mod in list(pvar_model_levels, pvar_model_levels_pc)){
  #summary(mod) %>% print

  # Impulse response function
  irf_result <- mod %>% girf(n.ahead = 10, ma_approx_steps= 10)

  # irf_result_bootstrapped <- bootstrap_irf(mod, typeof_irf = c("GIRF"),
  #           n.ahead = 10,
  #           nof_Nstar_draws = 3,
  #           confidence.band = 0.95,
  #           mc.cores = 5)
  # Plot IRFs
  plot(irf_result, scales = "free") %>% print()
  cat("    \n")
  cat("    \n")
  cat("    \n")
  cat("    \n")
}


# # Get shock variables (names of shock sources)
# shock_vars <- names(irf_result)
# irf_df <- map_dfr(shock_vars, function(shock) {
#   lower_matrix <- irf_result_bootstrapped$Lower[[shock]]
#   upper_matrix <- irf_result_bootstrapped$Upper[[shock]]
#
#   # Calculate mean pointwise IRF from bootstrap draws
#   mean_matrix <- (lower_matrix + upper_matrix) / 2
#
#   expand.grid(
#     horizon = seq_len(nrow(mean_matrix)),
#     response = colnames(mean_matrix)
#   ) %>%
#     mutate(
#       shock = shock,
#       irf = as.vector(mean_matrix),
#       lower = as.vector(lower_matrix),
#       upper = as.vector(upper_matrix)
#     )
# })
# ggplot(irf_df, aes(x = horizon, y = irf)) +
#   geom_line(color = "steelblue") +
#   geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2, fill = "steelblue") +
#   facet_grid(response ~ shock, scales = "free_y") +
#   labs(
#     title = "Impulse Response Functions with 95% Confidence Intervals",
#     x = "Horizon",
#     y = "Response"
#   ) +
#   theme_minimal()

```

<!-- # Property Prices -->

<!-- ```{r, echo = FALSE, results = 'asis', cache = TRUE} -->

<!-- # is <- isatpanel( -->
<!-- #       data = data.frame(mines_cz), -->
<!-- #       formula = as.formula("log_hpi ~ log_weighted_annual_avg_wkly_wage + l1_log_weighted_annual_avg_wkly_wage + l2_log_weighted_annual_avg_wkly_wage"), -->
<!-- #       index = c("unit", "year"), -->
<!-- #       effect = "twoways", -->
<!-- #       #iis = TRUE, -->
<!-- #       fesis = TRUE, -->
<!-- #       #ar = 1, -->
<!-- #       t.pval = 0.01, -->
<!-- #       max.block.size = 5 -->
<!-- #     ) -->

<!-- fun_list <- c(log_hpi ~ log_weighted_annual_avg_wkly_wage + l1_log_weighted_annual_avg_wkly_wage + l2_log_weighted_annual_avg_wkly_wage + log_real_gdp_priv_ind | unit + year, -->

<!-- gr_hpi ~ gr_weighted_annual_avg_wkly_wage + l1_gr_weighted_annual_avg_wkly_wage + l2_gr_weighted_annual_avg_wkly_wage | unit + year, -->

<!-- log_real_Elem_Educ_Total_Exp ~ log_weighted_annual_avg_wkly_wage + l1_log_weighted_annual_avg_wkly_wage + l2_log_weighted_annual_avg_wkly_wage + log_real_gdp_priv_ind + l1_log_real_gdp_priv_ind + l2_log_real_gdp_priv_ind | unit + year, -->

<!-- diff_log_real_Elem_Educ_Total_Exp ~ gr_weighted_annual_avg_wkly_wage + l1_gr_weighted_annual_avg_wkly_wage + l2_gr_weighted_annual_avg_wkly_wage + diff_log_real_gdp_priv_ind + l1_diff_log_real_gdp_priv_ind + l2_diff_log_real_gdp_priv_ind | unit + year, -->

<!-- log_real_Elem_Educ_Total_Exp_pp ~ log_weighted_annual_avg_wkly_wage + l1_log_weighted_annual_avg_wkly_wage + l2_log_weighted_annual_avg_wkly_wage + log_real_gdp_priv_ind_pc + l1_log_real_gdp_priv_ind_pc + l2_log_real_gdp_priv_ind_pc | unit + year, -->

<!-- diff_log_real_Elem_Educ_Total_Exp_pp ~ gr_weighted_annual_avg_wkly_wage + l1_gr_weighted_annual_avg_wkly_wage + l2_gr_weighted_annual_avg_wkly_wage + diff_log_real_gdp_priv_ind_pc + l1_diff_log_real_gdp_priv_ind_pc + l2_diff_log_real_gdp_priv_ind_pc | unit + year) -->

<!-- run_model(fun_list, mines_no_outliers) %>% etable(tex = latex_tables, adjustbox = TRUE) -->

<!-- ``` -->

<!-- ```{r, echo = FALSE, results = 'asis', cache = TRUE} -->
<!-- # General-to-Specific model selection using fixest -->
<!-- gets_fixest <- function(dep_var, indep_vars, data, fe = NULL, pval_cutoff = 0.1) { -->
<!--   remaining_vars <- indep_vars -->

<!--   repeat { -->
<!--     # Build formula -->
<!--     rhs <- paste(remaining_vars, collapse = " + ") -->
<!--     formula_str <- as.formula(paste(dep_var, "~", rhs, if (!is.null(fe)) paste("|", fe) else "")) -->

<!--     # Estimate model -->
<!--     model <- feols(formula_str, data = data) -->
<!--     coefs <- summary(model)$coeftable -->

<!--     # Filter out only the coefficients from the explanatory variables -->
<!--     pvals <- coefs[, "Pr(>|t|)"] -->
<!--     pvals <- pvals[names(pvals) %in% remaining_vars] -->

<!--     # Stop if all variables are below the cutoff or no variables remain -->
<!--     if (length(pvals) == 0 || all(pvals < pval_cutoff)) break -->

<!--     # Remove the variable with the highest p-value -->
<!--     worst_var <- names(which.max(pvals)) -->
<!--     remaining_vars <- setdiff(remaining_vars, worst_var) -->
<!--   } -->

<!--   # Return the final reduced model -->
<!--   final_formula <- paste(dep_var, "~", paste(remaining_vars, collapse = " + "), if (!is.null(fe)) paste("|", fe) else "") -->
<!--   return(final_formula) -->
<!-- } -->

<!-- # Example usage -->
<!-- # Replace 'your_data' with your actual data frame name -->
<!-- final_model <- gets_fixest( -->
<!--   dep_var = "log_real_Elem_Educ_Total_Exp_pp", -->
<!--   indep_vars = c("log_weighted_annual_avg_wkly_wage", -->
<!--                  "l1_log_weighted_annual_avg_wkly_wage", -->
<!--                  "l2_log_weighted_annual_avg_wkly_wage", -->
<!--                  "log_real_gdp_priv_ind_pc", -->
<!--                  "l1_log_real_gdp_priv_ind_pc", -->
<!--                  "l2_log_real_gdp_priv_ind_pc", -->
<!--                  "log_real_Property_Tax_pp", -->
<!--                  #"log_real_Total_State_IG_Revenue_pp", -->
<!--                  #"log_real_Total_Fed_IG_Revenue_pp", -->
<!--                  "log_hpi"),  # replace with your actual variable names -->
<!--   data = mines_cz, -->
<!--   fe = "unit + year",        # optional fixed effects -->
<!--   pval_cutoff = 0.1         # significance threshold -->
<!-- ) -->

<!-- # View results -->
<!-- # At a 10% significance level, we retain a 2-timeperiod lag of real_gdp_pc, contemporaneous wage (not likely), property_tax_pp, state_revenue_pp, hpi -->
<!-- feols(as.formula(final_model), data = mines_cz) %>% etable(adjustbox = TRUE, tex = latex_tables) -->


<!-- # I want to allow the coefficient to vary on the weekly wage treatment variable -->
<!-- feols(as.formula(gsub("log_weighted_annual_avg_wkly_wage", "i(share_own_discrete, log_weighted_annual_avg_wkly_wage)", final_model)), data = mines_cz) %>% -->
<!--   etable(adjustbox = TRUE, tex = latex_tables) -->

<!-- ``` -->

<!-- ```{r, cache = TRUE} -->

<!-- test <- readRDS(here("output/prop_price_breaks_csis.RDS")) -->

<!-- ``` -->

# Results{#sec-results}



# Discussion{#sec-discussion}




# Conclusion{#sec-conclusion}

The determinants of inequality in public education delivery in the US
are multiple and complex. Significant evidence exists of the role of
historically discriminatory policies related to congressional
districting, under-investment in low-income areas of color. Though this
work does not directly inform this debate, further work could explore
the extent to which wage growth interacts with such structural policies.

```{r, child = "appendix_generated.qmd"}


```
